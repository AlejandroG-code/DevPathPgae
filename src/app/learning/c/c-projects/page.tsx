/* eslint-disable @typescript-eslint/no-unused-vars */
// src/app/learning/c/c-projects/page.tsx
'use client'; 

import React, { useEffect } from 'react';
import ReactMarkdown, { Components } from 'react-markdown';
import rehypeRaw from 'rehype-raw';
import LessonSidebar from '@/app/_components/LessonSidebar'; // Adjust path if _components is not used
import { useParams } from 'next/navigation'; // Needed for useEffect dependencies

// Extend the Window interface to include the Prism property
declare global {
  interface Window {
    Prism?: {
      highlightAll: () => void;
    };
  }
}

interface LessonPageProps {
  params: {
    courseId: string;
    lessonId: string;
  };
}

const LESSON_CONTENT = `
## C Projects

When you write a C program, especially a larger one, it's common to organize your code into multiple files rather than putting everything into a single 'main.c' file. This approach improves modularity, readability, maintainability, and compilation efficiency.

### Typical Project Structure

A typical C project might look something like this:

\`\`\`
my_project/
├── src/
│   ├── main.c           # Contains the main function, application entry point
│   ├── module1.c        # Source file for module 1 (implementations)
│   ├── module2.c        # Source file for module 2 (implementations)
│   └── ...
├── include/
│   ├── module1.h        # Header file for module 1 (declarations/prototypes)
│   ├── module2.h        # Header file for module 2 (declarations/prototypes)
│   └── ...
├── Makefile             # (Optional but common) For automating compilation
├── README.md            # Project description
└── ...
\`\`\`

* **'.c' files (Source Files):** Contain the actual implementation of functions, global variables, and other definitions. These are compiled into object files ('.o').
* **'.h' files (Header Files):** Contain function prototypes, structure definitions, enum declarations, and macro definitions. They serve as interfaces for other source files that want to use the functions or data types defined in the corresponding '.c' file.
* **'Makefile':** A script used by the 'make' utility to automate the compilation and linking process for complex projects with many source files.

### The Compilation Process (Multi-File)

When you compile a multi-file C project, it typically involves several steps, usually orchestrated by a build system like 'make' or an IDE:

1.  **Preprocessing:** The preprocessor handles directives like '#include', '#define', '#ifdef', etc. It expands macros and includes the content of header files.
2.  **Compilation:** Each '.c' source file is compiled independently into an **object file** ('.o' or '.obj'). This step translates C code into machine-readable code but doesn't resolve external references (like calls to functions in other '.c' files).
3.  **Linking:** The linker takes all the object files generated by the compiler, along with any necessary library files (e.g., standard C library), and combines them into a single **executable program**. It resolves all external function calls and variable references.

**Example Compilation (using 'gcc' on Linux/macOS):**

Let's say you have 'main.c', 'utils.c', and 'utils.h':

* **'utils.h':**
    \`\`\`c
    // include/utils.h
    #ifndef UTILS_H
    #define UTILS_H

    // Function prototype
    int add(int a, int b);

    #endif
    \`\`\`

* **'utils.c':**
    \`\`\`c
    // src/utils.c
    #include "utils.h" // Include its own header for consistency

    // Function definition
    int add(int a, int b) {
        return a + b;
    }
    \`\`\`

* **'main.c':**
    \`\`\`c
    // src/main.c
    #include <stdio.h>
    #include "utils.h" // Include the header for our utility functions

    int main() {
        int result = add(5, 3);
        printf("Sum: %d\\n", result);
        return 0;
    }
    \`\`\`

**Manual Compilation Steps:**

1.  **Compile 'utils.c' to an object file:**
    \`\`\`bash
    gcc -c src/utils.c -o obj/utils.o -Iinclude
    \`\`\`
    * '-c': Compile only, do not link.
    * '-o obj/utils.o': Output object file to 'obj/utils.o'.
    * '-Iinclude': Tell the compiler to look for header files in the 'include' directory.

2.  **Compile 'main.c' to an object file:**
    \`\`\`bash
    gcc -c src/main.c -o obj/main.o -Iinclude
    \`\`\`

3.  **Link the object files to create the executable:**
    \`\`\`bash
    gcc obj/main.o obj/utils.o -o my_program
    \`\`\`
    * '-o my_program': Output the final executable named 'my_program'.

4.  **Run the program:**
    \`\`\`bash
    ./my_program
    \`\`\`

### Using a 'Makefile' (Simplified Example)

For larger projects, managing these compilation commands manually becomes cumbersome. A 'Makefile' automates this.

\`\`\`makefile
# Makefile
CC = gcc
CFLAGS = -Wall -Wextra -Iinclude # -Wall: enable all warnings, -Wextra: extra warnings
LDFLAGS = # Linker flags, e.g., -lm for math library
SRCDIR = src
OBJDIR = obj
BINDIR = bin

SOURCES = $(wildcard $(SRCDIR)/*.c) # Finds all .c files in src/
OBJECTS = $(patsubst $(SRCDIR)/%.c,$(OBJDIR)/%.o,$(SOURCES)) # Changes .c to .o and src/ to obj/
TARGET = $(BINDIR)/my_program

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(OBJECTS)
	@mkdir -p $(BINDIR)
	$(CC) $(OBJECTS) -o $(TARGET) $(LDFLAGS)
	@echo "Build successful: $(TARGET)"

$(OBJDIR)/%.o: $(SRCDIR)/%.c
	@mkdir -p $(OBJDIR)
	$(CC) $(CFLAGS) -c $< -o $@
	@echo "Compiled $<"

clean:
	@echo "Cleaning..."
	@rm -f $(OBJDIR)/*.o $(BINDIR)/*
	@rmdir $(OBJDIR) $(BINDIR) 2>/dev/null || true # Remove dirs, suppress error if empty/not exists
	@echo "Clean complete."
\`\`\`
To use this 'Makefile', save it as 'Makefile' (no extension) in your project root, create 'src', 'include', 'obj', 'bin' directories, place your '.c' and '.h' files, then run 'make' in the terminal.

Understanding project structure and compilation flow is essential for building and managing real-world C applications.
`;

export default function CProjectsPage({ params }: LessonPageProps) {
  const { courseId, lessonId } = useParams<{ courseId: string; lessonId: string }>();

  useEffect(() => {
    const link = document.createElement('link');
    link.href = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css';
    link.rel = 'stylesheet';
    document.head.appendChild(link);

    const scriptCore = document.createElement('script');
    scriptCore.src = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js';
    scriptCore.async = true;

    scriptCore.onload = () => {
      const scriptCLang = document.createElement('script');
      scriptCLang.src = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js';
      scriptCLang.async = true;

      const scriptBashLang = document.createElement('script'); // For bash/makefile examples
      scriptBashLang.src = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js';
      scriptBashLang.async = true;

      scriptCLang.onload = () => {
        document.body.appendChild(scriptBashLang); // Append Bash script
        scriptBashLang.onload = () => {
          if (window.Prism) {
            window.Prism.highlightAll();
          }
        };
      };
      document.body.appendChild(scriptCLang);
    };
    document.body.appendChild(scriptCore);

    return () => {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    };
  }, [LESSON_CONTENT, courseId, lessonId]);

  return (
    <div className="flex min-h-screen"> 
      <LessonSidebar /> 
      
      <main className="flex-1 ml-0 md:ml-64"> 
        <div className="lesson-content p-4 md:p-8 bg-gray-900 text-white rounded-lg shadow-xl">
          <ReactMarkdown
            rehypePlugins={[rehypeRaw]}
            components={{
              code: ({ inline, className, children, ...props }: React.HTMLAttributes<HTMLElement> & { inline?: boolean }) => {
                const match = /language-(\w+)/.exec(className || '');
                const lang = match ? match[1] : 'markup'; 

                return !inline ? (
                  <pre className="my-4 rounded-lg overflow-x-auto border border-gray-700 bg-[#1a1b26] p-4 text-sm">
                    <code className={`language-${lang}`} {...props}>
                      {String(children).replace(/\n$/, '')}
                    </code>
                  </pre>
                ) : (
                  <code className="bg-gray-700 text-vibrant-teal px-1 py-0.5 rounded-md text-xs" {...props}>
                    {children}
                  </code>
                );
              },
              h1: ({ node, ...props }) => <h1 className="text-4xl md:text-5xl font-extrabold text-vibrant-teal mb-4 mt-8 drop-shadow-md" {...props} />,
              h2: ({ node, ...props }) => <h2 className="text-3xl font-bold text-white mb-3 mt-6 border-b border-gray-700 pb-2" {...props} />,
              h3: ({ node, ...props }) => <h3 className="text-2xl font-semibold text-vibrant-teal mb-2 mt-5" {...props} />,
              p: ({ node, ...props }) => <p className="text-lg text-gray-300 mb-4 leading-relaxed" {...props} />,
              strong: ({ node, ...props }) => <strong className="font-bold text-vibrant-teal" {...props} />,
              a: ({ node, ...props }) => <a className="text-accent-purple hover:underline" {...props} />,
              table: ({ node, ...props }) => <table className="w-full text-left border-collapse my-6" {...props} />,
              th: ({ node, ...props }) => <th className="p-3 border-b-2 border-gray-600 text-white font-semibold bg-gray-700" {...props} />,
              td: ({ node, ...props }) => <td className="p-3 border-b border-gray-700 text-gray-300" {...props} />,
            }}
          >
            {LESSON_CONTENT}
          </ReactMarkdown>
        </div>
      </main>
    </div>
  );
}
