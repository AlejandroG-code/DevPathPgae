[
    {
      "id": "hard-1",
      "title": "Median of Two Sorted Arrays",
      "description": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays. The overall run time complexity should be `O(log (m+n))`.",
      "examples": [
        { "input": "[1,3], [2]", "output": "2.0" },
        { "input": "[1,2], [3,4]", "output": "2.5" }
      ],
      "hints": ["This is a binary search problem. The key is to find a partition point in both arrays such that elements to the left are less than or equal to elements to the right."],
      "solutionJs": "function findMedianSortedArrays(nums1, nums2) {\n  const m = nums1.length;\n  const n = nums2.length;\n  if (m > n) return findMedianSortedArrays(nums2, nums1); // Ensure nums1 is smaller\n\n  let low = 0;\n  let high = m;\n  const halfLen = Math.floor((m + n + 1) / 2);\n\n  while (low <= high) {\n    const i = Math.floor((low + high) / 2); // partition point for nums1\n    const j = halfLen - i; // partition point for nums2\n\n    const maxLeft1 = (i === 0) ? -Infinity : nums1[i - 1];\n    const minRight1 = (i === m) ? Infinity : nums1[i];\n\n    const maxLeft2 = (j === 0) ? -Infinity : nums2[j - 1];\n    const minRight2 = (j === n) ? Infinity : nums2[j];\n\n    if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n      // Partition is correct\n      if ((m + n) % 2 === 1) {\n        return Math.max(maxLeft1, maxLeft2);\n      } else {\n        return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2;\n      }\n    } else if (maxLeft1 > minRight2) {\n      high = i - 1;\n    } else {\n      low = i + 1;\n    }\n  }\n}",
      "solutionPython": "def find_median_sorted_arrays(nums1, nums2):\n  m, n = len(nums1), len(nums2)\n  if m > n: return find_median_sorted_arrays(nums2, nums1)\n\n  low, high = 0, m\n  half_len = (m + n + 1) // 2\n\n  while low <= high:\n    i = (low + high) // 2\n    j = half_len - i\n\n    max_left_1 = float('-inf') if i == 0 else nums1[i-1]\n    min_right_1 = float('inf') if i == m else nums1[i]\n\n    max_left_2 = float('-inf') if j == 0 else nums2[j-1]\n    min_right_2 = float('inf') if j == n else nums2[j]\n\n    if max_left_1 <= min_right_2 and max_left_2 <= min_right_1:\n      if (m + n) % 2 == 1:\n        return max(max_left_1, max_left_2)\n      else:\n        return (max(max_left_1, max_left_2) + min(min_right_1, min_right_2)) / 2.0\n    elif max_left_1 > min_right_2:\n      high = i - 1\n    else:\n      low = i + 1",
      "solutionJava": "class Solution {\n  public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    int m = nums1.length;\n    int n = nums2.length;\n    if (m > n) return findMedianSortedArrays(nums2, nums1); // Ensure nums1 is smaller\n\n    int low = 0;\n    int high = m;\n    int halfLen = (m + n + 1) / 2;\n\n    while (low <= high) {\n      int i = low + (high - low) / 2;\n      int j = halfLen - i;\n\n      int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];\n      int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i];\n\n      int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];\n      int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j];\n\n      if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n        if ((m + n) % 2 == 1) {\n          return (double) Math.max(maxLeft1, maxLeft2);\n        } else {\n          return (double) (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;\n        }\n      } else if (maxLeft1 > minRight2) {\n        high = i - 1;\n      } else {\n        low = i + 1;\n      }\n    }\n    return 0.0;\n  }\n}",
      "solutionCpp": "double findMedianSortedArrays(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n  int m = nums1.size();\n  int n = nums2.size();\n  if (m > n) {\n    return findMedianSortedArrays(nums2, nums1); // Ensure nums1 is smaller\n  }\n\n  int low = 0;\n  int high = m;\n  int halfLen = (m + n + 1) / 2;\n\n  while (low <= high) {\n    int i = low + (high - low) / 2; // partition point for nums1\n    int j = halfLen - i; // partition point for nums2\n\n    int maxLeft1 = (i == 0) ? std::numeric_limits<int>::min() : nums1[i - 1];\n    int minRight1 = (i == m) ? std::numeric_limits<int>::max() : nums1[i];\n\n    int maxLeft2 = (j == 0) ? std::numeric_limits<int>::min() : nums2[j - 1];\n    int minRight2 = (j == n) ? std::numeric_limits<int>::max() : nums2[j];\n\n    if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n      if ((m + n) % 2 == 1) {\n        return static_cast<double>(std::max(maxLeft1, maxLeft2));\n      } else {\n        return static_cast<double>(std::max(maxLeft1, maxLeft2) + std::min(minRight1, minRight2)) / 2.0;\n      }\n    } else if (maxLeft1 > minRight2) {\n      high = i - 1;\n    } else {\n      low = i + 1;\n    }\n  }\n  return 0.0;\n}",
      "difficulty": "Hard",
      "score": 250
    },
    {
      "id": "hard-2",
      "title": "Trapping Rain Water",
      "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
      "examples": [
        { "input": "[0,1,0,2,1,0,1,3,2,1,2,1]", "output": "6" },
        { "input": "[4,2,0,3,2,5]", "output": "9" }
      ],
      "hints": ["Use two pointers, one from left, one from right. Keep track of `max_left` and `max_right`."],
      "solutionJs": "function trap(height) {\n  if (height.length === 0) return 0;\n  let left = 0, right = height.length - 1;\n  let leftMax = 0, rightMax = 0;\n  let totalWater = 0;\n  while (left < right) {\n    if (height[left] < height[right]) {\n      if (height[left] >= leftMax) {\n        leftMax = height[left];\n      } else {\n        totalWater += leftMax - height[left];\n      }\n      left++;\n    } else {\n      if (height[right] >= rightMax) {\n        rightMax = height[right];\n      } else {\n        totalWater += rightMax - height[right];\n      }\n      right--;\n    }\n  }\n  return totalWater;\n}",
      "solutionPython": "def trap(height):\n  if not height: return 0\n  left, right = 0, len(height) - 1\n  left_max, right_max = 0, 0\n  total_water = 0\n  while left < right:\n    if height[left] < height[right]:\n      if height[left] >= left_max:\n        left_max = height[left]\n      else:\n        total_water += left_max - height[left]\n      left += 1\n    else:\n      if height[right] >= right_max:\n        right_max = height[right]\n      else:\n        total_water += right_max - height[right]\n      right -= 1\n  return total_water",
      "solutionJava": "class Solution {\n  public int trap(int[] height) {\n    if (height.length == 0) return 0;\n    int left = 0, right = height.length - 1;\n    int leftMax = 0, rightMax = 0;\n    int totalWater = 0;\n    while (left < right) {\n      if (height[left] < height[right]) {\n        if (height[left] >= leftMax) {\n          leftMax = height[left];\n        } else {\n          totalWater += leftMax - height[left];\n        }\n        left++;\n      } else {\n        if (height[right] >= rightMax) {\n          rightMax = height[right];\n        } else {\n          totalWater += rightMax - height[right];\n        }\n        right--;\n      }\n    }\n    return totalWater;\n  }\n}",
      "solutionCpp": "int trap(const std::vector<int>& height) {\n  if (height.empty()) return 0;\n  int left = 0, right = height.size() - 1;\n  int leftMax = 0, rightMax = 0;\n  int totalWater = 0;\n  while (left < right) {\n    if (height[left] < height[right]) {\n      if (height[left] >= leftMax) {\n        leftMax = height[left];\n      } else {\n        totalWater += leftMax - height[left];\n      }\n      left++;\n    } else {\n      if (height[right] >= rightMax) {\n        rightMax = height[right];\n      } else {\n        totalWater += rightMax - height[right];\n      }\n      right--;\n    }\n  }\n  return totalWater;\n}",
      "difficulty": "Hard",
      "score": 280
    },
    {
      "id": "hard-3",
      "title": "Word Break II",
      "description": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. You may assume the dictionary does not contain duplicate words.",
      "examples": [
        { "input": "\"leetcode\", [\"leet\",\"code\"]", "output": "[\"leet code\"]" },
        { "input": "\"applepenapple\", [\"apple\",\"pen\"]", "output": "[\"apple pen apple\"]" }
      ],
      "hints": ["This is a backtracking problem, potentially with memoization to optimize."],
      "solutionJs": "function wordBreak(s, wordDict) {\n  const memo = new Map();\n  const dictSet = new Set(wordDict);\n\n  function backtrack(index) {\n    if (index === s.length) {\n      return [''];\n    }\n    if (memo.has(index)) {\n      return memo.get(index);\n    }\n\n    const results = [];\n    for (let i = index; i < s.length; i++) {\n      const word = s.substring(index, i + 1);\n      if (dictSet.has(word)) {\n        const restOfSentences = backtrack(i + 1);\n        for (const sentence of restOfSentences) {\n          if (sentence === '') {\n            results.push(word);\n          } else {\n            results.push(word + ' ' + sentence);\n          }\n        }\n      }\n    }\n    memo.set(index, results);\n    return results;\n  }\n  return backtrack(0);\n}",
      "solutionPython": "def word_break(s, word_dict):\n  memo = {}\n  word_set = set(word_dict)\n\n  def backtrack(index):\n    if index == len(s):\n      return ['']\n    if index in memo:\n      return memo[index]\n\n    results = []\n    for i in range(index, len(s)):\n      word = s[index : i+1]\n      if word in word_set:\n        rest_of_sentences = backtrack(i + 1)\n        for sentence in rest_of_sentences:\n          if not sentence:\n            results.append(word)\n          else:\n            results.append(word + ' ' + sentence)\n    memo[index] = results\n    return results\n\n  return backtrack(0)",
      "solutionJava": "import java.util.*;\nclass Solution {\n  Map<Integer, List<String>> memo = new HashMap<>();\n  Set<String> wordSet;\n  String s;\n\n  public List<String> wordBreak(String s, List<String> wordDict) {\n    this.wordSet = new HashSet<>(wordDict);\n    this.s = s;\n    return backtrack(0);\n  }\n\n  private List<String> backtrack(int index) {\n    if (index == s.length()) {\n      return Arrays.asList(\"\");\n    }\n    if (memo.containsKey(index)) {\n      return memo.get(index);\n    }\n\n    List<String> results = new ArrayList<>();\n    for (int i = index; i < s.length(); i++) {\n      String word = s.substring(index, i + 1);\n      if (wordSet.contains(word)) {\n        List<String> restOfSentences = backtrack(i + 1);\n        for (String sentence : restOfSentences) {\n          if (sentence.isEmpty()) {\n            results.add(word);\n          } else {\n            results.add(word + \" \" + sentence);\n          }\n        }\n      }\n    }\n    memo.put(index, results);\n    return results;\n  }\n}",
      "solutionCpp": "std::unordered_map<int, std::vector<std::string>> memo;\nstd::unordered_set<std::string> wordSet;\nstd::string s_global;\n\nstd::vector<std::string> backtrack(int index) {\n    if (index == s_global.length()) {\n        return {\"\"};\n    }\n    if (memo.count(index)) {\n        return memo[index];\n    }\n\n    std::vector<std::string> results;\n    for (int i = index; i < s_global.length(); ++i) {\n        std::string word = s_global.substr(index, i - index + 1);\n        if (wordSet.count(word)) {\n            std::vector<std::string> restOfSentences = backtrack(i + 1);\n            for (const std::string& sentence : restOfSentences) {\n                if (sentence.empty()) {\n                    results.push_back(word);\n                } else {\n                    results.push_back(word + \" \" + sentence);\n                }\n            }\n        }\n    }\n    return memo[index] = results;\n}\n\nstd::vector<std::string> wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    s_global = s;\n    wordSet.clear();\n    for (const std::string& word : wordDict) {\n        wordSet.insert(word);\n    }\n    memo.clear();\n    return backtrack(0);\n}",
      "difficulty": "Hard",
      "score": 270
    },
    {
      "id": "hard-4",
      "title": "Sudoku Solver",
      "description": "Write a program to solve a Sudoku puzzle by filling the empty cells. A Sudoku solution must satisfy all of the following rules: 1. Each of the digits 1-9 must occur exactly once in each row. 2. Each of the digits 1-9 must occur exactly once in each column. 3. Each of the digits 1-9 must occur exactly once in each of the nine 3x3 sub-boxes of the grid. The '.' character indicates empty cells.",
      "examples": [
        { "input": "[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\"\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]", "output": "(Solved Sudoku Grid)" }
      ],
      "hints": ["Use backtracking. For each empty cell, try placing digits from 1 to 9. If a placement is valid, recurse. If it leads to a dead end, backtrack."],
      "solutionJs": "function solveSudoku(board) {\n  const N = 9;\n\n  function isValid(row, col, char) {\n    for (let i = 0; i < N; i++) {\n      if (board[row][i] === char || board[i][col] === char) return false;\n      const boxRow = Math.floor(row / 3) * 3 + Math.floor(i / 3);\n      const boxCol = Math.floor(col / 3) * 3 + (i % 3);\n      if (board[boxRow][boxCol] === char) return false;\n    }\n    return true;\n  }\n\n  function solve() {\n    for (let r = 0; r < N; r++) {\n      for (let c = 0; c < N; c++) {\n        if (board[r][c] === '.') {\n          for (let num = 1; num <= 9; num++) {\n            const char = String(num);\n            if (isValid(r, c, char)) {\n              board[r][c] = char;\n              if (solve()) return true;\n              board[r][c] = '.'; // Backtrack\n            }\n          }\n          return false; // No valid number for this cell\n        }\n      }\n    }\n    return true; // All cells filled\n  }\n  solve();\n}",
      "solutionPython": "def solve_sudoku(board):\n  N = 9\n  def is_valid(r, c, num_str):\n    for i in range(N):\n      if board[r][i] == num_str or board[i][c] == num_str: return False\n      box_row = (r // 3) * 3 + (i // 3)\n      box_col = (c // 3) * 3 + (i % 3)\n      if board[box_row][box_col] == num_str: return False\n    return True\n\n  def solve():\n    for r in range(N):\n      for c in range(N):\n        if board[r][c] == '.':\n          for num in range(1, 10):\n            num_str = str(num)\n            if is_valid(r, c, num_str):\n              board[r][c] = num_str\n              if solve(): return True\n              board[r][c] = '.' # Backtrack\n          return False # No valid number\n    return True # All cells filled\n  solve()",
      "solutionJava": "class Solution {\n  public void solveSudoku(char[][] board) {\n    solve(board);\n  }\n\n  private boolean solve(char[][] board) {\n    for (int r = 0; r < 9; r++) {\n      for (int c = 0; c < 9; c++) {\n        if (board[r][c] == '.') {\n          for (char num = '1'; num <= '9'; num++) {\n            if (isValid(board, r, c, num)) {\n              board[r][c] = num;\n              if (solve(board)) return true;\n              board[r][c] = '.'; // Backtrack\n            }\n          }\n          return false; // No valid number\n        }\n      }\n    }\n    return true; // All cells filled\n  }\n\n  private boolean isValid(char[][] board, int row, int col, char num) {\n    for (int i = 0; i < 9; i++) {\n      if (board[row][i] == num || board[i][col] == num) return false;\n      int boxRow = (row / 3) * 3 + (i / 3);\n      int boxCol = (col / 3) * 3 + (i % 3);\n      if (board[boxRow][boxCol] == num) return false;\n    }\n    return true;\n  }\n}",
      "solutionCpp": "bool isValid(std::vector<std::vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; ++i) {\n        if (board[row][i] == c || board[i][col] == c) return false;\n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\n    }\n    return true;\n}\n\nbool solve(std::vector<std::vector<char>>& board) {\n    for (int i = 0; i < 9; ++i) {\n        for (int j = 0; j < 9; ++j) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; ++c) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n                        if (solve(board)) return true;\n                        else board[i][j] = '.'; // Backtrack\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(std::vector<std::vector<char>>& board) {\n    solve(board);\n}",
      "difficulty": "Hard",
      "score": 300
    },
    {
      "id": "hard-5",
      "title": "Regular Expression Matching",
      "description": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where: `'.'` Matches any single character. `'*'` Matches zero or more of the preceding element. The matching should cover the entire input string (not partial).",
      "examples": [
        { "input": "s = \"aa\", p = \"a\"", "output": "false" },
        { "input": "s = \"aa\", p = \"a*\"", "output": "true" },
        { "input": "s = \"ab\", p = \".*\"", "output": "true" }
      ],
      "hints": ["Use dynamic programming. `dp[i][j]` represents whether `s[0...i-1]` matches `p[0...j-1]`."],
      "solutionJs": "function isMatch(s, p) {\n  const m = s.length;\n  const n = p.length;\n  const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(false));\n  dp[0][0] = true;\n\n  for (let j = 1; j <= n; j++) {\n    if (p[j - 1] === '*') {\n      dp[0][j] = dp[0][j - 2];\n    }\n  }\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (s[i - 1] === p[j - 1] || p[j - 1] === '.') {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else if (p[j - 1] === '*') {\n        dp[i][j] = dp[i][j - 2]; // Zero occurrences\n        if (s[i - 1] === p[j - 2] || p[j - 2] === '.') {\n          dp[i][j] = dp[i][j] || dp[i - 1][j]; // One or more occurrences\n        }\n      }\n    }\n  }\n  return dp[m][n];\n}",
      "solutionPython": "def is_match(s, p):\n  m, n = len(s), len(p)\n  dp = [[False] * (n + 1) for _ in range(m + 1)]\n  dp[0][0] = True\n\n  for j in range(1, n + 1):\n    if p[j - 1] == '*':\n      dp[0][j] = dp[0][j - 2]\n\n  for i in range(1, m + 1):\n    for j in range(1, n + 1):\n      if s[i - 1] == p[j - 1] or p[j - 1] == '.':\n        dp[i][j] = dp[i - 1][j - 1]\n      elif p[j - 1] == '*':\n        dp[i][j] = dp[i][j - 2] # Zero occurrences\n        if p[j - 2] == '.' or p[j - 2] == s[i - 1]:\n          dp[i][j] = dp[i][j] or dp[i - 1][j] # One or more occurrences\n  return dp[m][n]",
      "solutionJava": "class Solution {\n  public boolean isMatch(String s, String p) {\n    int m = s.length();\n    int n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n      if (p.charAt(j - 1) == '*') {\n        dp[0][j] = dp[0][j - 2];\n      }\n    }\n\n    for (int i = 1; i <= m; i++) {\n      for (int j = 1; j <= n; j++) {\n        if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {\n          dp[i][j] = dp[i - 1][j - 1];\n        } else if (p.charAt(j - 1) == '*') {\n          dp[i][j] = dp[i][j - 2]; // Zero occurrences\n          if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)) {\n            dp[i][j] = dp[i][j] || dp[i - 1][j]; // One or more occurrences\n          }\n        }\n      }\n    }\n    return dp[m][n];\n  }\n}",
      "solutionCpp": "bool isMatch(const std::string& s, const std::string& p) {\n  int m = s.length();\n  int n = p.length();\n  std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n  dp[0][0] = true;\n\n  for (int j = 1; j <= n; ++j) {\n    if (p[j - 1] == '*') {\n      dp[0][j] = dp[0][j - 2];\n    }\n  }\n\n  for (int i = 1; i <= m; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      if (s[i - 1] == p[j - 1] || p[j - 1] == '.') {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else if (p[j - 1] == '*') {\n        dp[i][j] = dp[i][j - 2]; // Zero occurrences\n        if (p[j - 2] == '.' || p[j - 2] == s[i - 1]) {\n          dp[i][j] = dp[i][j] || dp[i - 1][j]; // One or more occurrences\n        }\n      }\n    }\n  }\n  return dp[m][n];\n}",
      "difficulty": "Hard",
      "score": 290
    },
    {
      "id": "hard-6",
      "title": "Merge k Sorted Lists",
      "description": "You are given an array of `k` linked-lists `lists`, each sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
      "examples": [
        { "input": "lists = [[1,4,5],[1,3,4],[2,6]]", "output": "[1,1,2,3,4,4,5,6]" },
        { "input": "lists = []", "output": "[]" }
      ],
      "hints": ["Use a min-priority queue (min-heap) to keep track of the smallest current element from all lists. Alternatively, use a divide and conquer approach to merge two lists at a time."],
      "solutionJs": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n * this.val = (val===undefined ? 0 : val)\n * this.next = (next===undefined ? null : next)\n * }\n */\n// Helper for merging two sorted lists\nfunction mergeTwoLists(l1, l2) {\n  if (!l1) return l2;\n  if (!l2) return l1;\n  if (l1.val < l2.val) {\n    l1.next = mergeTwoLists(l1.next, l2);\n    return l1;\n  } else {\n    l2.next = mergeTwoLists(l1, l2.next);\n    return l2;\n  }\n}\n\nfunction mergeKLists(lists) {\n  if (!lists || lists.length === 0) return null;\n  if (lists.length === 1) return lists[0];\n\n  let interval = 1;\n  while (interval < lists.length) {\n    for (let i = 0; i + interval < lists.length; i = i + interval * 2) {\n      lists[i] = mergeTwoLists(lists[i], lists[i + interval]);\n    }\n    interval *= 2;\n  }\n  return lists[0];\n}",
      "solutionPython": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nimport heapq\ndef merge_k_lists(lists):\n  min_heap = []\n  # Push (value, list_node_reference) into heap\n  for i, node in enumerate(lists):\n    if node:\n      heapq.heappush(min_heap, (node.val, i, node)) # Added index to handle ties consistently for Python 3.x\n\n  dummy = ListNode(0)\n  current = dummy\n\n  while min_heap:\n    val, list_idx, node = heapq.heappop(min_heap)\n    current.next = node\n    current = current.next\n    if node.next:\n      heapq.heappush(min_heap, (node.next.val, list_idx, node.next))\n\n  return dummy.next",
      "solutionJava": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; }\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nimport java.util.PriorityQueue;\nclass Solution {\n  public ListNode mergeKLists(ListNode[] lists) {\n    if (lists == null || lists.length == 0) return null;\n    PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\n    for (ListNode node : lists) {\n      if (node != null) {\n        minHeap.add(node);\n      }\n    }\n    ListNode dummy = new ListNode(0);\n    ListNode current = dummy;\n    while (!minHeap.isEmpty()) {\n      ListNode smallest = minHeap.poll();\n      current.next = smallest;\n      current = current.next;\n      if (smallest.next != null) {\n        minHeap.add(smallest.next);\n      }\n    }\n    return dummy.next;\n  }\n}",
      "solutionCpp": "struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nstruct CompareListNode {\n    bool operator()(ListNode* a, ListNode* b) {\n        return a->val > b->val;\n    }\n};\n\nclass Solution {\npublic:\n    ListNode* mergeKLists(std::vector<ListNode*>& lists) {\n        if (lists.empty()) return nullptr;\n\n        std::priority_queue<ListNode*, std::vector<ListNode*>, CompareListNode> pq;\n\n        for (ListNode* list : lists) {\n            if (list) {\n                pq.push(list);\n            }\n        }\n\n        ListNode dummy(0);\n        ListNode* current = &dummy;\n\n        while (!pq.empty()) {\n            ListNode* smallest = pq.top();\n            pq.pop();\n            current->next = smallest;\n            current = current->next;\n            if (smallest->next) {\n                pq.push(smallest->next);\n            }\n        }\n        return dummy.next;\n    }\n};",
      "difficulty": "Hard",
      "score": 260
    },
    {
      "id": "hard-7",
      "title": "Longest Consecutive Sequence",
      "description": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in `O(n)` time.",
      "examples": [
        { "input": "[100,4,200,1,3,2]", "output": "4 (1, 2, 3, 4)" },
        { "input": "[0,3,7,2,5,8,4,6,0,1]", "output": "9" }
      ],
      "hints": ["Put all numbers into a hash set for `O(1)` average time lookups. Then iterate through the set, and for each number, check if it's the start of a sequence (i.e., `num - 1` is not in the set). If it is, build the sequence."],
      "solutionJs": "function longestConsecutive(nums) {\n  if (nums.length === 0) return 0;\n  const numSet = new Set(nums);\n  let maxLength = 0;\n\n  for (const num of numSet) {\n    // Check if current num is the start of a sequence\n    if (!numSet.has(num - 1)) {\n      let currentNum = num;\n      let currentLength = 1;\n      while (numSet.has(currentNum + 1)) {\n        currentNum++;\n        currentLength++;\n      }\n      maxLength = Math.max(maxLength, currentLength);\n    }\n  }\n  return maxLength;\n}",
      "solutionPython": "def longest_consecutive(nums):\n  if not nums: return 0\n  num_set = set(nums)\n  max_length = 0\n  for num in num_set:\n    if (num - 1) not in num_set: # Start of a sequence\n      current_num = num;\n      current_length = 1;\n      while (current_num + 1) in num_set:\n        current_num += 1;\n        current_length += 1;\n      max_length = max(max_length, current_length);\n  return max_length",
      "solutionJava": "import java.util.HashSet;\nclass Solution {\n  public int longestConsecutive(int[] nums) {\n    if (nums.length == 0) return 0;\n    HashSet<Integer> numSet = new HashSet<>();\n    for (int num : nums) numSet.add(num);\n    int maxLength = 0;\n    for (int num : numSet) {\n      if (!numSet.contains(num - 1)) { // Start of a sequence\n        int currentNum = num;\n        int currentLength = 1;\n        while (numSet.contains(currentNum + 1)) {\n          currentNum++;\n          currentLength++;\n        }\n        maxLength = Math.max(maxLength, currentLength);\n      }\n    }\n    return maxLength;\n  }\n}",
      "solutionCpp": "int longestConsecutive(const std::vector<int>& nums) {\n  if (nums.empty()) return 0;\n  std::unordered_set<int> numSet(nums.begin(), nums.end());\n  int maxLength = 0;\n\n  for (int num : nums) {\n    if (numSet.find(num - 1) == numSet.end()) { // Is this the start of a sequence?\n      int currentNum = num;\n      int currentLength = 1;\n      while (numSet.count(currentNum + 1)) {\n        currentNum++;\n        currentLength++;\n      }\n      maxLength = std::max(maxLength, currentLength);\n    }\n  }\n  return maxLength;\n}",
      "difficulty": "Hard",
      "score": 255
    },
    {
      "id": "hard-8",
      "title": "N-Queens",
      "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer `n`, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.",
      "examples": [
        { "input": "n = 4", "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]" },
        { "input": "n = 1", "output": "[[\"Q\"]]" }
      ],
      "hints": ["Use backtracking. Keep track of occupied columns, diagonals (row+col), and anti-diagonals (row-col)."],
      "solutionJs": "function solveNQueens(n) {\n  const result = [];\n  const board = Array(n).fill(0).map(() => Array(n).fill('.'));\n\n  const cols = new Set();\n  const diag1 = new Set(); // r + c\n  const diag2 = new Set(); // r - c\n\n  function backtrack(r) {\n    if (r === n) {\n      result.push(board.map(row => row.join('')));\n      return;\n    }\n\n    for (let c = 0; c < n; c++) {\n      if (!cols.has(c) && !diag1.has(r + c) && !diag2.has(r - c)) {\n        board[r][c] = 'Q';\n        cols.add(c);\n        diag1.add(r + c);\n        diag2.add(r - c);\n\n        backtrack(r + 1);\n\n        board[r][c] = '.'; // Backtrack\n        cols.delete(c);\n        diag1.delete(r + c);\n        diag2.delete(r - c);\n      }\n    }\n  }\n  backtrack(0);\n  return result;\n}",
      "solutionPython": "def solve_n_queens(n):\n  result = []\n  board = [['.' for _ in range(n)] for _ in range(n)]\n  cols = set()\n  diag1 = set() # r + c\n  diag2 = set() # r - c\n\n  def backtrack(r):\n    if r == n:\n      result.append([\" \".join(row) for row in board])\n      return\n\n    for c in range(n):\n      if c not in cols and (r + c) not in diag1 and (r - c) not in diag2:\n        board[r][c] = 'Q'\n        cols.add(c)\n        diag1.add(r + c)\n        diag2.add(r - c)\n\n        backtrack(r + 1)\n\n        board[r][c] = '.' # Backtrack\n        cols.remove(c)\n        diag1.remove(r + c)\n        diag2.remove(r - c)\n\n  backtrack(0)\n  return result",
      "solutionJava": "import java.util.*;\nclass Solution {\n  public List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    char[][] board = new char[n][n];\n    for (int i = 0; i < n; i++) {\n      Arrays.fill(board[i], '.');\n    }\n\n    Set<Integer> cols = new HashSet<>();\n    Set<Integer> diag1 = new HashSet<>(); // r + c\n    Set<Integer> diag2 = new HashSet<>(); // r - c\n\n    backtrack(0, n, board, cols, diag1, diag2, result);\n    return result;\n  }\n\n  private void backtrack(int r, int n, char[][] board, Set<Integer> cols, Set<Integer> diag1, Set<Integer> diag2, List<List<String>> result) {\n    if (r == n) {\n      List<String> currentBoard = new ArrayList<>();\n      for (int i = 0; i < n; i++) {\n        currentBoard.add(new String(board[i]));\n      }\n      result.add(currentBoard);\n      return;\n    }\n\n    for (int c = 0; c < n; c++) {\n      if (!cols.contains(c) && !diag1.contains(r + c) && !diag2.contains(r - c)) {\n        board[r][c] = 'Q';\n        cols.add(c);\n        diag1.add(r + c);\n        diag2.add(r - c);\n\n        backtrack(r + 1, n, board, cols, diag1, diag2, result);\n\n        board[r][c] = '.'; // Backtrack\n        cols.remove(c);\n        diag1.remove(r + c);\n        diag2.remove(r - c);\n      }\n    }\n  }\n}",
      "solutionCpp": "class Solution {\npublic:\n    std::vector<std::vector<std::string>> solveNQueens(int n) {\n        std::vector<std::vector<std::string>> result;\n        std::vector<std::string> board(n, std::string(n, '.'));\n\n        std::vector<bool> cols(n, false);\n        std::vector<bool> diag1(2 * n - 1, false); // r + c\n        std::vector<bool> diag2(2 * n - 1, false); // r - c + n - 1 (to shift index)\n\n        backtrack(0, n, board, cols, diag1, diag2, result);\n        return result;\n    }\n\nprivate:\n    void backtrack(int r, int n, std::vector<std::string>& board, std::vector<bool>& cols, \n                   std::vector<bool>& diag1, std::vector<bool>& diag2, \n                   std::vector<std::vector<std::string>>& result) {\n        if (r == n) {\n            result.push_back(board);\n            return;\n        }\n\n        for (int c = 0; c < n; ++c) {\n            if (!cols[c] && !diag1[r + c] && !diag2[r - c + n - 1]) {\n                board[r][c] = 'Q';\n                cols[c] = true;\n                diag1[r + c] = true;\n                diag2[r - c + n - 1] = true;\n\n                backtrack(r + 1, n, board, cols, diag1, diag2, result);\n\n                board[r][c] = '.'; // Backtrack\n                cols[c] = false;\n                diag1[r + c] = false;\n                diag2[r - c + n - 1] = false;\n            }\n        }\n    }\n};",
      "difficulty": "Hard",
      "score": 295
    },
    {
      "id": "hard-9",
      "title": "Longest Valid Parentheses",
      "description": "Given a string containing just the characters `(` and `)`, return the length of the longest valid (well-formed) parentheses substring.",
      "examples": [
        { "input": "s = \"(()\"", "output": "2" },
        { "input": "s = \")()()\"", "output": "4" },
        { "input": "s = \"\"", "output": "0" }
      ],
      "hints": ["Use a stack to keep track of indices of opening parentheses. Or use dynamic programming."],
      "solutionJs": "function longestValidParentheses(s) {\n  let maxLength = 0;\n  const stack = [-1]; // Initialize stack with -1\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '(') {\n      stack.push(i);\n    } else {\n      stack.pop();\n      if (stack.length === 0) {\n        stack.push(i);\n      } else {\n        maxLength = Math.max(maxLength, i - stack[stack.length - 1]);\n      }\n    }\n  }\n  return maxLength;\n}",
      "solutionPython": "def longest_valid_parentheses(s):\n  max_length = 0\n  stack = [-1]\n  for i, char in enumerate(s):\n    if char == '(':\n      stack.append(i)\n    else:\n      stack.pop()\n      if not stack:\n        stack.append(i)\n      else:\n        max_length = max(max_length, i - stack[-1])\n  return max_length",
      "solutionJava": "import java.util.Stack;\nclass Solution {\n  public int longestValidParentheses(String s) {\n    int maxLength = 0;\n    Stack<Integer> stack = new Stack<>();\n    stack.push(-1);\n    for (int i = 0; i < s.length(); i++) {\n      if (s.charAt(i) == '(') {\n        stack.push(i);\n      } else {\n        stack.pop();\n        if (stack.empty()) {\n          stack.push(i);\n        } else {\n          maxLength = Math.max(maxLength, i - stack.peek());\n        }\n      }\n    }\n    return maxLength;\n  }\n}",
      "solutionCpp": "int longestValidParentheses(std::string s) {\n  int maxLength = 0;\n  std::stack<int> st;\n  st.push(-1);\n\n  for (int i = 0; i < s.length(); ++i) {\n    if (s[i] == '(') {\n      st.push(i);\n    } else {\n      st.pop();\n      if (st.empty()) {\n        st.push(i);\n      } else {\n        maxLength = std::max(maxLength, i - st.top());\n      }\n    }\n  }\n  return maxLength;\n}",
      "difficulty": "Hard",
      "score": 265
    },
    {
      "id": "hard-10",
      "title": "Minimum Window Substring",
      "description": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `\"\"`. The testcases will be generated such that the answer is always unique.",
      "examples": [
        { "input": "s = \"ADOBECODEBANC\", t = \"ABC\"", "output": "\"BANC\"" },
        { "input": "s = \"a\", t = \"a\"", "output": "\"a\"" },
        { "input": "s = \"a\", t = \"aa\"", "output": "\"\"" }
      ],
      "hints": ["Use a sliding window approach with a hash map to keep track of character counts."],
      "solutionJs": "function minWindow(s, t) {\n  if (t.length === 0) return '';\n\n  const tMap = {};\n  for (const char of t) {\n    tMap[char] = (tMap[char] || 0) + 1;\n  }\n\n  let windowStart = 0;\n  let matched = 0;\n  let minLength = Infinity;\n  let substringStart = 0;\n\n  for (let windowEnd = 0; windowEnd < s.length; windowEnd++) {\n    const rightChar = s[windowEnd];\n    if (rightChar in tMap) {\n      tMap[rightChar]--;\n      if (tMap[rightChar] >= 0) {\n        matched++;\n      }\n    }\n\n    while (matched === t.length) {\n      if (windowEnd - windowStart + 1 < minLength) {\n        minLength = windowEnd - windowStart + 1;\n        substringStart = windowStart;\n      }\n\n      const leftChar = s[windowStart];\n      windowStart++;\n      if (leftChar in tMap) {\n        if (tMap[leftChar] === 0) {\n          matched--;\n        }\n        tMap[leftChar]++;\n      }\n    }\n  }\n\n  if (minLength === Infinity) {\n    return '';\n  }\n\n  return s.substring(substringStart, substringStart + minLength);\n}",
      "solutionPython": "from collections import Counter\ndef min_window(s, t):\n  if not t: return ''\n\n  t_map = Counter(t)\n  window_start = 0\n  matched = 0\n  min_length = float('inf')\n  substring_start = 0\n\n  for window_end in range(len(s)):\n    right_char = s[window_end]\n    if right_char in t_map:\n      t_map[right_char] -= 1\n      if t_map[right_char] >= 0:\n        matched += 1\n\n    while matched == len(t):\n      if window_end - window_start + 1 < min_length:\n        min_length = window_end - window_start + 1\n        substring_start = window_start\n\n      left_char = s[window_start]\n      window_start += 1\n      if left_char in t_map:\n        if t_map[left_char] == 0:\n          matched -= 1\n        t_map[left_char] += 1\n\n  if min_length == float('inf'):\n    return ''\n  return s[substring_start : substring_start + min_length]",
      "solutionJava": "import java.util.HashMap;\nimport java.util.Map;\nclass Solution {\n  public String minWindow(String s, String t) {\n    if (t.length() == 0) return \"\";\n\n    Map<Character, Integer> tMap = new HashMap<>();\n    for (char c : t.toCharArray()) {\n      tMap.put(c, tMap.getOrDefault(c, 0) + 1);\n    }\n\n    int windowStart = 0;\n    int matched = 0;\n    int minLength = Integer.MAX_VALUE;\n    int substringStart = 0;\n\n    for (int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\n      char rightChar = s.charAt(windowEnd);\n      if (tMap.containsKey(rightChar)) {\n        tMap.put(rightChar, tMap.get(rightChar) - 1);\n        if (tMap.get(rightChar) >= 0) {\n          matched++;\n        }\n      }\n\n      while (matched == t.length()) {\n        if (windowEnd - windowStart + 1 < minLength) {\n          minLength = windowEnd - windowStart + 1;\n          substringStart = windowStart;\n        }\n\n        char leftChar = s.charAt(windowStart);\n        windowStart++;\n        if (tMap.containsKey(leftChar)) {\n          if (tMap.get(leftChar) == 0) {\n            matched--;\n          }\n          tMap.put(leftChar, tMap.get(leftChar) + 1);\n        }\n      }\n    }\n\n    if (minLength == Integer.MAX_VALUE) {\n      return \"\";\n    }\n\n    return s.substring(substringStart, substringStart + minLength);\n  }\n}",
      "solutionCpp": "std::string minWindow(std::string s, std::string t) {\n    if (t.empty()) return \"\";\n\n    std::unordered_map<char, int> tMap;\n    for (char c : t) {\n        tMap[c]++;\n    }\n\n    int windowStart = 0;\n    int matched = 0;\n    int minLength = INT_MAX;\n    int substringStart = 0;\n\n    for (int windowEnd = 0; windowEnd < s.length(); ++windowEnd) {\n        char rightChar = s[windowEnd];\n        if (tMap.count(rightChar)) {\n            tMap[rightChar]--;\n            if (tMap[rightChar] >= 0) {\n                matched++;\n            }\n        }\n\n        while (matched == t.length()) {\n            if (windowEnd - windowStart + 1 < minLength) {\n                minLength = windowEnd - windowStart + 1;\n                substringStart = windowStart;\n            }\n\n            char leftChar = s[windowStart];\n            windowStart++;\n            if (tMap.count(leftChar)) {\n                if (tMap[leftChar] == 0) {\n                    matched--;\n                }\n                tMap[leftChar]++;\n            }\n        }\n    }\n\n    if (minLength == INT_MAX) {\n        return \"\";\n    }\n\n    return s.substr(substringStart, minLength);\n}",
      "difficulty": "Hard",
      "score": 285
    },
    {
      "id": "hard-11",
      "title": "Word Ladder",
      "description": "A transformation sequence from `word_list` to `end_word` using a dictionary `word_list` is a sequence of words `begin_word -> s1 -> s2 -> ... -> sk` such that: Every adjacent pair of words differs by a single letter. Every `si` in the sequence is in `word_list`. Note that `begin_word` does not need to be in `word_list`. `end_word` is in `word_list`. Given two words, `begin_word` and `end_word`, and a dictionary `word_list`, return the number of words in the shortest transformation sequence. If no such sequence exists, return 0.",
      "examples": [
        { "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]", "output": "5 (hit -> hot -> dot -> dog -> cog)" },
        { "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]", "output": "0" }
      ],
      "hints": ["This is a shortest path problem, which often implies Breadth-First Search (BFS)."],
      "solutionJs": "function ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n\n  let queue = [[beginWord, 1]];\n  wordSet.delete(beginWord);\n\n  while (queue.length > 0) {\n    const [currentWord, level] = queue.shift();\n\n    for (let i = 0; i < currentWord.length; i++) {\n      const originalChar = currentWord[i];\n      for (let charCode = 97; charCode <= 122; charCode++) { // 'a' to 'z'\n        const newChar = String.fromCharCode(charCode);\n        if (newChar === originalChar) continue;\n\n        const newWordArr = currentWord.split('');\n        newWordArr[i] = newChar;\n        const newWord = newWordArr.join('');\n\n        if (newWord === endWord) return level + 1;\n\n        if (wordSet.has(newWord)) {\n          wordSet.delete(newWord);\n          queue.push([newWord, level + 1]);\n        }\n      }\n    }\n  }\n  return 0;\n}",
      "solutionPython": "from collections import deque\ndef ladder_length(begin_word, end_word, word_list):\n  word_set = set(word_list)\n  if end_word not in word_set: return 0\n\n  queue = deque([(begin_word, 1)])\n  word_set.discard(begin_word)\n\n  while queue:\n    current_word, level = queue.popleft()\n\n    for i in range(len(current_word)):\n      original_char = current_word[i]\n      for char_code in range(ord('a'), ord('z') + 1):\n        new_char = chr(char_code)\n        if new_char == original_char: continue\n\n        new_word_list = list(current_word)\n        new_word_list[i] = new_char\n        new_word = \"\".join(new_word_list)\n\n        if new_word == end_word: return level + 1\n\n        if new_word in word_set:\n          word_set.remove(new_word)\n          queue.append((new_word, level + 1))\n\n  return 0",
      "solutionJava": "import java.util.*;\nclass Solution {\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> wordSet = new HashSet<>(wordList);\n    if (!wordSet.contains(endWord)) return 0;\n\n    Queue<Pair<String, Integer>> queue = new LinkedList<>();\n    queue.offer(new Pair<>(beginWord, 1));\n    wordSet.remove(beginWord);\n\n    while (!queue.isEmpty()) {\n      Pair<String, Integer> current = queue.poll();\n      String currentWord = current.getKey();\n      int level = current.getValue();\n\n      for (int i = 0; i < currentWord.length(); i++) {\n        char[] charArray = currentWord.toCharArray();\n        char originalChar = charArray[i];\n\n        for (char c = 'a'; c <= 'z'; c++) {\n          if (c == originalChar) continue;\n          charArray[i] = c;\n          String newWord = new String(charArray);\n\n          if (newWord.equals(endWord)) return level + 1;\n\n          if (wordSet.contains(newWord)) {\n            wordSet.remove(newWord);\n            queue.offer(new Pair<>(newWord, level + 1));\n          }\n        }\n        charArray[i] = originalChar; // Backtrack for next iteration\n      }\n    }\n    return 0;\n  }\n\n  // Need a Pair class or similar for Java 8+ if not using javafx.util.Pair\n  static class Pair<K, V> {\n    private K key;\n    private V value;\n\n    public Pair(K key, V value) {\n      this.key = key;\n      this.value = value;\n    }\n\n    public K getKey() { return key; }\n    public V getValue() { return value; }\n  }\n}",
      "solutionCpp": "class Solution {\npublic:\n    int ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n        std::unordered_set<std::string> wordSet(wordList.begin(), wordList.end());\n        if (wordSet.find(endWord) == wordSet.end()) return 0;\n\n        std::queue<std::pair<std::string, int>> q;\n        q.push({beginWord, 1});\n        wordSet.erase(beginWord);\n\n        while (!q.empty()) {\n            std::string currentWord = q.front().first;\n            int level = q.front().second;\n            q.pop();\n\n            for (int i = 0; i < currentWord.length(); ++i) {\n                char originalChar = currentWord[i];\n                for (char c = 'a'; c <= 'z'; ++c) {\n                    if (c == originalChar) continue;\n                    currentWord[i] = c;\n\n                    if (currentWord == endWord) return level + 1;\n\n                    if (wordSet.count(currentWord)) {\n                        wordSet.erase(currentWord);\n                        q.push({currentWord, level + 1});\n                    }\n                }\n                currentWord[i] = originalChar; // Backtrack\n            }\n        }\n        return 0;\n    }\n};",
      "difficulty": "Hard",
      "score": 300
    },
    {
      "id": "hard-12",
      "title": "Burst Balloons",
      "description": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by `nums[i]`. You are asked to burst all the balloons. If you burst balloon `i`, you will get `nums[left] * nums[i] * nums[right]` coins. Here `left` and `right` are adjacent indices of `i`. After the balloon is burst, `left` and `right` then become adjacent. Find the maximum coins you can collect by bursting the balloons wisely.",
      "examples": [
        { "input": "nums = [3,1,5,8]", "output": "167" },
        { "input": "nums = [1,5]", "output": "10" }
      ],
      "hints": ["This is a dynamic programming problem. Think about the last balloon to burst in an interval."],
      "solutionJs": "function maxCoins(nums) {\n  const n = nums.length;\n  const points = [1, ...nums, 1];\n  const dp = Array(n + 2).fill(0).map(() => Array(n + 2).fill(0));\n\n  for (let len = 1; len <= n; len++) {\n    for (let i = 1; i <= n - len + 1; i++) {\n      const j = i + len - 1;\n      for (let k = i; k <= j; k++) {\n        // k is the last balloon to burst in (i, j) interval\n        const coins = points[i - 1] * points[k] * points[j + 1];\n        dp[i][j] = Math.max(dp[i][j], coins + dp[i][k - 1] + dp[k + 1][j]);\n      }\n    }\n  }\n  return dp[1][n];\n}",
      "solutionPython": "def max_coins(nums):\n  n = len(nums)\n  points = [1] + nums + [1]\n  dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n  for length in range(1, n + 1):\n    for i in range(1, n - length + 2):\n      j = i + length - 1\n      for k in range(i, j + 1):\n        # k is the last balloon to burst in (i, j) interval\n        coins = points[i - 1] * points[k] * points[j + 1]\n        dp[i][j] = max(dp[i][j], coins + dp[i][k - 1] + dp[k + 1][j])\n\n  return dp[1][n]",
      "solutionJava": "class Solution {\n  public int maxCoins(int[] nums) {\n    int n = nums.length;\n    int[] points = new int[n + 2];\n    points[0] = 1;\n    points[n + 1] = 1;\n    for (int i = 0; i < n; i++) {\n      points[i + 1] = nums[i];\n    }\n\n    int[][] dp = new int[n + 2][n + 2];\n\n    for (int len = 1; len <= n; len++) {\n      for (int i = 1; i <= n - len + 1; i++) {\n        int j = i + len - 1;\n        for (int k = i; k <= j; k++) {\n          int coins = points[i - 1] * points[k] * points[j + 1];\n          dp[i][j] = Math.max(dp[i][j], coins + dp[i][k - 1] + dp[k + 1][j]);\n        }\n      }\n    }\n    return dp[1][n];\n  }\n}",
      "solutionCpp": "int maxCoins(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> points(n + 2);\n    points[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        points[i + 1] = nums[i];\n    }\n    points[n + 1] = 1;\n\n    std::vector<std::vector<int>> dp(n + 2, std::vector<int>(n + 2, 0));\n\n    for (int len = 1; len <= n; ++len) {\n        for (int i = 1; i <= n - len + 1; ++i) {\n            int j = i + len - 1;\n            for (int k = i; k <= j; ++k) {\n                // k is the last balloon to burst in the interval (i, j)\n                int coins = points[i - 1] * points[k] * points[j + 1];\n                dp[i][j] = std::max(dp[i][j], coins + dp[i][k - 1] + dp[k + 1][j]);\n            }\n        }\n    }\n    return dp[1][n];\n}",
      "difficulty": "Hard",
      "score": 310
    },
    {
      "id": "hard-13",
      "title": "K-th Smallest Pair Distance",
      "description": "Given an integer array `nums`, return the `k`-th smallest distance among all pairs. The distance of a pair `(a, b)` is defined as the absolute difference between `a` and `b`.",
      "examples": [
        { "input": "nums = [1,3,1], k = 1", "output": "0 (Pair (1,1))" },
        { "input": "nums = [1,1,1], k = 2", "output": "0" },
        { "input": "nums = [1,6,1], k = 3", "output": "5 (Pairs are (0,5), (0,0), (5,5))" }
      ],
      "hints": ["Sort the array first. Then use binary search on the answer (the distance value). For a given distance `mid`, count how many pairs have a distance less than or equal to `mid`."],
      "solutionJs": "function smallestDistancePair(nums, k) {\n  nums.sort((a, b) => a - b);\n  const n = nums.length;\n\n  let low = 0;\n  let high = nums[n - 1] - nums[0];\n  let ans = 0;\n\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    let count = 0;\n    let left = 0;\n    for (let right = 0; right < n; right++) {\n      while (nums[right] - nums[left] > mid) {\n        left++;\n      }\n      count += right - left;\n    }\n\n    if (count >= k) {\n      ans = mid;\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return ans;\n}",
      "solutionPython": "def smallest_distance_pair(nums, k):\n  nums.sort()\n  n = len(nums)\n\n  low, high = 0, nums[n-1] - nums[0]\n  ans = 0\n\n  while low <= high:\n    mid = (low + high) // 2\n    count = 0\n    left = 0\n    for right in range(n):\n      while nums[right] - nums[left] > mid:\n        left += 1\n      count += right - left\n\n    if count >= k:\n      ans = mid\n      high = mid - 1\n    else:\n      low = mid + 1\n\n  return ans",
      "solutionJava": "import java.util.Arrays;\nclass Solution {\n  public int smallestDistancePair(int[] nums, int k) {\n    Arrays.sort(nums);\n    int n = nums.length;\n\n    int low = 0;\n    int high = nums[n - 1] - nums[0];\n    int ans = 0;\n\n    while (low <= high) {\n      int mid = low + (high - low) / 2;\n      int count = 0;\n      int left = 0;\n      for (int right = 0; right < n; right++) {\n        while (nums[right] - nums[left] > mid) {\n          left++;\n        }\n        count += right - left;\n      }\n\n      if (count >= k) {\n        ans = mid;\n        high = mid - 1;\n      } else {\n        low = mid + 1;\n      }\n    }\n    return ans;\n  }\n}",
      "solutionCpp": "int smallestDistancePair(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end());\n    int n = nums.size();\n\n    int low = 0;\n    int high = nums[n - 1] - nums[0];\n    int ans = 0;\n\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        int left = 0;\n        for (int right = 0; right < n; ++right) {\n            while (nums[right] - nums[left] > mid) {\n                left++;\n            }\n            count += right - left;\n        }\n\n        if (count >= k) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return ans;\n}",
      "difficulty": "Hard",
      "score": 275
    },
    {
      "id": "hard-14",
      "title": "Maximum Profit in Job Scheduling",
      "description": "We have `n` jobs, where `startTime[i]` is the start time, `endTime[i]` is the end time, and `profit[i]` is the profit of the `ith` job. You want to choose a subset of jobs such that no two jobs have overlapping time intervals and the sum of profits of the chosen jobs is maximized. Return the maximum profit you can achieve.",
      "examples": [
        { "input": "startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]", "output": "120 (Job 1: (1,3,50), Job 4: (3,6,70). Note: job 1 ends at 3, job 4 starts at 3, so they don't overlap.)" },
        { "input": "startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]", "output": "6" }
      ],
      "hints": ["Sort jobs by their end times. Use dynamic programming with binary search or a `TreeMap` to find the last non-overlapping job."],
      "solutionJs": "function jobScheduling(startTime, endTime, profit) {\n  const n = startTime.length;\n  const jobs = [];\n  for (let i = 0; i < n; i++) {\n    jobs.push({ start: startTime[i], end: endTime[i], profit: profit[i] });\n  }\n  jobs.sort((a, b) => a.end - b.end);\n\n  const dp = new Map(); // end_time -> max_profit\n  dp.set(0, 0);\n\n  for (const job of jobs) {\n    let currentProfit = job.profit;\n    // Find the largest end_time <= job.start\n    let prevEnd = 0;\n    for (const [end, maxP] of dp.entries()) {\n      if (end <= job.start) {\n        prevEnd = Math.max(prevEnd, end);\n      }\n    }\n    currentProfit += dp.get(prevEnd);\n\n    // Get the current max profit up to job.end\n    let maxProfitUpToEnd = 0;\n    for (const [end, maxP] of dp.entries()) {\n      if (end >= job.end) {\n        maxProfitUpToEnd = Math.max(maxProfitUpToEnd, maxP);\n      }\n    }\n    dp.set(job.end, Math.max(currentProfit, maxProfitUpToEnd));\n  }\n\n  let maxTotalProfit = 0;\n  for (const profitValue of dp.values()) {\n    maxTotalProfit = Math.max(maxTotalProfit, profitValue);\n  }\n  return maxTotalProfit;\n}",
      "solutionPython": "import bisect\ndef job_scheduling(start_time, end_time, profit):\n  n = len(start_time)\n  jobs = sorted(zip(end_time, start_time, profit))\n\n  dp = {0: 0} # {end_time: max_profit_up_to_this_time}\n\n  for end, start, p in jobs:\n    # Find the largest end_time in dp that is <= current job's start time\n    # bisect_right finds insertion point, then go back one index\n    keys = list(dp.keys())\n    idx = bisect.bisect_right(keys, start) - 1\n    prev_end_time = keys[idx]\n\n    # Calculate profit if we include current job\n    current_profit = dp[prev_end_time] + p\n\n    # Update dp with max profit up to 'end'\n    # The last key in dp (largest end time) represents the current max overall profit\n    if current_profit > list(dp.values())[-1]:\n        dp[end] = current_profit\n    else:\n        # If current_profit is not better than the current max overall, \n        # ensure we maintain non-decreasing values in dp.\n        # This handles cases where adding a job might result in less profit for an end time,\n        # but we only care about the maximum profit at any given end time.\n        dp[end] = list(dp.values())[-1]\n\n  return list(dp.values())[-1]",
      "solutionJava": "import java.util.Arrays;\nimport java.util.TreeMap;\nclass Solution {\n  class Job {\n    int start;\n    int end;\n    int profit;\n\n    public Job(int start, int end, int profit) {\n      this.start = start;\n      this.end = end;\n      this.profit = profit;\n    }\n  }\n\n  public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n    int n = startTime.length;\n    Job[] jobs = new Job[n];\n    for (int i = 0; i < n; i++) {\n      jobs[i] = new Job(startTime[i], endTime[i], profit[i]);\n    }\n\n    Arrays.sort(jobs, (a, b) -> a.end - b.end);\n\n    TreeMap<Integer, Integer> dp = new TreeMap<>(); // key: end_time, value: max_profit_up_to_this_time\n    dp.put(0, 0);\n\n    for (Job job : jobs) {\n      // Find the largest end time <= current job's start time\n      // floorEntry gives (key, value) pair where key <= job.start\n      Map.Entry<Integer, Integer> entry = dp.floorEntry(job.start);\n      int prevProfit = entry.getValue();\n\n      int currentJobProfit = prevProfit + job.profit;\n\n      // If the profit for current job's end time is greater than the current max profit known\n      // at or before this end time, update it.\n      // We only add new entries if they increase the maximum profit.\n      if (currentJobProfit > dp.lastEntry().getValue()) {\n        dp.put(job.end, currentJobProfit);\n      }\n    }\n\n    return dp.lastEntry().getValue();\n  }\n}",
      "solutionCpp": "struct Job {\n    int start;\n    int end;\n    int profit;\n};\n\nbool compareJobs(const Job& a, const Job& b) {\n    return a.end < b.end;\n}\n\nclass Solution {\npublic:\n    int jobScheduling(std::vector<int>& startTime, std::vector<int>& endTime, std::vector<int>& profit) {\n        int n = startTime.size();\n        std::vector<Job> jobs(n);\n        for (int i = 0; i < n; ++i) {\n            jobs[i] = {startTime[i], endTime[i], profit[i]};\n        }\n        std::sort(jobs.begin(), jobs.end(), compareJobs);\n\n        // dp stores {end_time: max_profit_up_to_this_time}\n        std::map<int, int> dp;\n        dp[0] = 0; // Base case: 0 profit at time 0\n\n        for (const auto& job : jobs) {\n            // Find the maximum profit from jobs ending before or at job.start\n            // upper_bound returns an iterator to the first element whose key is greater than job.start\n            // --it takes it back to the element <= job.start\n            auto it = dp.upper_bound(job.start);\n            --it;\n            int prevProfit = it->second;\n\n            // Calculate profit if we include current job\n            int currentProfit = prevProfit + job.profit;\n\n            // If the current profit is greater than the maximum profit seen so far\n            // (which is the last entry in the map), update dp.\n            // This ensures dp values are non-decreasing.\n            if (currentProfit > dp.rbegin()->second) {\n                dp[job.end] = currentProfit;\n            }\n        }\n\n        return dp.rbegin()->second;\n    }\n};",
      "difficulty": "Hard",
      "score": 305
    },
    {
      "id": "hard-15",
      "title": "Serialize and Deserialize Binary Tree",
      "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.",
      "examples": [
        { "input": "[1,2,3,null,null,4,5]", "output": "[1,2,3,null,null,4,5]" }
      ],
      "hints": ["Use a level-order (BFS) or pre-order (DFS) traversal. Represent null nodes explicitly to reconstruct the tree structure correctly."],
      "solutionJs": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n * this.val = val;\n * this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n  if (!root) return 'null';\n\n  let queue = [root];\n  let result = [];\n\n  while (queue.length > 0) {\n    let node = queue.shift();\n\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push('null');\n    }\n  }\n  return result.join(',');\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const nodes = data.split(',');\n  if (nodes[0] === 'null') return null;\n\n  const root = new TreeNode(parseInt(nodes[0]));\n  let queue = [root];\n  let i = 1;\n\n  while (queue.length > 0 && i < nodes.length) {\n    let current = queue.shift();\n\n    // Left child\n    if (nodes[i] !== 'null') {\n      current.left = new TreeNode(parseInt(nodes[i]));\n      queue.push(current.left);\n    }\n    i++;\n\n    // Right child\n    if (i < nodes.length && nodes[i] !== 'null') {\n      current.right = new TreeNode(parseInt(nodes[i]));\n      queue.push(current.right);\n    }\n    i++;\n  }\n  return root;\n};\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var ser = new Codec();\n * var deser = new Codec();\n * var tree = ser.serialize(root);\n * var ans = deser.deserialize(tree);\n * // Example for TreeNode definition if not provided:\n * // function TreeNode(val) { this.val = val; this.left = this.right = null; }",
      "solutionPython": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nfrom collections import deque\n\nclass Codec:\n\n    def serialize(self, root):\n        if not root: return \"null\"\n        \n        queue = deque([root])\n        result = []\n        \n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(\"null\")\n                \n        return \",\".join(result)\n\n    def deserialize(self, data):\n        nodes = data.split(',')\n        if nodes[0] == \"null\": return None\n        \n        root = TreeNode(int(nodes[0]))\n        queue = deque([root])\n        i = 1\n        \n        while queue and i < len(nodes):\n            current = queue.popleft()\n            \n            # Left child\n            if nodes[i] != \"null\":\n                current.left = TreeNode(int(nodes[i]))\n                queue.append(current.left)\n            i += 1\n            \n            # Right child\n            if i < len(nodes) and nodes[i] != \"null\":\n                current.right = TreeNode(int(nodes[i]))\n                queue.append(current.right)\n            i += 1\n            \n        return root\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n\n# Example for TreeNode definition if not provided:\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right",
      "solutionJava": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) return \"null\";\n\n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        sb.append(root.val);\n\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n\n            // Left child\n            if (node.left != null) {\n                sb.append(\",\").append(node.left.val);\n                queue.offer(node.left);\n            } else {\n                sb.append(\",null\");\n            }\n\n            // Right child\n            if (node.right != null) {\n                sb.append(\",\").append(node.right.val);\n                queue.offer(node.right);\n            } else {\n                sb.append(\",null\");\n            }\n        }\n        // Trim trailing nulls to make it concise if they represent the last level's children\n        // This part needs careful handling if strict 'level order' nulls are required\n        // For robust solution, typically you don't trim until you hit actual nodes.\n        // A simpler way for a full level-order representation: just include all nulls.\n        // The provided solution below (JS/Python/C++) will work with explicit nulls for reconstruction.\n        // Let's adjust this Java solution to be consistent with others by adding nulls for every position.\n\n        sb = new StringBuilder(); // Reset for a standard BFS representation\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node == null) {\n                sb.append(\"null,\");\n                continue;\n            }\n            sb.append(node.val).append(\",\");\n            queue.offer(node.left);\n            queue.offer(node.right);\n        }\n        // Remove trailing comma and possibly unnecessary 'null's at the very end\n        String result = sb.toString();\n        while (result.endsWith(\"null,\")) {\n            result = result.substring(0, result.length() - 5);\n        }\n        if (result.endsWith(\",\")) result = result.substring(0, result.length() - 1); // remove last comma if any\n        return result;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] nodes = data.split(\",\");\n        if (nodes[0].equals(\"null\")) return null;\n\n        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int i = 1;\n\n        while (!queue.isEmpty() && i < nodes.length) {\n            TreeNode current = queue.poll();\n\n            // Left child\n            if (!nodes[i].equals(\"null\")) {\n                current.left = new TreeNode(Integer.parseInt(nodes[i]));\n                queue.offer(current.left);\n            }\n            i++;\n\n            // Right child\n            if (i < nodes.length && !nodes[i].equals(\"null\")) {\n                current.right = new TreeNode(Integer.parseInt(nodes[i]));\n                queue.offer(current.right);\n            }\n            i++;\n        }\n        return root;\n    }\n}",
      "solutionCpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n * int val;\n * TreeNode *left;\n * TreeNode *right;\n * TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n#include <string>\n#include <queue>\n#include <vector>\n#include <sstream>\n\n// struct TreeNode {\n//     int val;\n//     TreeNode *left;\n//     TreeNode *right;\n//     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n// };\n\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    std::string serialize(TreeNode* root) {\n        if (!root) return \"null\";\n\n        std::string result = \"\";\n        std::queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            TreeNode* node = q.front();\n            q.pop();\n\n            if (node) {\n                result += std::to_string(node->val) + \",\";\n                q.push(node->left);\n                q.push(node->right);\n            } else {\n                result += \"null,\";\n            }\n        }\n        // Remove trailing 'null,'s from the end for a cleaner output\n        while (result.length() >= 5 && result.substr(result.length() - 5) == \"null,\") {\n            result.resize(result.length() - 5);\n        }\n        if (!result.empty() && result.back() == ',') {\n            result.pop_back();\n        }\n        return result;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(std::string data) {\n        if (data == \"null\") return nullptr;\n\n        std::stringstream ss(data);\n        std::string item;\n        std::getline(ss, item, ',');\n        TreeNode* root = new TreeNode(std::stoi(item));\n        std::queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            TreeNode* current = q.front();\n            q.pop();\n\n            // Left child\n            if (std::getline(ss, item, ',')) {\n                if (item != \"null\") {\n                    current->left = new TreeNode(std::stoi(item));\n                    q.push(current->left);\n                }\n            }\n\n            // Right child\n            if (std::getline(ss, item, ',')) {\n                if (item != \"null\") {\n                    current->right = new TreeNode(std::stoi(item));\n                    q.push(current->right);\n                }\n            }\n        }\n        return root;\n    }\n};",
      "difficulty": "Hard",
      "score": 315
    },
    {
      "id": "hard-16",
      "title": "Meeting Rooms II",
      "description": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.",
      "examples": [
        { "input": "intervals = [[0,30],[5,10],[15,20]]", "output": "2" },
        { "input": "intervals = [[7,10],[2,4]]", "output": "1" }
      ],
      "hints": ["Sort the intervals by start time. Use a min-heap to store the end times of active meetings. If the current meeting's start time is greater than or equal to the smallest end time in the heap, we can reuse a room."],
      "solutionJs": "function minMeetingRooms(intervals) {\n  if (intervals.length === 0) return 0;\n\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  // Min-heap to store end times of meetings\n  const minHeap = []; // In JS, simulate min-heap using array and sort/splice for simplicity or use a custom Heap class\n\n  // Add the first meeting's end time\n  minHeap.push(intervals[0][1]);\n  minHeap.sort((a, b) => a - b);\n\n  for (let i = 1; i < intervals.length; i++) {\n    const currentStart = intervals[i][0];\n    const currentEnd = intervals[i][1];\n\n    // If the earliest ending meeting (heap.peek()) has ended before or at current meeting's start\n    if (minHeap[0] <= currentStart) {\n      minHeap.shift(); // Remove it, we can reuse this room\n    }\n    minHeap.push(currentEnd);\n    minHeap.sort((a, b) => a - b); // Keep the min-heap property\n  }\n  return minHeap.length;\n}",
      "solutionPython": "import heapq\ndef min_meeting_rooms(intervals):\n  if not intervals: return 0\n\n  intervals.sort(key=lambda x: x[0])\n\n  # Min-heap to store end times of meetings\n  min_heap = []\n\n  # Add the first meeting's end time to the heap\n  heapq.heappush(min_heap, intervals[0][1])\n\n  for i in range(1, len(intervals)):\n    current_start = intervals[i][0]\n    current_end = intervals[i][1]\n\n    # If the earliest ending meeting (heap[0]) has ended before or at current meeting's start\n    if min_heap[0] <= current_start:\n      heapq.heappop(min_heap) # Reuse this room\n    \n    heapq.heappush(min_heap, current_end) # Assign current meeting to a room\n\n  return len(min_heap)",
      "solutionJava": "import java.util.Arrays;\nimport java.util.PriorityQueue;\n\nclass Solution {\n  public int minMeetingRooms(int[][] intervals) {\n    if (intervals == null || intervals.length == 0) return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]); // Sort by start time\n\n    // Min-heap to store end times of meetings\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) -> a - b);\n\n    // Add the first meeting's end time\n    minHeap.add(intervals[0][1]);\n\n    for (int i = 1; i < intervals.length; i++) {\n      // If the earliest ending meeting (heap.peek()) has ended before or at current meeting's start\n      if (minHeap.peek() <= intervals[i][0]) {\n        minHeap.poll(); // Remove it, we can reuse this room\n      }\n      minHeap.add(intervals[i][1]); // Add current meeting's end time\n    }\n\n    return minHeap.size();\n  }\n}",
      "solutionCpp": "class Solution {\npublic:\n    int minMeetingRooms(std::vector<std::vector<int>>& intervals) {\n        if (intervals.empty()) return 0;\n\n        // Sort intervals by start time\n        std::sort(intervals.begin(), intervals.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n            return a[0] < b[0];\n        });\n\n        // Min-heap to store end times of meetings\n        // std::priority_queue is max-heap by default, so use std::greater<int>\n        std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n\n        // Add the first meeting's end time\n        minHeap.push(intervals[0][1]);\n\n        for (int i = 1; i < intervals.size(); ++i) {\n            // If the earliest ending meeting (heap.top()) has ended before or at current meeting's start\n            if (minHeap.top() <= intervals[i][0]) {\n                minHeap.pop(); // Reuse this room\n            }\n            minHeap.push(intervals[i][1]); // Add current meeting's end time\n        }\n\n        return minHeap.size();\n    }\n};",
      "difficulty": "Hard",
      "score": 270
    },
    {
      "id": "hard-17",
      "title": "Find K Closest Elements",
      "description": "Given a sorted integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order.\nAn integer `a` is closer to `x` than an integer `b` if: `|a - x| < |b - x|`, or `|a - x| == |b - x|` and `a < b`.",
      "examples": [
        { "input": "arr = [1,2,3,4,5], k = 4, x = 3", "output": "[1,2,3,4]" },
        { "input": "arr = [1,2,3,4,5], k = 4, x = -1", "output": "[1,2,3,4]" }
      ],
      "hints": ["Use binary search to find `x` or its closest insertion point. Then use two pointers to expand outwards to find the `k` closest elements."],
      "solutionJs": "function findClosestElements(arr, k, x) {\n  let left = 0;\n  let right = arr.length - 1;\n  let start = 0;\n  let end = arr.length - k;\n\n  // Binary search to find the optimal starting point of the window of k elements\n  while (start < end) {\n    const mid = Math.floor(start + (end - start) / 2);\n    if (x - arr[mid] > arr[mid + k] - x) {\n      start = mid + 1;\n    } else {\n      end = mid;\n    }\n  }\n  return arr.slice(start, start + k);\n}",
      "solutionPython": "import bisect\ndef find_closest_elements(arr, k, x):\n  # Find insertion point for x\n  idx = bisect.bisect_left(arr, x)\n\n  # Initialize left and right pointers around idx\n  left, right = idx - 1, idx\n\n  # Expand window until k elements are found\n  while right - left - 1 < k:\n    if left == -1:\n      right += 1\n    elif right == len(arr):\n      left -= 1\n    elif abs(arr[left] - x) <= abs(arr[right] - x):\n      left -= 1\n    else:\n      right += 1\n  \n  return arr[left + 1:right]",
      "solutionJava": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nclass Solution {\n  public List<Integer> findClosestElements(int[] arr, int k, int x) {\n    int left = 0;\n    int right = arr.length - k;\n\n    while (left < right) {\n      int mid = left + (right - left) / 2;\n      // Compare distance of arr[mid] to x with arr[mid+k] to x\n      // If x - arr[mid] (distance from left end of window) is greater than arr[mid+k] - x (distance from right end)\n      // it means arr[mid] is 'further' from x than arr[mid+k].\n      // So, we need to shift our window to the right.\n      if (x - arr[mid] > arr[mid + k] - x) {\n        left = mid + 1;\n      } else {\n        // Otherwise, arr[mid] is closer or equally close (prioritize smaller values),\n        // so this window starting at mid could be the answer. Try smaller index.\n        right = mid;\n      }\n    }\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = left; i < left + k; i++) {\n      result.add(arr[i]);\n    }\n    return result;\n  }\n}",
      "solutionCpp": "class Solution {\npublic:\n    std::vector<int> findClosestElements(std::vector<int>& arr, int k, int x) {\n        int left = 0;\n        int right = arr.size() - k;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            // If the element at mid is further from x than the element at mid + k,\n            // it means the window needs to shift right.\n            // The condition `x - arr[mid] > arr[mid + k] - x` prioritizes smaller numbers\n            // when distances are equal.\n            if (x - arr[mid] > arr[mid + k] - x) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return std::vector<int>(arr.begin() + left, arr.begin() + left + k);\n    }\n};",
      "difficulty": "Hard",
      "score": 260
    },
    {
      "id": "hard-18",
      "title": "Largest Rectangle in Histogram",
      "description": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
      "examples": [
        { "input": "heights = [2,1,5,6,2,3]", "output": "10 (Rectangle formed by 5 and 6, height 5, width 2)" },
        { "input": "heights = [2,4]", "output": "4" }
      ],
      "hints": ["Use a monotonic stack to find the nearest smaller element to the left and right for each bar."],
      "solutionJs": "function largestRectangleArea(heights) {\n  let maxArea = 0;\n  const stack = []; // Stores indices\n\n  // Pad heights with 0 at start and end to handle edge cases\n  const extendedHeights = [0, ...heights, 0];\n\n  for (let i = 0; i < extendedHeights.length; i++) {\n    while (stack.length > 0 && extendedHeights[i] < extendedHeights[stack[stack.length - 1]]) {\n      const h = extendedHeights[stack.pop()];\n      const w = i - stack[stack.length - 1] - 1;\n      maxArea = Math.max(maxArea, h * w);\n    }\n    stack.push(i);\n  }\n  return maxArea;\n}",
      "solutionPython": "def largest_rectangle_area(heights):\n  max_area = 0\n  stack = [] # Stores indices\n\n  # Add sentinels to handle edge cases (empty stack, final elements)\n  heights = [0] + heights + [0]\n\n  for i in range(len(heights)):\n    while stack and heights[i] < heights[stack[-1]]:\n      h = heights[stack.pop()]\n      w = i - stack[-1] - 1\n      max_area = max(max_area, h * w)\n    stack.append(i)\n\n  return max_area",
      "solutionJava": "import java.util.Stack;\nclass Solution {\n  public int largestRectangleArea(int[] heights) {\n    int maxArea = 0;\n    Stack<Integer> stack = new Stack<>(); // Stores indices\n\n    // Pad heights with 0 at start and end to handle edge cases cleanly\n    int[] newHeights = new int[heights.length + 2];\n    newHeights[0] = 0;\n    newHeights[newHeights.length - 1] = 0;\n    for (int i = 0; i < heights.length; i++) {\n      newHeights[i + 1] = heights[i];\n    }\n    heights = newHeights;\n\n    for (int i = 0; i < heights.length; i++) {\n      while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {\n        int h = heights[stack.pop()];\n        int w = i - stack.peek() - 1;\n        maxArea = Math.max(maxArea, h * w);\n      }\n      stack.push(i);\n    }\n    return maxArea;\n  }\n}",
      "solutionCpp": "int largestRectangleArea(std::vector<int>& heights) {\n    int maxArea = 0;\n    std::stack<int> s; // Stores indices\n\n    // Add sentinels (0 at start and end) to handle all elements and empty stack scenarios\n    std::vector<int> h(heights.begin(), heights.end());\n    h.insert(h.begin(), 0);\n    h.push_back(0);\n\n    for (int i = 0; i < h.size(); ++i) {\n        while (!s.empty() && h[i] < h[s.top()]) {\n            int height = h[s.top()];\n            s.pop();\n            int width = i - s.top() - 1;\n            maxArea = std::max(maxArea, height * width);\n        }\n        s.push(i);\n    }\n    return maxArea;\n}",
      "difficulty": "Hard",
      "score": 290
    },
    {
      "id": "hard-19",
      "title": "Sliding Window Maximum",
      "description": "You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
      "examples": [
        { "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3", "output": "[3,3,5,5,6,7]" },
        { "input": "nums = [1], k = 1", "output": "[1]" }
      ],
      "hints": ["Use a deque (double-ended queue) to store indices. Maintain the deque such that it stores indices of elements in decreasing order of their values. The front of the deque will always be the maximum for the current window."],
      "solutionJs": "function maxSlidingWindow(nums, k) {\n  const result = [];\n  const deque = []; // Stores indices\n\n  for (let i = 0; i < nums.length; i++) {\n    // Remove elements from the back of the deque if they are smaller than current element\n    while (deque.length > 0 && nums[deque[deque.length - 1]] <= nums[i]) {\n      deque.pop();\n    }\n    deque.push(i);\n\n    // Remove elements from the front of the deque if they are outside the current window\n    if (deque[0] <= i - k) {\n      deque.shift();\n    }\n\n    // Once window is formed (i+1 >= k), the front of the deque is the max\n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n  return result;\n}",
      "solutionPython": "from collections import deque\ndef max_sliding_window(nums, k):\n  result = []\n  dq = deque() # Stores indices\n\n  for i in range(len(nums)):\n    # Remove elements from the back of the deque if they are smaller than current element\n    while dq and nums[dq[-1]] <= nums[i]:\n      dq.pop()\n    dq.append(i)\n\n    # Remove elements from the front of the deque if they are outside the current window\n    if dq[0] <= i - k:\n      dq.popleft()\n\n    # Once window is formed (i+1 >= k), the front of the deque is the max\n    if i >= k - 1:\n      result.append(nums[dq[0]])\n  \n  return result",
      "solutionJava": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n  public int[] maxSlidingWindow(int[] nums, int k) {\n    if (nums == null || k <= 0) return new int[0];\n\n    int n = nums.length;\n    int[] result = new int[n - k + 1];\n    int ri = 0;\n\n    // deque stores indices\n    Deque<Integer> dq = new ArrayDeque<>();\n\n    for (int i = 0; i < n; i++) {\n      // Remove indices out of window bounds from front\n      if (!dq.isEmpty() && dq.peekFirst() < i - k + 1) {\n        dq.pollFirst();\n      }\n\n      // Remove elements smaller than current from back (they can't be max)\n      while (!dq.isEmpty() && nums[dq.peekLast()] < nums[i]) {\n        dq.pollLast();\n      }\n      dq.offerLast(i);\n\n      // If window is fully formed, add max to result\n      if (i >= k - 1) {\n        result[ri++] = nums[dq.peekFirst()];\n      }\n    }\n    return result;\n  }\n}",
      "solutionCpp": "class Solution {\npublic:\n    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\n        std::vector<int> result;\n        std::deque<int> dq; // Stores indices\n\n        for (int i = 0; i < nums.size(); ++i) {\n            // Remove indices from the front that are outside the current window\n            if (!dq.empty() && dq.front() <= i - k) {\n                dq.pop_front();\n            }\n\n            // Remove elements from the back that are smaller than the current element\n            // as they can't be the maximum in any future window that includes nums[i]\n            while (!dq.empty() && nums[dq.back()] < nums[i]) {\n                dq.pop_back();\n            }\n\n            // Add current element's index to the back\n            dq.push_back(i);\n\n            // If the window has formed (i.e., we have processed at least k elements)\n            if (i >= k - 1) {\n                result.push_back(nums[dq.front()]);\n            }\n        }\n        return result;\n    }\n};",
      "difficulty": "Hard",
      "score": 280
    },
    {
      "id": "hard-20",
      "title": "Scramble String",
      "description": "We say that a string `s1` is a scrambled string of a string `s2` if `s2` is obtained from `s1` by repeatedly applying the following algorithm once to a substring of `s1`:\n1. Choose an index `i` (0 < i < `s.length`) to divide the string `s` into two non-empty substrings `x` and `y` where `s = x + y`.\n2. Randomly decide to swap the two substrings or not. That is, `s` can become `x + y` or `y + x`.\nGiven two strings `s1` and `s2` of the same length, return `true` if `s2` is a scrambled string of `s1`, otherwise return `false`.",
      "examples": [
        { "input": "s1 = \"great\", s2 = \"rgeat\"", "output": "true" },
        { "input": "s1 = \"abcde\", s2 = \"caebd\"", "output": "false" }
      ],
      "hints": ["This is a dynamic programming problem or a recursive solution with memoization. The key is to try all possible split points and all possible swaps at each split."],
      "solutionJs": "function isScramble(s1, s2) {\n  if (s1 === s2) return true;\n  if (s1.length !== s2.length) return false;\n  if (s1.length === 0) return true;\n\n  const n = s1.length;\n  // dp[len][i][j] means if s1[i...i+len-1] is a scramble of s2[j...j+len-1]\n  const dp = Array(n + 1).fill(0).map(() => \n    Array(n).fill(0).map(() => \n      Array(n).fill(false)));\n\n  // Base case: len = 1\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      dp[1][i][j] = (s1[i] === s2[j]);\n    }\n  }\n\n  for (let len = 2; len <= n; len++) {\n    for (let i = 0; i <= n - len; i++) {\n      for (let j = 0; j <= n - len; j++) {\n        for (let k = 1; k < len; k++) {\n          // Case 1: No swap\n          // s1[i...i+k-1] scramble s2[j...j+k-1] AND\n          // s1[i+k...i+len-1] scramble s2[j+k...j+len-1]\n          if (dp[k][i][j] && dp[len - k][i + k][j + k]) {\n            dp[len][i][j] = true;\n            break;\n          }\n          // Case 2: Swap\n          // s1[i...i+k-1] scramble s2[j+len-k...j+len-1] AND\n          // s1[i+k...i+len-1] scramble s2[j...j+len-k-1]\n          if (dp[k][i][j + len - k] && dp[len - k][i + k][j]) {\n            dp[len][i][j] = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  return dp[n][0][0];\n}",
      "solutionPython": "def is_scramble(s1, s2):\n  if s1 == s2: return True\n  if len(s1) != len(s2): return False\n  if len(s1) == 0: return True\n\n  # Check if they have the same characters, important optimization\n  if sorted(s1) != sorted(s2): return False\n\n  n = len(s1)\n  # dp[len][i][j] means if s1[i...i+len-1] is a scramble of s2[j...j+len-1]\n  dp = [[[False] * n for _ in range(n)] for _ in range(n + 1)]\n\n  # Base case: len = 1\n  for i in range(n):\n    for j in range(n):\n      dp[1][i][j] = (s1[i] == s2[j])\n\n  for length in range(2, n + 1):\n    for i in range(n - length + 1):\n      for j in range(n - length + 1):\n        for k in range(1, length):\n          # Case 1: No swap\n          # s1[i...i+k-1] scramble s2[j...j+k-1] AND\n          # s1[i+k...i+length-1] scramble s2[j+k...j+length-1]\n          if (dp[k][i][j] and dp[length - k][i + k][j + k]):\n            dp[length][i][j] = True\n            break\n          \n          # Case 2: Swap\n          # s1[i...i+k-1] scramble s2[j+length-k...j+length-1] AND\n          # s1[i+k...i+length-1] scramble s2[j...j+length-k-1]\n          if (dp[k][i][j + length - k] and dp[length - k][i + k][j]):\n            dp[length][i][j] = True\n            break\n            \n  return dp[n][0][0]",
      "solutionJava": "class Solution {\n  public boolean isScramble(String s1, String s2) {\n    if (s1.equals(s2)) return true;\n    if (s1.length() != s2.length()) return false;\n\n    int n = s1.length();\n    // dp[len][i][j]: s1[i...i+len-1] is a scramble of s2[j...j+len-1]\n    boolean[][][] dp = new boolean[n + 1][n][n];\n\n    // Base case: len = 1\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        dp[1][i][j] = (s1.charAt(i) == s2.charAt(j));\n      }\n    }\n\n    for (int len = 2; len <= n; len++) {\n      for (int i = 0; i <= n - len; i++) {\n        for (int j = 0; j <= n - len; j++) {\n          for (int k = 1; k < len; k++) {\n            // Case 1: No swap\n            // s1[i...i+k-1] scramble s2[j...j+k-1] AND\n            // s1[i+k...i+len-1] scramble s2[j+k...j+len-1]\n            if (dp[k][i][j] && dp[len - k][i + k][j + k]) {\n              dp[len][i][j] = true;\n              break;\n            }\n            // Case 2: Swap\n            // s1[i...i+k-1] scramble s2[j+len-k...j+len-1] AND\n            // s1[i+k...i+len-1] scramble s2[j...j+len-k-1]\n            if (dp[k][i][j + len - k] && dp[len - k][i + k][j]) {\n              dp[len][i][j] = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return dp[n][0][0];\n  }\n}",
      "solutionCpp": "class Solution {\npublic:\n    bool isScramble(std::string s1, std::string s2) {\n        if (s1 == s2) return true;\n        if (s1.length() != s2.length()) return false;\n\n        int n = s1.length();\n        // dp[len][i][j] means if s1[i...i+len-1] is a scramble of s2[j...j+len-1]\n        // len: length of substring\n        // i: starting index in s1\n        // j: starting index in s2\n        std::vector<std::vector<std::vector<bool>>> dp(n + 1, \n            std::vector<std::vector<bool>>(n, \n                std::vector<bool>(n, false)));\n\n        // Base case: len = 1\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dp[1][i][j] = (s1[i] == s2[j]);\n            }\n        }\n\n        for (int len = 2; len <= n; ++len) {\n            for (int i = 0; i <= n - len; ++i) {\n                for (int j = 0; j <= n - len; ++j) {\n                    for (int k = 1; k < len; ++k) {\n                        // Case 1: No swap\n                        // s1[i...i+k-1] scramble s2[j...j+k-1] AND\n                        // s1[i+k...i+len-1] scramble s2[j+k...j+len-1]\n                        if (dp[k][i][j] && dp[len - k][i + k][j + k]) {\n                            dp[len][i][j] = true;\n                            break;\n                        }\n                        // Case 2: Swap\n                        // s1[i...i+k-1] scramble s2[j+len-k...j+len-1] AND\n                        // s1[i+k...i+len-1] scramble s2[j...j+len-k-1]\n                        if (dp[k][i][j + len - k] && dp[len - k][i + k][j]) {\n                            dp[len][i][j] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[n][0][0];\n    }\n};",
      "difficulty": "Hard",
      "score": 320
    }
  ]