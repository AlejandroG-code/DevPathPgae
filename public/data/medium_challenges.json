[
    {
      "id": "medium-1",
      "title": "Find Largest Three",
      "description": "Given an array of integers, return the three largest distinct numbers. If less than three, return all numbers.",
      "examples": [
        { "input": "[10, 4, 3, 50, 23, 90]", "output": "[50, 90, 23] (order may vary)" },
        { "input": "[5, 1, 2]", "output": "[1, 2, 5]" }
      ],
      "hints": ["Sort the array and pick the last three unique elements.", "Maintain three variables for largest, second largest, third largest."],
      "solutionJs": "function findLargestThree(arr) {\n  const sortedUnique = [...new Set(arr)].sort((a, b) => a - b);\n  return sortedUnique.slice(Math.max(0, sortedUnique.length - 3));\n}",
      "solutionPython": "def find_largest_three(arr):\n  unique_sorted = sorted(list(set(arr)))\n  return unique_sorted[-3:]",
      "solutionJava": "import java.util.*;\nclass Solution {\n  public List<Integer> findLargestThree(int[] arr) {\n    Set<Integer> uniqueNums = new TreeSet<>(); // TreeSet keeps sorted unique elements\n    for (int num : arr) uniqueNums.add(num);\n    List<Integer> list = new ArrayList<>(uniqueNums);\n    if (list.size() <= 3) return list;\n    return list.subList(list.size() - 3, list.size());\n  }\n}",
      "solutionCpp": "std::vector<int> findLargestThree(std::vector<int> arr) {\n  std::sort(arr.begin(), arr.end());\n  arr.erase(std::unique(arr.begin(), arr.end()), arr.end());\n  if (arr.size() <= 3) return arr;\n  return std::vector<int>(arr.end() - 3, arr.end());\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-2",
      "title": "Longest Word",
      "description": "Given a sentence, find the longest word in it.",
      "examples": [
        { "input": "\"The quick brown fox jumps over the lazy dog\"", "output": "\"jumps\"" },
        { "input": "\"Hello world\"", "output": "\"Hello\"" }
      ],
      "hints": ["Split the sentence into words. Iterate and compare lengths."],
      "solutionJs": "function longestWord(sentence) {\n  const words = sentence.match(/\\b\\w+\\b/g) || [];\n  if (words.length === 0) return '';\n  let longest = '';\n  for (const word of words) {\n    if (word.length > longest.length) {\n      longest = word;\n    }\n  }\n  return longest;\n}",
      "solutionPython": "import re\ndef longest_word(sentence):\n  words = re.findall(r'\\b\\w+\\b', sentence)\n  if not words: return ''\n  return max(words, key=len)",
      "solutionJava": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n  public String longestWord(String sentence) {\n    Pattern pattern = Pattern.compile(\"\\\\b\\\\w+\\\\b\");\n    Matcher matcher = pattern.matcher(sentence);\n    String longest = \"\";\n    while (matcher.find()) {\n      String word = matcher.group();\n      if (word.length() > longest.length()) {\n        longest = word;\n      }\n    }\n    return longest;\n  }\n}",
      "solutionCpp": "std::string longestWord(const std::string& sentence) {\n  std::string longest = \"\";\n  std::string currentWord;\n  std::stringstream ss(sentence);\n  while (ss >> currentWord) {\n    // Remove punctuation from word\n    currentWord.erase(std::remove_if(currentWord.begin(), currentWord.end(), ::ispunct), currentWord.end());\n    if (currentWord.length() > longest.length()) {\n      longest = currentWord;\n    }\n  }\n  return longest;\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-3",
      "title": "Validate Parentheses",
      "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
      "examples": [
        { "input": "\"()[]{}\"", "output": "true" },
        { "input": "\"{[()]}\"", "output": "true" },
        { "input": "\"([)]\"", "output": "false" }
      ],
      "hints": ["Use a stack. Push opening brackets, pop matching closing brackets."],
      "solutionJs": "function isValidParentheses(s) {\n  const stack = [];\n  const map = { '(': ')', '{': '}', '[': ']' };\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (map[char]) {\n      stack.push(char);\n    } else {\n      if (stack.length === 0) return false;\n      const lastOpen = stack.pop();\n      if (map[lastOpen] !== char) return false;\n    }\n  }\n  return stack.length === 0;\n}",
      "solutionPython": "def is_valid_parentheses(s):\n  stack = []\n  mapping = {')': '(', '}': '{', ']': '['}\n  for char in s:\n    if char in mapping:\n      if not stack or stack.pop() != mapping[char]:\n        return False\n    else:\n      stack.append(char)\n  return not stack",
      "solutionJava": "import java.util.Stack;\nimport java.util.HashMap;\nclass Solution {\n  public boolean isValidParentheses(String s) {\n    Stack<Character> stack = new Stack<>();\n    HashMap<Character, Character> map = new HashMap<>();\n    map.put(')', '(');\n    map.put('}', '{');\n    map.put(']', '[');\n    for (char c : s.toCharArray()) {\n      if (map.containsKey(c)) {\n        if (stack.empty() || stack.pop() != map.get(c)) return false;\n      } else {\n        stack.push(c);\n      }\n    }\n    return stack.empty();\n  }\n}",
      "solutionCpp": "bool isValidParentheses(std::string s) {\n  std::stack<char> st;\n  std::map<char, char> mapping = {{')', '('}, {'}', '{'}, {']', '['}};\n  for (char c : s) {\n    if (mapping.count(c)) { // If it's a closing bracket\n      if (st.empty() || st.top() != mapping[c]) return false;\n      st.pop();\n    } else { // If it's an opening bracket\n      st.push(c);\n    }\n  }\n  return st.empty();\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-4",
      "title": "Array Intersection",
      "description": "Given two arrays, write a function to compute their intersection (elements common to both).",
      "examples": [
        { "input": "[1,2,2,1], [2,2]", "output": "[2]" },
        { "input": "[4,9,5], [9,4,9,8,4]", "output": "[9,4]" }
      ],
      "hints": ["Use Hash Sets for efficient lookup. Convert one array to a Set, then iterate the second."],
      "solutionJs": "function intersection(nums1, nums2) {\n  const set1 = new Set(nums1);\n  const resultSet = new Set();\n  for (const num of nums2) {\n    if (set1.has(num)) {\n      resultSet.add(num);\n    }\n  }\n  return Array.from(resultSet);\n}",
      "solutionPython": "def intersection(nums1, nums2):\n  set1 = set(nums1)\n  result_set = set()\n  for num in nums2:\n    if num in set1:\n      result_set.add(num)\n  return list(result_set)",
      "solutionJava": "import java.util.HashSet;\nimport java.util.Arrays;\nclass Solution {\n  public int[] intersection(int[] nums1, int[] nums2) {\n    HashSet<Integer> set1 = new HashSet<>();\n    for (int num : nums1) set1.add(num);\n    HashSet<Integer> resultSet = new HashSet<>();\n    for (int num : nums2) {\n      if (set1.contains(num)) resultSet.add(num);\n    }\n    int[] result = new int[resultSet.size()];\n    int i = 0;\n    for (int num : resultSet) result[i++] = num;\n    return result;\n  }\n}",
      "solutionCpp": "std::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) {\n  std::unordered_set<int> set1(nums1.begin(), nums1.end());\n  std::unordered_set<int> resultSet;\n  for (int num : nums2) {\n    if (set1.count(num)) {\n      resultSet.insert(num);\n    }\n  }\n  return std::vector<int>(resultSet.begin(), resultSet.end());\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-5",
      "title": "Merge Sorted Arrays",
      "description": "Given two sorted integer arrays `nums1` and `nums2`, merge `nums2` into `nums1` as one sorted array. Assume `nums1` has enough space.",
      "examples": [
        { "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3", "output": "[1,2,2,3,5,6]" },
        { "input": "nums1 = [1], m = 1, nums2 = [], n = 0", "output": "[1]" }
      ],
      "hints": ["Start merging from the end of the arrays to avoid overwriting elements.", "Use three pointers."],
      "solutionJs": "function merge(nums1, m, nums2, n) {\n  let p1 = m - 1;\n  let p2 = n - 1;\n  let i = m + n - 1;\n  while (p2 >= 0) {\n    if (p1 >= 0 && nums1[p1] > nums2[p2]) {\n      nums1[i--] = nums1[p1--];\n    } else {\n      nums1[i--] = nums2[p2--];\n    }\n  }\n  return nums1; // In-place modification, but returning for testing clarity\n}",
      "solutionPython": "def merge(nums1, m, nums2, n):\n  p1, p2, i = m - 1, n - 1, m + n - 1\n  while p2 >= 0:\n    if p1 >= 0 and nums1[p1] > nums2[p2]:\n      nums1[i] = nums1[p1]\n      p1 -= 1\n    else:\n      nums1[i] = nums2[p2]\n      p2 -= 1\n    i -= 1",
      "solutionJava": "class Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    int p1 = m - 1;\n    int p2 = n - 1;\n    int i = m + n - 1;\n    while (p2 >= 0) {\n      if (p1 >= 0 && nums1[p1] > nums2[p2]) {\n        nums1[i--] = nums1[p1--];\n      } else {\n        nums1[i--] = nums2[p2--];\n      }\n    }\n  }\n}",
      "solutionCpp": "void merge(std::vector<int>& nums1, int m, std::vector<int>& nums2, int n) {\n  int p1 = m - 1;\n  int p2 = n - 1;\n  int i = m + n - 1;\n  while (p2 >= 0) {\n    if (p1 >= 0 && nums1[p1] > nums2[p2]) {\n      nums1[i--] = nums1[p1--];\n    } else {\n      nums1[i--] = nums2[p2--];\n    }\n  }\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-6",
      "title": "First Unique Character in a String",
      "description": "Given a string `s`, find the first non-repeating character in it and return its index. If it does not exist, return -1.",
      "examples": [
        { "input": "\"leetcode\"", "output": "0" },
        { "input": "\"loveleetcode\"", "output": "2" },
        { "input": "\"aabb\"", "output": "-1" }
      ],
      "hints": ["Use a hash map (object/dictionary) to store character counts."],
      "solutionJs": "function firstUniqueChar(s) {\n  const charCount = {};\n  for (const char of s) {\n    charCount[char] = (charCount[char] || 0) + 1;\n  }\n  for (let i = 0; i < s.length; i++) {\n    if (charCount[s[i]] === 1) {\n      return i;\n    }\n  }\n  return -1;\n}",
      "solutionPython": "from collections import Counter\ndef first_unique_char(s):\n  char_count = Counter(s)\n  for i, char in enumerate(s):\n    if char_count[char] == 1:\n      return i\n  return -1",
      "solutionJava": "import java.util.HashMap;\nclass Solution {\n  public int firstUniqChar(String s) {\n    HashMap<Character, Integer> count = new HashMap<>();\n    for (char c : s.toCharArray()) {\n      count.put(c, count.getOrDefault(c, 0) + 1);\n    }\n    for (int i = 0; i < s.length(); i++) {\n      if (count.get(s.charAt(i)) == 1) {\n        return i;\n      }\n    }\n    return -1;\n  }\n}",
      "solutionCpp": "int firstUniqChar(std::string s) {\n  std::unordered_map<char, int> charCount;\n  for (char c : s) {\n    charCount[c]++;\n  }\n  for (int i = 0; i < s.length(); i++) {\n    if (charCount[s[i]] == 1) {\n      return i;\n    }\n  }\n  return -1;\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-7",
      "title": "Container With Most Water",
      "description": "Given `n` non-negative integers `a1, a2, ..., an` where each represents a point at coordinate `(i, ai)`. `n` vertical lines are drawn such that the two endpoints of line `i` is at `(i, ai)` and `(i, 0)`. Find two lines, which, together with the x-axis, form a container that contains the most water.",
      "examples": [
        { "input": "[1,8,6,2,5,4,8,3,7]", "output": "49" },
        { "input": "[1,1]", "output": "1" }
      ],
      "hints": ["Use two pointers, one at each end. Move the pointer pointing to the shorter line inward."],
      "solutionJs": "function maxArea(height) {\n  let left = 0;\n  let right = height.length - 1;\n  let maxWater = 0;\n  while (left < right) {\n    const h = Math.min(height[left], height[right]);\n    const w = right - left;\n    maxWater = Math.max(maxWater, h * w);\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  return maxWater;\n}",
      "solutionPython": "def max_area(height):\n  left, right = 0, len(height) - 1\n  max_water = 0\n  while left < right:\n    h = min(height[left], height[right])\n    w = right - left\n    max_water = max(max_water, h * w)\n    if height[left] < height[right]:\n      left += 1\n    else:\n      right -= 1\n  return max_water",
      "solutionJava": "class Solution {\n  public int maxArea(int[] height) {\n    int left = 0;\n    int right = height.length - 1;\n    int maxWater = 0;\n    while (left < right) {\n      int h = Math.min(height[left], height[right]);\n      int w = right - left;\n      maxWater = Math.max(maxWater, h * w);\n      if (height[left] < height[right]) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n    return maxWater;\n  }\n}",
      "solutionCpp": "int maxArea(const std::vector<int>& height) {\n  int left = 0;\n  int right = height.size() - 1;\n  int maxWater = 0;\n  while (left < right) {\n    int h = std::min(height[left], height[right]);\n    int w = right - left;\n    maxWater = std::max(maxWater, h * w);\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  return maxWater;\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-8",
      "title": "Rotate Array",
      "description": "Rotate an array to the right by `k` steps, where `k` is non-negative.",
      "examples": [
        { "input": "[1,2,3,4,5,6,7], k = 3", "output": "[5,6,7,1,2,3,4]" },
        { "input": "[-1,-100,3,99], k = 2", "output": "[3,99,-1,-100]" }
      ],
      "hints": ["Use the modulo operator to handle `k` larger than array length.", "Consider reversing segments of the array."],
      "solutionJs": "function rotate(nums, k) {\n  k %= nums.length;\n  function reverse(arr, start, end) {\n    while (start < end) {\n      [arr[start], arr[end]] = [arr[end], arr[start]];\n      start++;\n      end--;\n    }\n  }\n  reverse(nums, 0, nums.length - 1);\n  reverse(nums, 0, k - 1);\n  reverse(nums, k, nums.length - 1);\n  return nums; // In-place, but returning for testing clarity\n}",
      "solutionPython": "def rotate(nums, k):\n  n = len(nums)\n  k %= n\n  nums[:] = nums[n-k:] + nums[:n-k]",
      "solutionJava": "class Solution {\n  public void rotate(int[] nums, int k) {\n    k %= nums.length;\n    reverse(nums, 0, nums.length - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, nums.length - 1);\n  }\n  private void reverse(int[] nums, int start, int end) {\n    while (start < end) {\n      int temp = nums[start];\n      nums[start] = nums[end];\n      nums[end] = temp;\n      start++;\n      end--;\n    }\n  }\n}",
      "solutionCpp": "void rotate(std::vector<int>& nums, int k) {\n  k %= nums.size();\n  std::reverse(nums.begin(), nums.end());\n  std::reverse(nums.begin(), nums.begin() + k);\n  std::reverse(nums.begin() + k, nums.end());\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-9",
      "title": "Group Anagrams",
      "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.",
      "examples": [
        { "input": "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]", "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]" },
        { "input": "[\"a\"]", "output": "[[\"a\"]]" }
      ],
      "hints": ["Anagrams have the same characters, just in a different order. Sorting the characters of a word creates a canonical key for anagrams."],
      "solutionJs": "function groupAnagrams(strs) {\n  const map = new Map();\n  for (const s of strs) {\n    const key = s.split('').sort().join('');\n    if (map.has(key)) {\n      map.get(key).push(s);\n    } else {\n      map.set(key, [s]);\n    }\n  }\n  return Array.from(map.values());\n}",
      "solutionPython": "from collections import defaultdict\ndef group_anagrams(strs):\n  anagrams = defaultdict(list)\n  for s in strs:\n    key = \"\".join(sorted(s))\n    anagrams[key].append(s)\n  return list(anagrams.values())",
      "solutionJava": "import java.util.*;\nclass Solution {\n  public List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> map = new HashMap<>();\n    for (String s : strs) {\n      char[] chars = s.toCharArray();\n      Arrays.sort(chars);\n      String key = new String(chars);\n      map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);\n    }\n    return new ArrayList<>(map.values());\n  }\n}",
      "solutionCpp": "std::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {\n  std::unordered_map<std::string, std::vector<std::string>> map;\n  for (const std::string& s : strs) {\n    std::string key = s;\n    std::sort(key.begin(), key.end());\n    map[key].push_back(s);\n  }\n  std::vector<std::vector<std::string>> result;\n  for (auto const& [key, val] : map) {\n    result.push_back(val);\n  }\n  return result;\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-10",
      "title": "Longest Palindromic Substring",
      "description": "Given a string `s`, return the longest palindromic substring in `s`.",
      "examples": [
        { "input": "\"babad\"", "output": "\"bab\"" },
        { "input": "\"cbbd\"", "output": "\"bb\"" }
      ],
      "hints": ["Expand around center. A palindrome can be centered at a character or between two characters."],
      "solutionJs": "function longestPalindrome(s) {\n  if (s.length < 1) return '';\n  let start = 0;\n  let end = 0;\n\n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    return right - left - 1;\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    const len1 = expandAroundCenter(i, i); // Odd length palindromes\n    const len2 = expandAroundCenter(i, i + 1); // Even length palindromes\n    const len = Math.max(len1, len2);\n\n    if (len > end - start) {\n      start = i - Math.floor((len - 1) / 2);\n      end = i + Math.floor(len / 2);\n    }\n  }\n  return s.substring(start, end + 1);\n}",
      "solutionPython": "def longest_palindrome(s):\n  if not s: return ''\n  start, end = 0, 0\n  def expand_around_center(l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n      l -= 1\n      r += 1\n    return r - l - 1\n\n  for i in range(len(s)):\n    len1 = expand_around_center(i, i)\n    len2 = expand_around_center(i, i + 1)\n    length = max(len1, len2)\n    if length > end - start + 1:\n      start = i - (length - 1) // 2\n      end = i + length // 2\n  return s[start : end + 1]",
      "solutionJava": "class Solution {\n  public String longestPalindrome(String s) {\n    if (s == null || s.length() < 1) return \"\";\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n      int len1 = expandAroundCenter(s, i, i);\n      int len2 = expandAroundCenter(s, i, i + 1);\n      int len = Math.max(len1, len2);\n      if (len > end - start + 1) {\n        start = i - (len - 1) / 2;\n        end = i + len / 2;\n      }\n    }\n    return s.substring(start, end + 1);\n  }\n  private int expandAroundCenter(String s, int left, int right) {\n    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n      left--;\n      right++;\n    }\n    return right - left - 1;\n  }\n}",
      "solutionCpp": "std::string longestPalindrome(std::string s) {\n  if (s.empty()) return \"\";\n  int start = 0, end = 0;\n  auto expandAroundCenter = [&](int left, int right) {\n    while (left >= 0 && right < s.length() && s[left] == s[right]) {\n      left--;\n      right++;\n    }\n    return right - left - 1;\n  };\n\n  for (int i = 0; i < s.length(); i++) {\n    int len1 = expandAroundCenter(i, i);\n    int len2 = expandAroundCenter(i, i + 1);\n    int len = std::max(len1, len2);\n\n    if (len > end - start + 1) {\n      start = i - (len - 1) / 2;\n      end = i + len / 2;\n    }\n  }\n  return s.substr(start, end - start + 1);\n}",
      "difficulty": "Medium",
      "score": 50
    },
    {
      "id": "medium-11",
      "title": "Product of Array Except Self",
      "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must write an algorithm that runs in `O(n)` time without using the division operator.",
      "examples": [
        { "input": "[1,2,3,4]", "output": "[24,12,8,6]" },
        { "input": "[-1,1,0,-3,3]", "output": "[0,0,9,0,0]" }
      ],
      "hints": ["Calculate prefix products and suffix products separately."],
      "solutionJs": "function productExceptSelf(nums) {\n  const n = nums.length;\n  const answer = new Array(n).fill(1);\n  let prefix = 1;\n  for (let i = 0; i < n; i++) {\n    answer[i] = prefix;\n    prefix *= nums[i];\n  }\n  let suffix = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    answer[i] *= suffix;\n    suffix *= nums[i];\n  }\n  return answer;\n}",
      "solutionPython": "def product_except_self(nums):\n  n = len(nums)\n  answer = [1] * n\n  prefix = 1\n  for i in range(n):\n    answer[i] = prefix\n    prefix *= nums[i]\n  suffix = 1\n  for i in range(n - 1, -1, -1):\n    answer[i] *= suffix\n    suffix *= nums[i]\n  return answer",
      "solutionJava": "class Solution {\n  public int[] productExceptSelf(int[] nums) {\n    int n = nums.length;\n    int[] answer = new int[n];\n    Arrays.fill(answer, 1);\n    int prefix = 1;\n    for (int i = 0; i < n; i++) {\n      answer[i] = prefix;\n      prefix *= nums[i];\n    }\n    int suffix = 1;\n    for (int i = n - 1; i >= 0; i--) {\n      answer[i] *= suffix;\n      suffix *= nums[i];\n    }\n    return answer;\n  }\n}",
      "solutionCpp": "std::vector<int> productExceptSelf(const std::vector<int>& nums) {\n  int n = nums.size();\n  std::vector<int> answer(n, 1);\n  int prefix = 1;\n  for (int i = 0; i < n; i++) {\n    answer[i] = prefix;\n    prefix *= nums[i];\n  }\n  int suffix = 1;\n  for (int i = n - 1; i >= 0; i--) {\n    answer[i] *= suffix;\n    suffix *= nums[i];\n  }\n  return answer;\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-12",
      "title": "Number of Islands",
      "description": "Given an `m x n` 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
      "examples": [
        { "input": "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]", "output": "1" },
        { "input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]", "output": "3" }
      ],
      "hints": ["Use DFS or BFS to traverse and mark visited land cells. Increment island count each time you start a new traversal."],
      "solutionJs": "function numIslands(grid) {\n  let numRows = grid.length;\n  if (numRows === 0) return 0;\n  let numCols = grid[0].length;\n  let numIslands = 0;\n\n  function dfs(r, c) {\n    if (r < 0 || r >= numRows || c < 0 || c >= numCols || grid[r][c] === '0') {\n      return;\n    }\n    grid[r][c] = '0'; // Mark as visited\n    dfs(r + 1, c);\n    dfs(r - 1, c);\n    dfs(r, c + 1);\n    dfs(r, c - 1);\n  }\n\n  for (let r = 0; r < numRows; r++) {\n    for (let c = 0; c < numCols; c++) {\n      if (grid[r][c] === '1') {\n        numIslands++;\n        dfs(r, c);\n      }\n    }\n  }\n  return numIslands;\n}",
      "solutionPython": "def num_islands(grid):\n  num_rows = len(grid)\n  if num_rows == 0: return 0\n  num_cols = len(grid[0])\n  num_islands = 0\n\n  def dfs(r, c):\n    if r < 0 or r >= num_rows or c < 0 or c >= num_cols or grid[r][c] == '0':\n      return\n    grid[r][c] = '0'\n    dfs(r + 1, c)\n    dfs(r - 1, c)\n    dfs(r, c + 1)\n    dfs(r, c - 1)\n\n  for r in range(num_rows):\n    for c in range(num_cols):\n      if grid[r][c] == '1':\n        num_islands += 1\n        dfs(r, c)\n  return num_islands",
      "solutionJava": "class Solution {\n  public int numIslands(char[][] grid) {\n    int numRows = grid.length;\n    if (numRows == 0) return 0;\n    int numCols = grid[0].length;\n    int numIslands = 0;\n    for (int r = 0; r < numRows; r++) {\n      for (int c = 0; c < numCols; c++) {\n        if (grid[r][c] == '1') {\n          numIslands++;\n          dfs(grid, r, c);\n        }\n      }\n    }\n    return numIslands;\n  }\n  private void dfs(char[][] grid, int r, int c) {\n    int numRows = grid.length;\n    int numCols = grid[0].length;\n    if (r < 0 || r >= numRows || c < 0 || c >= numCols || grid[r][c] == '0') {\n      return;\n    }\n    grid[r][c] = '0'; // Mark as visited\n    dfs(grid, r + 1, c);\n    dfs(grid, r - 1, c);\n    dfs(grid, r, c + 1);\n    dfs(grid, r, c - 1);\n  }\n}",
      "solutionCpp": "void dfs(std::vector<std::vector<char>>& grid, int r, int c) {\n  int numRows = grid.size();\n  int numCols = grid[0].size();\n  if (r < 0 || r >= numRows || c < 0 || c >= numCols || grid[r][c] == '0') {\n    return;\n  }\n  grid[r][c] = '0';\n  dfs(grid, r + 1, c);\n  dfs(grid, r - 1, c);\n  dfs(grid, r, c + 1);\n  dfs(grid, r, c - 1);\n}\nint numIslands(std::vector<std::vector<char>>& grid) {\n  int numRows = grid.size();\n  if (numRows == 0) return 0;\n  int numCols = grid[0].size();\n  int numIslands = 0;\n  for (int r = 0; r < numRows; r++) {\n    for (int c = 0; c < numCols; c++) {\n      if (grid[r][c] == '1') {\n        numIslands++;\n        dfs(grid, r, c);\n      }\n    }\n  }\n  return numIslands;\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-13",
      "title": "Zigzag Conversion",
      "description": "The string `s` is written in a zigzag pattern on a given number of rows `numRows`. Convert the string as if reading row by row.",
      "examples": [
        { "input": "\"PAYPALISHIRING\", numRows = 3", "output": "\"PAHNAPLSIIGYIR\"" },
        { "input": "\"PAYPALISHIRING\", numRows = 4", "output": "\"PINALSIGYAHRPI\"" }
      ],
      "hints": ["Simulate the zigzag pattern by moving down and up. Use an array of strings to build rows."],
      "solutionJs": "function convert(s, numRows) {\n  if (numRows === 1) return s;\n  const rows = Array(numRows).fill('');\n  let currentRow = 0;\n  let goingDown = false;\n  for (const char of s) {\n    rows[currentRow] += char;\n    if (currentRow === 0 || currentRow === numRows - 1) {\n      goingDown = !goingDown;\n    }\n    currentRow += goingDown ? 1 : -1;\n  }\n  return rows.join('');\n}",
      "solutionPython": "def convert(s, num_rows):\n  if num_rows == 1: return s\n  rows = [''] * num_rows\n  current_row = 0\n  going_down = False\n  for char in s:\n    rows[current_row] += char\n    if current_row == 0 or current_row == num_rows - 1:\n      going_down = not going_down\n    current_row += 1 if going_down else -1\n  return ''.join(rows)",
      "solutionJava": "class Solution {\n  public String convert(String s, int numRows) {\n    if (numRows == 1) return s;\n    StringBuilder[] rows = new StringBuilder[numRows];\n    for (int i = 0; i < numRows; i++) {\n      rows[i] = new StringBuilder();\n    }\n    int currentRow = 0;\n    boolean goingDown = false;\n    for (char c : s.toCharArray()) {\n      rows[currentRow].append(c);\n      if (currentRow == 0 || currentRow == numRows - 1) {\n        goingDown = !goingDown;\n      }\n      currentRow += goingDown ? 1 : -1;\n    }\n    StringBuilder result = new StringBuilder();\n    for (StringBuilder row : rows) {\n      result.append(row);\n    }\n    return result.toString();\n  }\n}",
      "solutionCpp": "std::string convert(std::string s, int numRows) {\n  if (numRows == 1) return s;\n  std::vector<std::string> rows(numRows);\n  int currentRow = 0;\n  bool goingDown = false;\n  for (char c : s) {\n    rows[currentRow] += c;\n    if (currentRow == 0 || currentRow == numRows - 1) {\n      goingDown = !goingDown;\n    }\n    currentRow += goingDown ? 1 : -1;\n  }\n  std::string result = \"\";\n  for (const std::string& row : rows) {\n    result += row;\n  }\n  return result;\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-14",
      "title": "Reverse Words in a String",
      "description": "Given an input string `s`, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in `s` will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space.",
      "examples": [
        { "input": "\"the sky is blue\"", "output": "\"blue is sky the\"" },
        { "input": "\"  hello world  \"", "output": "\"world hello\"" }
      ],
      "hints": ["Split the string by spaces. Filter out empty strings. Reverse the resulting array of words."],
      "solutionJs": "function reverseWords(s) {\n  return s.trim().split(/\\s+/).reverse().join(' ');\n}",
      "solutionPython": "def reverse_words(s):\n  return ' '.join(s.split()[::-1])",
      "solutionJava": "class Solution {\n  public String reverseWords(String s) {\n    String[] words = s.trim().split(\"\\\\s+\");\n    StringBuilder reversed = new StringBuilder();\n    for (int i = words.length - 1; i >= 0; i--) {\n      reversed.append(words[i]);\n      if (i > 0) reversed.append(\" \");\n    }\n    return reversed.toString();\n  }\n}",
      "solutionCpp": "std::string reverseWords(std::string s) {\n  std::stringstream ss(s);\n  std::string word;\n  std::vector<std::string> words;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  std::string result = \"\";\n  for (int i = words.size() - 1; i >= 0; i--) {\n    result += words[i];\n    if (i > 0) result += \" \";\n  }\n  return result;\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-15",
      "title": "Search in Rotated Sorted Array",
      "description": "There is an integer array `nums` sorted in ascending order (with distinct values). Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index `k`. Given the array `nums` after the rotation and an integer `target`, return the index of `target` if it is in `nums`, or -1 if it is not in `nums`. You must write an algorithm with `O(log n)` runtime complexity.",
      "examples": [
        { "input": "[4,5,6,7,0,1,2], target = 0", "output": "4" },
        { "input": "[4,5,6,7,0,1,2], target = 3", "output": "-1" }
      ],
      "hints": ["Use a modified binary search. Determine which half is sorted."],
      "solutionJs": "function search(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    // Check if left half is sorted\n    if (nums[left] <= nums[mid]) {\n      if (nums[left] <= target && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else { // Right half is sorted\n      if (nums[mid] < target && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}",
      "solutionPython": "def search(nums, target):\n  left, right = 0, len(nums) - 1\n  while left <= right:\n    mid = (left + right) // 2\n    if nums[mid] == target: return mid\n    if nums[left] <= nums[mid]: # Left half is sorted\n      if nums[left] <= target < nums[mid]:\n        right = mid - 1\n      else:\n        left = mid + 1\n    else: # Right half is sorted\n      if nums[mid] < target <= nums[right]:\n        left = mid + 1\n      else:\n        right = mid - 1\n  return -1",
      "solutionJava": "class Solution {\n  public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] == target) return mid;\n      if (nums[left] <= nums[mid]) { // Left side is sorted\n        if (nums[left] <= target && target < nums[mid]) {\n          right = mid - 1;\n        } else {\n          left = mid + 1;\n        }\n      } else { // Right side is sorted\n        if (nums[mid] < target && target <= nums[right]) {\n          left = mid + 1;\n        } else {\n          right = mid - 1;\n        }\n      }\n    }\n    return -1;\n  }\n}",
      "solutionCpp": "int search(const std::vector<int>& nums, int target) {\n  int left = 0, right = nums.size() - 1;\n  while (left <= right) {\n    int mid = left + (right - left) / 2;\n    if (nums[mid] == target) return mid;\n    if (nums[left] <= nums[mid]) { // Left side is sorted\n      if (nums[left] <= target && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else { // Right side is sorted\n      if (nums[mid] < target && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-16",
      "title": "Jump Game",
      "description": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in `nums` represents your maximum jump length at that position. Return `true` if you can reach the last index, or `false` otherwise.",
      "examples": [
        { "input": "[2,3,1,1,4]", "output": "true" },
        { "input": "[3,2,1,0,4]", "output": "false" }
      ],
      "hints": ["Use a 'greedy' approach. Keep track of the furthest reachable position."],
      "solutionJs": "function canJump(nums) {\n  let maxReach = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (i > maxReach) {\n      return false; // Cannot reach current position\n    }\n    maxReach = Math.max(maxReach, i + nums[i]);\n    if (maxReach >= nums.length - 1) {\n      return true; // Reached or surpassed the last index\n    }\n  }\n  return true; // Should be true if loop finishes without returning false\n}",
      "solutionPython": "def can_jump(nums):\n  max_reach = 0\n  for i in range(len(nums)):\n    if i > max_reach: return False\n    max_reach = max(max_reach, i + nums[i])\n    if max_reach >= len(nums) - 1: return True\n  return True",
      "solutionJava": "class Solution {\n  public boolean canJump(int[] nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.length; i++) {\n      if (i > maxReach) {\n        return false;\n      }\n      maxReach = Math.max(maxReach, i + nums[i]);\n      if (maxReach >= nums.length - 1) {\n        return true;\n      }\n    }\n    return true;\n  }\n}",
      "solutionCpp": "bool canJump(const std::vector<int>& nums) {\n  int maxReach = 0;\n  for (int i = 0; i < nums.size(); ++i) {\n    if (i > maxReach) {\n      return false;\n    }\n    maxReach = std::max(maxReach, i + nums[i]);\n    if (maxReach >= nums.size() - 1) {\n      return true;\n    }\n  }\n  return true;\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-17",
      "title": "Subarray Sum Equals K",
      "description": "Given an array of integers `nums` and an integer `k`, return the total number of subarrays whose sum equals to `k`.",
      "examples": [
        { "input": "[1,1,1], k = 2", "output": "2" },
        { "input": "[1,2,3], k = 3", "output": "2" }
      ],
      "hints": ["Use a hash map to store cumulative sums and their frequencies. `(current_sum - k)` should be present in the map."],
      "solutionJs": "function subarraySum(nums, k) {\n  let count = 0;\n  let sum = 0;\n  const sumMap = { 0: 1 }; // cumulative sum -> frequency\n  for (const num of nums) {\n    sum += num;\n    if (sumMap[sum - k]) {\n      count += sumMap[sum - k];\n    }\n    sumMap[sum] = (sumMap[sum] || 0) + 1;\n  }\n  return count;\n}",
      "solutionPython": "from collections import defaultdict\ndef subarray_sum(nums, k):\n  count = 0\n  current_sum = 0\n  sum_map = defaultdict(int)\n  sum_map[0] = 1\n  for num in nums:\n    current_sum += num\n    if (current_sum - k) in sum_map:\n      count += sum_map[current_sum - k]\n    sum_map[current_sum] += 1\n  return count",
      "solutionJava": "import java.util.HashMap;\nclass Solution {\n  public int subarraySum(int[] nums, int k) {\n    int count = 0;\n    int sum = 0;\n    HashMap<Integer, Integer> sumMap = new HashMap<>();\n    sumMap.put(0, 1);\n    for (int num : nums) {\n      sum += num;\n      if (sumMap.containsKey(sum - k)) {\n        count += sumMap.get(sum - k);\n      }\n      sumMap.put(sum, sumMap.getOrDefault(sum, 0) + 1);\n    }\n    return count;\n  }\n}",
      "solutionCpp": "int subarraySum(const std::vector<int>& nums, int k) {\n  int count = 0;\n  int currentSum = 0;\n  std::unordered_map<int, int> sumMap;\n  sumMap[0] = 1;\n  for (int num : nums) {\n    currentSum += num;\n    if (sumMap.count(currentSum - k)) {\n      count += sumMap[currentSum - k];\n    }\n    sumMap[currentSum]++;\n  }\n  return count;\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-18",
      "title": "Minimum Path Sum",
      "description": "Given a `m x n` grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.",
      "examples": [
        { "input": "[[1,3,1],[1,5,1],[4,2,1]]", "output": "7 (1->1->2->1)" },
        { "input": "[[1,2,3],[4,5,6]]", "output": "12" }
      ],
      "hints": ["Use dynamic programming. The minimum path sum to a cell `(i,j)` is `grid[i][j]` + `min(dp[i-1][j], dp[i][j-1])`."],
      "solutionJs": "function minPathSum(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n  const dp = Array(m).fill(0).map(() => Array(n).fill(0));\n\n  for (let r = 0; r < m; r++) {\n    for (let c = 0; c < n; c++) {\n      if (r === 0 && c === 0) {\n        dp[r][c] = grid[r][c];\n      } else if (r === 0) {\n        dp[r][c] = grid[r][c] + dp[r][c - 1];\n      } else if (c === 0) {\n        dp[r][c] = grid[r][c] + dp[r - 1][c];\n      } else {\n        dp[r][c] = grid[r][c] + Math.min(dp[r - 1][c], dp[r][c - 1]);\n      }\n    }\n  }\n  return dp[m - 1][n - 1];\n}",
      "solutionPython": "def min_path_sum(grid):\n  m, n = len(grid), len(grid[0])\n  dp = [[0] * n for _ in range(m)]\n\n  for r in range(m):\n    for c in range(n):\n      if r == 0 and c == 0:\n        dp[r][c] = grid[r][c]\n      elif r == 0:\n        dp[r][c] = grid[r][c] + dp[r][c - 1]\n      elif c == 0:\n        dp[r][c] = grid[r][c] + dp[r - 1][c]\n      else:\n        dp[r][c] = grid[r][c] + min(dp[r - 1][c], dp[r][c - 1])\n  return dp[m - 1][n - 1]",
      "solutionJava": "class Solution {\n  public int minPathSum(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    int[][] dp = new int[m][n];\n\n    for (int r = 0; r < m; r++) {\n      for (int c = 0; c < n; c++) {\n        if (r == 0 && c == 0) {\n          dp[r][c] = grid[r][c];\n        } else if (r == 0) {\n          dp[r][c] = grid[r][c] + dp[r][c - 1];\n        } else if (c == 0) {\n          dp[r][c] = grid[r][c] + dp[r - 1][c];\n        } else {\n          dp[r][c] = grid[r][c] + Math.min(dp[r - 1][c], dp[r][c - 1]);\n        }\n      }\n    }\n    return dp[m - 1][n - 1];\n  }\n}",
      "solutionCpp": "int minPathSum(const std::vector<std::vector<int>>& grid) {\n  int m = grid.size();\n  int n = grid[0].size();\n  std::vector<std::vector<int>> dp(m, std::vector<int>(n));\n  for (int r = 0; r < m; ++r) {\n    for (int c = 0; c < n; ++c) {\n      if (r == 0 && c == 0) {\n        dp[r][c] = grid[r][c];\n      } else if (r == 0) {\n        dp[r][c] = grid[r][c] + dp[r][c - 1];\n      } else if (c == 0) {\n        dp[r][c] = grid[r][c] + dp[r - 1][c];\n      } else {\n        dp[r][c] = grid[r][c] + std::min(dp[r - 1][c], dp[r][c - 1]);\n      }\n    }\n  }\n  return dp[m - 1][n - 1];\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-19",
      "title": "Decode Ways",
      "description": "A message containing letters from `A-Z` is being encoded to numbers using the following mapping: `'A' -> 1`, `'B' -> 2`, ..., `'Z' -> 26`. Given a string `s` containing only digits, return the number of ways to decode it.",
      "examples": [
        { "input": "\"12\"", "output": "2 (AB (1 2) or L (12))" },
        { "input": "\"226\"", "output": "3 (BZ (2 26), VF (22 6), BBF (2 2 6))" }
      ],
      "hints": ["Use dynamic programming. Consider one-digit and two-digit decodings."],
      "solutionJs": "function numDecodings(s) {\n  if (s[0] === '0') return 0;\n  const n = s.length;\n  const dp = new Array(n + 1).fill(0);\n  dp[0] = 1;\n  dp[1] = 1;\n\n  for (let i = 2; i <= n; i++) {\n    const oneDigit = parseInt(s.substring(i - 1, i));\n    const twoDigits = parseInt(s.substring(i - 2, i));\n\n    if (oneDigit >= 1 && oneDigit <= 9) {\n      dp[i] += dp[i - 1];\n    }\n    if (twoDigits >= 10 && twoDigits <= 26) {\n      dp[i] += dp[i - 2];\n    }\n  }\n  return dp[n];\n}",
      "solutionPython": "def num_decodings(s):\n  if s[0] == '0': return 0\n  n = len(s)\n  dp = [0] * (n + 1)\n  dp[0] = 1\n  dp[1] = 1\n\n  for i in range(2, n + 1):\n    one_digit = int(s[i-1:i])\n    two_digits = int(s[i-2:i])\n\n    if 1 <= one_digit <= 9:\n      dp[i] += dp[i-1]\n    if 10 <= two_digits <= 26:\n      dp[i] += dp[i-2]\n  return dp[n]",
      "solutionJava": "class Solution {\n  public int numDecodings(String s) {\n    if (s.charAt(0) == '0') return 0;\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n      int oneDigit = Integer.parseInt(s.substring(i - 1, i));\n      int twoDigits = Integer.parseInt(s.substring(i - 2, i));\n      if (oneDigit >= 1 && oneDigit <= 9) {\n        dp[i] += dp[i - 1];\n      }\n      if (twoDigits >= 10 && twoDigits <= 26) {\n        dp[i] += dp[i - 2];\n      }\n    }\n    return dp[n];\n  }\n}",
      "solutionCpp": "int numDecodings(std::string s) {\n  if (s[0] == '0') return 0;\n  int n = s.length();\n  std::vector<int> dp(n + 1, 0);\n  dp[0] = 1;\n  dp[1] = 1;\n\n  for (int i = 2; i <= n; ++i) {\n    int oneDigit = std::stoi(s.substr(i - 1, 1));\n    int twoDigits = std::stoi(s.substr(i - 2, 2));\n\n    if (oneDigit >= 1 && oneDigit <= 9) {\n      dp[i] += dp[i - 1];\n    }\n    if (twoDigits >= 10 && twoDigits <= 26) {\n      dp[i] += dp[i - 2];\n    }\n  }\n  return dp[n];\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-20",
      "title": "Top K Frequent Elements",
      "description": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.",
      "examples": [
        { "input": "[1,1,1,2,2,3], k = 2", "output": "[1,2] (order may vary)" },
        { "input": "[1], k = 1", "output": "[1]" }
      ],
      "hints": ["Use a hash map to count frequencies. Then use a min-heap (priority queue) or sort the entries."],
      "solutionJs": "function topKFrequent(nums, k) {\n  const freqMap = new Map();\n  for (const num of nums) {\n    freqMap.set(num, (freqMap.get(num) || 0) + 1);\n  }\n  const sortedEntries = Array.from(freqMap.entries()).sort((a, b) => b[1] - a[1]);\n  return sortedEntries.slice(0, k).map(entry => entry[0]);\n}",
      "solutionPython": "from collections import Counter\ndef top_k_frequent(nums, k):\n  counts = Counter(nums)\n  return [item[0] for item in counts.most_common(k)]",
      "solutionJava": "import java.util.*;\nclass Solution {\n  public int[] topKFrequent(int[] nums, int k) {\n    Map<Integer, Integer> freqMap = new HashMap<>();\n    for (int num : nums) freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n    // Min-heap to store (number, frequency) pairs, ordered by frequency\n    PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(\n      (a, b) -> a.getValue() - b.getValue()\n    );\n    for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\n      pq.offer(entry);\n      if (pq.size() > k) pq.poll();\n    }\n    int[] result = new int[k];\n    for (int i = k - 1; i >= 0; i--) {\n      result[i] = pq.poll().getKey();\n    }\n    return result;\n  }\n}",
      "solutionCpp": "std::vector<int> topKFrequent(std::vector<int>& nums, int k) {\n  std::unordered_map<int, int> freqMap;\n  for (int num : nums) {\n    freqMap[num]++;\n  }\n  // Pair: (frequency, number)\n  std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;\n\n  for (auto const& [num, freq] : freqMap) {\n    pq.push({freq, num});\n    if (pq.size() > k) {\n      pq.pop();\n    }\n  }\n  std::vector<int> result;\n  while (!pq.empty()) {\n    result.push_back(pq.top().second);\n    pq.pop();\n  }\n  std::reverse(result.begin(), result.end());\n  return result;\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-21",
      "title": "Longest Substring Without Repeating Characters",
      "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
      "examples": [
        { "input": "\"abcabcbb\"", "output": "3 (abc)" },
        { "input": "\"bbbbb\"", "output": "1 (b)" },
        { "input": "\"pwwkew\"", "output": "3 (wke)" }
      ],
      "hints": ["Use a sliding window approach with a hash set/map to store characters in the current window."],
      "solutionJs": "function lengthOfLongestSubstring(s) {\n  let left = 0;\n  let maxLength = 0;\n  const charSet = new Set();\n  for (let right = 0; right < s.length; right++) {\n    while (charSet.has(s[right])) {\n      charSet.delete(s[left]);\n      left++;\n    }\n    charSet.add(s[right]);\n    maxLength = Math.max(maxLength, right - left + 1);\n  }\n  return maxLength;\n}",
      "solutionPython": "def length_of_longest_substring(s):\n  left = 0\n  max_length = 0\n  char_set = set()\n  for right in range(len(s)):\n    while s[right] in char_set:\n      char_set.remove(s[left])\n      left += 1\n    char_set.add(s[right])\n    max_length = max(max_length, right - left + 1)\n  return max_length",
      "solutionJava": "import java.util.HashSet;\nclass Solution {\n  public int lengthOfLongestSubstring(String s) {\n    int left = 0;\n    int maxLength = 0;\n    HashSet<Character> charSet = new HashSet<>();\n    for (int right = 0; right < s.length(); right++) {\n      while (charSet.contains(s.charAt(right))) {\n        charSet.remove(s.charAt(left));\n        left++;\n      }\n      charSet.add(s.charAt(right));\n      maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n  }\n}",
      "solutionCpp": "int lengthOfLongestSubstring(const std::string& s) {\n  int left = 0;\n  int maxLength = 0;\n  std::unordered_set<char> charSet;\n  for (int right = 0; right < s.length(); ++right) {\n    while (charSet.count(s[right])) {\n      charSet.erase(s[left]);\n      left++;\n    }\n    charSet.insert(s[right]);\n    maxLength = std::max(maxLength, right - left + 1);\n  }\n  return maxLength;\n}",
      "difficulty": "Medium",
      "score": 75
    },
    {
      "id": "medium-22",
      "title": "Add Two Numbers (Linked Lists)",
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
      "examples": [
        { "input": "(2 -> 4 -> 3) + (5 -> 6 -> 4)", "output": "(7 -> 0 -> 8) (342 + 465 = 807)" },
        { "input": "(0) + (0)", "output": "(0)" }
      ],
      "hints": ["Iterate through both lists simultaneously. Keep track of a carry-over digit."],
      "solutionJs": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n * this.val = (val===undefined ? 0 : val)\n * this.next = (next===undefined ? null : next)\n * }\n */\nfunction addTwoNumbers(l1, l2) {\n  let dummyHead = new ListNode(0);\n  let current = dummyHead;\n  let carry = 0;\n  while (l1 !== null || l2 !== null || carry !== 0) {\n    const val1 = l1 ? l1.val : 0;\n    const val2 = l2 ? l2.val : 0;\n    const sum = val1 + val2 + carry;\n    carry = Math.floor(sum / 10);\n    current.next = new ListNode(sum % 10);\n    current = current.next;\n    if (l1) l1 = l1.next;\n    if (l2) l2 = l2.next;\n  }\n  return dummyHead.next;\n}",
      "solutionPython": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\ndef add_two_numbers(l1, l2):\n  dummy_head = ListNode(0)\n  current = dummy_head\n  carry = 0\n  while l1 or l2 or carry:\n    val1 = l1.val if l1 else 0\n    val2 = l2.val if l2 else 0\n    total = val1 + val2 + carry\n    carry = total // 10\n    current.next = ListNode(total % 10)\n    current = current.next\n    l1 = l1.next if l1 else None\n    l2 = l2.next if l2 else None\n  return dummy_head.next",
      "solutionJava": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; }\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode current = dummyHead;\n    int carry = 0;\n    while (l1 != null || l2 != null || carry != 0) {\n      int val1 = (l1 != null) ? l1.val : 0;\n      int val2 = (l2 != null) ? l2.val : 0;\n      int sum = val1 + val2 + carry;\n      carry = sum / 10;\n      current.next = new ListNode(sum % 10);\n      current = current.next;\n      if (l1 != null) l1 = l1.next;\n      if (l2 != null) l2 = l2.next;\n    }\n    return dummyHead.next;\n  }\n}",
      "solutionCpp": "struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummyHead(0);\n        ListNode* current = &dummyHead;\n        int carry = 0;\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\n            int val1 = (l1 != nullptr) ? l1->val : 0;\n            int val2 = (l2 != nullptr) ? l2->val : 0;\n            int sum = val1 + val2 + carry;\n            carry = sum / 10;\n            current->next = new ListNode(sum % 10);\n            current = current->next;\n            if (l1 != nullptr) l1 = l1->next;\n            if (l2 != nullptr) l2 = l2->next;\n        }\n        return dummyHead.next;\n    }\n};",
      "difficulty": "Medium",
      "score": 100
    },
    {
      "id": "medium-23",
      "title": "Longest Increasing Subsequence",
      "description": "Given an integer array `nums`, return the length of the longest strictly increasing subsequence.",
      "examples": [
        { "input": "[10,9,2,5,3,7,101,18]", "output": "4 (e.g., [2,3,7,101])" },
        { "input": "[7,7,7,7,7,7,7]", "output": "1" }
      ],
      "hints": ["Use dynamic programming (DP). `dp[i]` could store the length of the LIS ending at index `i`."],
      "solutionJs": "function lengthOfLIS(nums) {\n  if (nums.length === 0) return 0;\n  const dp = Array(nums.length).fill(1);\n  let maxLength = 1;\n\n  for (let i = 1; i < nums.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j]) {\n        dp[i] = Math.max(dp[i], 1 + dp[j]);\n      }\n    }\n    maxLength = Math.max(maxLength, dp[i]);\n  }\n  return maxLength;\n}",
      "solutionPython": "def length_of_lis(nums):\n  if not nums: return 0\n  dp = [1] * len(nums)\n  max_length = 1\n  for i in range(1, len(nums)):\n    for j in range(i):\n      if nums[i] > nums[j]:\n        dp[i] = max(dp[i], 1 + dp[j])\n    max_length = max(max_length, dp[i])\n  return max_length",
      "solutionJava": "import java.util.Arrays;\nclass Solution {\n  public int lengthOfLIS(int[] nums) {\n    if (nums == null || nums.length == 0) return 0;\n    int[] dp = new int[nums.length];\n    Arrays.fill(dp, 1);\n    int maxLength = 1;\n    for (int i = 1; i < nums.length; i++) {\n      for (int j = 0; j < i; j++) {\n        if (nums[i] > nums[j]) {\n          dp[i] = Math.max(dp[i], 1 + dp[j]);\n        }\n      }\n      maxLength = Math.max(maxLength, dp[i]);\n    }\n    return maxLength;\n  }\n}",
      "solutionCpp": "int lengthOfLIS(const std::vector<int>& nums) {\n  if (nums.empty()) return 0;\n  std::vector<int> dp(nums.size(), 1);\n  int maxLength = 1;\n  for (int i = 1; i < nums.size(); ++i) {\n    for (int j = 0; j < i; ++j) {\n      if (nums[i] > nums[j]) {\n        dp[i] = std::max(dp[i], 1 + dp[j]);\n      }\n    }\n    maxLength = std::max(maxLength, dp[i]);\n  }\n  return maxLength;\n}",
      "difficulty": "Medium",
      "score": 100
    },
    {
      "id": "medium-24",
      "title": "Coin Change",
      "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
      "examples": [
        { "input": "coins = [1,2,5], amount = 11", "output": "3 (11 = 5 + 5 + 1)" },
        { "input": "coins = [2], amount = 3", "output": "-1" }
      ],
      "hints": ["Use dynamic programming. `dp[i]` can store the minimum coins needed for amount `i`."],
      "solutionJs": "function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (i - coin >= 0) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}",
      "solutionPython": "def coin_change(coins, amount):\n  dp = [float('inf')] * (amount + 1)\n  dp[0] = 0\n  for i in range(1, amount + 1):\n    for coin in coins:\n      if i - coin >= 0:\n        dp[i] = min(dp[i], dp[i - coin] + 1)\n  return dp[amount] if dp[amount] != float('inf') else -1",
      "solutionJava": "import java.util.Arrays;\nclass Solution {\n  public int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1); // Use amount + 1 as 'infinity'\n    dp[0] = 0;\n    for (int i = 1; i <= amount; i++) {\n      for (int coin : coins) {\n        if (i - coin >= 0) {\n          dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n      }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n  }\n}",
      "solutionCpp": "int coinChange(const std::vector<int>& coins, int amount) {\n  std::vector<int> dp(amount + 1, amount + 1);\n  dp[0] = 0;\n  for (int i = 1; i <= amount; ++i) {\n    for (int coin : coins) {\n      if (i - coin >= 0) {\n        dp[i] = std::min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n  return dp[amount] > amount ? -1 : dp[amount];\n}",
      "difficulty": "Medium",
      "score": 100
    },
    {
      "id": "medium-25",
      "title": "Unique Paths",
      "description": "There is a robot on an `m x n` grid. The robot is initially located at the top-left corner (i.e., `grid[0][0]`). The robot tries to move to the bottom-right corner (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time. Given the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
      "examples": [
        { "input": "m = 3, n = 7", "output": "28" },
        { "input": "m = 3, n = 2", "output": "3" }
      ],
      "hints": ["This is a classic dynamic programming problem. `dp[i][j] = dp[i-1][j] + dp[i][j-1]`."],
      "solutionJs": "function uniquePaths(m, n) {\n  const dp = Array(m).fill(0).map(() => Array(n).fill(0));\n  for (let r = 0; r < m; r++) dp[r][0] = 1;\n  for (let c = 0; c < n; c++) dp[0][c] = 1;\n\n  for (let r = 1; r < m; r++) {\n    for (let c = 1; c < n; c++) {\n      dp[r][c] = dp[r - 1][c] + dp[r][c - 1];\n    }\n  }\n  return dp[m - 1][n - 1];\n}",
      "solutionPython": "def unique_paths(m, n):\n  dp = [[0] * n for _ in range(m)]\n  for r in range(m): dp[r][0] = 1\n  for c in range(n): dp[0][c] = 1\n\n  for r in range(1, m):\n    for c in range(1, n):\n      dp[r][c] = dp[r-1][c] + dp[r][c-1]\n  return dp[m-1][n-1]",
      "solutionJava": "class Solution {\n  public int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int r = 0; r < m; r++) dp[r][0] = 1;\n    for (int c = 0; c < n; c++) dp[0][c] = 1;\n    for (int r = 1; r < m; r++) {\n      for (int c = 1; c < n; c++) {\n        dp[r][c] = dp[r - 1][c] + dp[r][c - 1];\n      }\n    }\n    return dp[m - 1][n - 1];\n  }\n}",
      "solutionCpp": "int uniquePaths(int m, int n) {\n  std::vector<std::vector<int>> dp(m, std::vector<int>(n, 0));\n  for (int r = 0; r < m; ++r) dp[r][0] = 1;\n  for (int c = 0; c < n; ++c) dp[0][c] = 1;\n  for (int r = 1; r < m; ++r) {\n    for (int c = 1; c < n; ++c) {\n      dp[r][c] = dp[r - 1][c] + dp[r][c - 1];\n    }\n  }\n  return dp[m - 1][n - 1];\n}",
      "difficulty": "Medium",
      "score": 100
    },
    {
      "id": "medium-26",
      "title": "Maximum Subarray",
      "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.",
      "examples": [
        { "input": "[-2,1,-3,4,-1,2,1,-5,4]", "output": "6 ([4,-1,2,1])" },
        { "input": "[1]", "output": "1" }
      ],
      "hints": ["Kadane's algorithm. Keep track of current sum and max sum found so far."],
      "solutionJs": "function maxSubArray(nums) {\n  let currentMax = nums[0];\n  let globalMax = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    currentMax = Math.max(nums[i], currentMax + nums[i]);\n    globalMax = Math.max(globalMax, currentMax);\n  }\n  return globalMax;\n}",
      "solutionPython": "def max_subarray(nums):\n  current_max = nums[0]\n  global_max = nums[0]\n  for i in range(1, len(nums)):\n    current_max = max(nums[i], current_max + nums[i])\n    global_max = max(global_max, current_max)\n  return global_max",
      "solutionJava": "class Solution {\n  public int maxSubArray(int[] nums) {\n    int currentMax = nums[0];\n    int globalMax = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n      currentMax = Math.max(nums[i], currentMax + nums[i]);\n      globalMax = Math.max(globalMax, currentMax);\n    }\n    return globalMax;\n  }\n}",
      "solutionCpp": "int maxSubArray(const std::vector<int>& nums) {\n  int currentMax = nums[0];\n  int globalMax = nums[0];\n  for (int i = 1; i < nums.size(); ++i) {\n    currentMax = std::max(nums[i], currentMax + nums[i]);\n    globalMax = std::max(globalMax, currentMax);\n  }\n  return globalMax;\n}",
      "difficulty": "Medium",
      "score": 100
    },
    {
      "id": "medium-27",
      "title": "Longest Common Prefix",
      "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string `\"\"`.",
      "examples": [
        { "input": "[\"flower\",\"flow\",\"flight\"]", "output": "\"fl\"" },
        { "input": "[\"dog\",\"racecar\",\"car\"]", "output": "\"\"" }
      ],
      "hints": ["Compare characters at the same index across all strings. Stop when a mismatch is found or a string ends."],
      "solutionJs": "function longestCommonPrefix(strs) {\n  if (strs.length === 0) return '';\n  let prefix = strs[0];\n  for (let i = 1; i < strs.length; i++) {\n    while (strs[i].indexOf(prefix) !== 0) {\n      prefix = prefix.substring(0, prefix.length - 1);\n      if (prefix === '') return '';\n    }\n  }\n  return prefix;\n}",
      "solutionPython": "def longest_common_prefix(strs):\n  if not strs: return \"\"\n  prefix = strs[0]\n  for i in range(1, len(strs)):\n    while not strs[i].startswith(prefix):\n      prefix = prefix[:-1]\n      if not prefix: return \"\"\n  return prefix",
      "solutionJava": "class Solution {\n  public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++) {\n      while (strs[i].indexOf(prefix) != 0) {\n        prefix = prefix.substring(0, prefix.length() - 1);\n        if (prefix.isEmpty()) return \"\";\n      }\n    }\n    return prefix;\n  }\n}",
      "solutionCpp": "std::string longestCommonPrefix(std::vector<std::string>& strs) {\n  if (strs.empty()) return \"\";\n  std::string prefix = strs[0];\n  for (size_t i = 1; i < strs.size(); ++i) {\n    while (strs[i].find(prefix) != 0) {\n      prefix = prefix.substr(0, prefix.length() - 1);\n      if (prefix.empty()) return \"\";\n    }\n  }\n  return prefix;\n}",
      "difficulty": "Medium",
      "score": 100
    },
    {
      "id": "medium-28",
      "title": "Valid Anagram",
      "description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
      "examples": [
        { "input": "\"anagram\", \"nagaram\"", "output": "true" },
        { "input": "\"rat\", \"car\"", "output": "false" }
      ],
      "hints": ["Count character frequencies for both strings using hash maps or arrays. Or sort both strings and compare."],
      "solutionJs": "function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  const charCount = {};\n  for (const char of s) {\n    charCount[char] = (charCount[char] || 0) + 1;\n  }\n  for (const char of t) {\n    if (!charCount[char]) return false;\n    charCount[char]--;\n  }\n  return true;\n}",
      "solutionPython": "from collections import Counter\ndef is_anagram(s, t):\n  return Counter(s) == Counter(t)",
      "solutionJava": "import java.util.HashMap;\nclass Solution {\n  public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) return false;\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    for (char c : s.toCharArray()) {\n      charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n    }\n    for (char c : t.toCharArray()) {\n      if (!charCount.containsKey(c) || charCount.get(c) == 0) return false;\n      charCount.put(c, charCount.get(c) - 1);\n    }\n    return true;\n  }\n}",
      "solutionCpp": "bool isAnagram(std::string s, std::string t) {\n  if (s.length() != t.length()) return false;\n  std::unordered_map<char, int> charCount;\n  for (char c : s) {\n    charCount[c]++;\n  }\n  for (char c : t) {\n    if (charCount.count(c) == 0 || charCount[c] == 0) return false;\n    charCount[c]--;\n  }\n  return true;\n}",
      "difficulty": "Medium",
      "score": 100
    },
    {
      "id": "medium-29",
      "title": "Implement Queue using Stacks",
      "description": "Implement a first in, first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).",
      "examples": [
        { "input": "Queue q = new Queue(); q.push(1); q.push(2); q.peek(); q.pop(); q.empty();", "output": "1, 1, false" }
      ],
      "hints": ["Use one stack as the primary storage and another as a temporary buffer for `pop` and `peek` operations."],
      "solutionJs": "class MyQueue {\n  constructor() {\n    this.inStack = [];\n    this.outStack = [];\n  }\n  push(x) {\n    this.inStack.push(x);\n  }\n  _transfer() {\n    if (this.outStack.length === 0) {\n      while (this.inStack.length > 0) {\n        this.outStack.push(this.inStack.pop());\n      }\n    }\n  }\n  pop() {\n    this._transfer();\n    return this.outStack.pop();\n  }\n  peek() {\n    this._transfer();\n    return this.outStack[this.outStack.length - 1];\n  }\n  empty() {\n    return this.inStack.length === 0 && this.outStack.length === 0;\n  }\n}",
      "solutionPython": "class MyQueue:\n  def __init__(self):\n    self.in_stack = []\n    self.out_stack = []\n  def push(self, x: int) -> None:\n    self.in_stack.append(x)\n  def _transfer(self):\n    if not self.out_stack:\n      while self.in_stack:\n        self.out_stack.append(self.in_stack.pop())\n  def pop(self) -> int:\n    self._transfer()\n    return self.out_stack.pop()\n  def peek(self) -> int:\n    self._transfer()\n    return self.out_stack[-1]\n  def empty(self) -> bool:\n    return not self.in_stack and not self.out_stack",
      "solutionJava": "import java.util.Stack;\nclass MyQueue {\n  private Stack<Integer> inStack;\n  private Stack<Integer> outStack;\n  public MyQueue() {\n    inStack = new Stack<>();\n    outStack = new Stack<>();\n  }\n  public void push(int x) {\n    inStack.push(x);\n  }\n  private void transfer() {\n    if (outStack.empty()) {\n      while (!inStack.empty()) {\n        outStack.push(inStack.pop());\n      }\n    }\n  }\n  public int pop() {\n    transfer();\n    return outStack.pop();\n  }\n  public int peek() {\n    transfer();\n    return outStack.peek();\n  }\n  public boolean empty() {\n    return inStack.empty() && outStack.empty();\n  }\n}",
      "solutionCpp": "class MyQueue {\npublic:\n    std::stack<int> inStack;\n    std::stack<int> outStack;\n\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        inStack.push(x);\n    }\n    \n    void transfer() {\n        if (outStack.empty()) {\n            while (!inStack.empty()) {\n                outStack.push(inStack.top());\n                inStack.pop();\n            }\n        }\n    }\n\n    int pop() {\n        transfer();\n        int val = outStack.top();\n        outStack.pop();\n        return val;\n    }\n    \n    int peek() {\n        transfer();\n        return outStack.top();\n    }\n    \n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};",
      "difficulty": "Medium",
      "score": 100
    },
    {
      "id": "medium-30",
      "title": "Implement Stack using Queues",
      "description": "Implement a last in, first out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).",
      "examples": [
        { "input": "Stack s = new Stack(); s.push(1); s.push(2); s.top(); s.pop(); s.empty();", "output": "2, 2, false" }
      ],
      "hints": ["When pushing, add to one queue. When popping/peeking, transfer all but the last element to the other queue."],
      "solutionJs": "class MyStack {\n  constructor() {\n    this.q1 = [];\n    this.q2 = [];\n  }\n  push(x) {\n    this.q1.push(x);\n  }\n  pop() {\n    while (this.q1.length > 1) {\n      this.q2.push(this.q1.shift());\n    }\n    const popped = this.q1.shift();\n    [this.q1, this.q2] = [this.q2, this.q1]; // Swap queues\n    return popped;\n  }\n  top() {\n    while (this.q1.length > 1) {\n      this.q2.push(this.q1.shift());\n    }\n    const topVal = this.q1[0];\n    this.q2.push(this.q1.shift());\n    [this.q1, this.q2] = [this.q2, this.q1];\n    return topVal;\n  }\n  empty() {\n    return this.q1.length === 0;\n  }\n}",
      "solutionPython": "import collections\nclass MyStack:\n  def __init__(self):\n    self.q1 = collections.deque()\n    self.q2 = collections.deque()\n  def push(self, x: int) -> None:\n    self.q1.append(x)\n  def pop(self) -> int:\n    while len(self.q1) > 1:\n      self.q2.append(self.q1.popleft())\n    popped = self.q1.popleft()\n    self.q1, self.q2 = self.q2, self.q1 # Swap queues\n    return popped\n  def top(self) -> int:\n    while len(self.q1) > 1:\n      self.q2.append(self.q1.popleft())\n    top_val = self.q1[0]\n    self.q2.append(self.q1.popleft())\n    self.q1, self.q2 = self.q2, self.q1\n    return top_val\n  def empty(self) -> bool:\n    return not self.q1",
      "solutionJava": "import java.util.LinkedList;\nimport java.util.Queue;\nclass MyStack {\n  private Queue<Integer> q1;\n  private Queue<Integer> q2;\n  public MyStack() {\n    q1 = new LinkedList<>();\n    q2 = new LinkedList<>();\n  }\n  public void push(int x) {\n    q1.offer(x);\n  }\n  public int pop() {\n    while (q1.size() > 1) {\n      q2.offer(q1.poll());\n    }\n    int popped = q1.poll();\n    Queue<Integer> temp = q1;\n    q1 = q2;\n    q2 = temp;\n    return popped;\n  }\n  public int top() {\n    while (q1.size() > 1) {\n      q2.offer(q1.poll());\n    }\n    int topVal = q1.peek();\n    q2.offer(q1.poll());\n    Queue<Integer> temp = q1;\n    q1 = q2;\n    q2 = temp;\n    return topVal;\n  }\n  public boolean empty() {\n    return q1.isEmpty();\n  }\n}",
      "solutionCpp": "class MyStack {\npublic:\n    std::queue<int> q1;\n    std::queue<int> q2;\n\n    MyStack() {\n    }\n    \n    void push(int x) {\n        q1.push(x);\n    }\n    \n    int pop() {\n        while (q1.size() > 1) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        int val = q1.front();\n        q1.pop();\n        // Swap q1 and q2\n        std::queue<int> temp = q1;\n        q1 = q2;\n        q2 = temp;\n        return val;\n    }\n    \n    int top() {\n        while (q1.size() > 1) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        int val = q1.front();\n        q2.push(q1.front()); // Push back to Q2 to keep it\n        q1.pop();\n        // Swap q1 and q2\n        std::queue<int> temp = q1;\n        q1 = q2;\n        q2 = temp;\n        return val;\n    }\n    \n    bool empty() {\n        return q1.empty();\n    }\n};",
      "difficulty": "Medium",
      "score": 100
    }
  ]