[
    {
      "id": "c-home",
      "title": "C Home",
      "description": "Welcome to the C tutorial. Start your journey into C programming with foundational knowledge.",
      "content": "Welcome to the C Programming Tutorial! This comprehensive guide will take you through the fundamentals of the C language, from basic syntax to advanced concepts like pointers and file handling. C is a foundational language, influencing many modern programming languages and being crucial for systems programming, embedded systems, and game development.\n\n### What You Will Learn:\n\n* **Fundamentals:** Variables, data types, operators, and basic input/output.\n* **Control Flow:** Conditional statements (`if`, `else`, `switch`) and loops (`for`, `while`, `do-while`).\n* **Data Structures:** Arrays, strings, and an introduction to pointers.\n* **Functions:** Modularizing your code and understanding function parameters.\n* **Memory Management:** Dynamic memory allocation using `malloc`, `calloc`, `realloc`, and `free`.\n* **Advanced Topics:** Structures, unions, enums, file I/O, and more.\n\n### Why C is Important:\n\n1.  **Performance:** C offers direct memory manipulation, leading to highly optimized and fast applications.\n2.  **System Programming:** It's the language of choice for operating systems (like Linux), embedded systems, and drivers.\n3.  **Foundation for Other Languages:** Many popular languages (C++, Java, Python, JavaScript) are either built on C or borrow heavily from its syntax and concepts.\n4.  **Portability:** C programs can be compiled and run on diverse hardware platforms with minimal changes.\n5.  **Understanding Computer Architecture:** Learning C helps in grasping how computer hardware and software interact at a low level.\n\nLet's embark on this journey to master the powerful C programming language!",
      "codeExamples": []
    },
    {
      "id": "c-intro",
      "title": "C Intro",
      "description": "Learn what C is, its history, and its widespread applications.",
      "content": "C is a powerful, general-purpose programming language developed by Dennis Ritchie at Bell Labs in the early 1970s. It was primarily designed for developing system applications that directly interact with hardware, like operating systems, kernels, and embedded systems. C is known for its efficiency, low-level memory access, and as a foundational language for many other modern programming languages (like C++, Java, JavaScript, Python, PHP, Perl, and more).\n\n### Why Learn C?\n\n* **Foundation:** Understanding C provides a deep insight into how computers work and how memory is managed, which is beneficial for learning other languages and system programming.\n* **Performance:** C programs are typically very fast due to low-level memory management and direct hardware access.\n* **Portability:** C code can be compiled and run on various platforms with minimal changes.\n* **System Programming:** It's widely used for operating systems (like Linux kernel), embedded systems, device drivers, and compilers.\n* **Industry Standard:** Many fundamental software components are written in C.\n\n### Your First C Program: Hello World!\n\nThe classic 'Hello, World!' program demonstrates the basic structure of a C program.\n\n```c\n#include <stdio.h> // Include standard input-output library\n\nint main() { // Main function: where program execution begins\n    printf(\"Hello, C!\\n\"); // Output text to the console\n    return 0; // Indicate successful program execution\n}\n```\n\n* `#include <stdio.h>`: This is a preprocessor directive that includes the Standard Input-Output library. It provides functions like `printf` for displaying output and `scanf` for taking input.\n* `int main()`: The `main` function is the entry point of every C program. Execution always begins from this function.\n* `printf(\"Hello, C!\\n\");`: The `printf` function (from `stdio.h`) is used to print formatted output to the console. `\\n` is an escape sequence for a new line.\n* `return 0;`: This statement indicates that the program executed successfully. A non-zero value typically signals an error to the operating system.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\nint main() {\n    printf(\"Hello, C!\\n\");\n    return 0;\n}",
          "description": "A basic C program that prints 'Hello, C!' to the console."
        }
      ]
    },
    {
      "id": "c-get-started",
      "title": "C Get Started",
      "description": "Set up your development environment and write your first compilable C program.",
      "content": "To write and run C programs, you need a **Text Editor** (to write code) and a **Compiler** (to translate your C code into an executable program). A **Compiler** is a software that converts the C source code into machine code that the computer's CPU can understand and execute.\n\n### Setting Up Your Environment:\n\n1.  **Text Editor:** You can use any text editor you prefer, such as:\n    * **VS Code:** (Highly recommended) A powerful, free editor with extensions for C/C++.\n    * **Sublime Text:** A fast and feature-rich text editor.\n    * **Notepad++ (Windows):** A popular free text editor.\n    * **Vim/Emacs (Linux/macOS):** Command-line based editors for power users.\n\n2.  **C Compiler (GCC - GNU Compiler Collection):**\n    * GCC is the most widely used C compiler. It's available for Windows, macOS, and Linux.\n    * **Windows:** Install `MinGW` or `Cygwin`, which include GCC. A simpler option is to install VS Code and its C/C++ extension pack, which often guides you through MinGW installation.\n    * **macOS:** Install Xcode Command Line Tools by running `xcode-select --install` in your terminal. This includes Clang, which is compatible with GCC.\n    * **Linux:** GCC is usually pre-installed. If not, use your package manager (e.g., `sudo apt install build-essential` on Debian/Ubuntu).\n\n### Writing and Running Your First Program:\n\nLet's create a simple program, save it, compile it, and run it.\n\n1.  **Create a file:** Open your text editor and type the following code. Save the file as `myfirstprogram.c` (the `.c` extension is crucial).\n\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        printf(\"Hello from my first C program!\\n\");\n        return 0;\n    }\n    ```\n\n2.  **Open Terminal/Command Prompt:** Navigate to the directory where you saved `myfirstprogram.c`.\n\n    ```bash\n    # Example for Windows:\n    cd C:\\Users\\YourUser\\Desktop\\C_Programs\n\n    # Example for macOS/Linux:\n    cd ~/Documents/C_Programs\n    ```\n\n3.  **Compile the program:** Use the GCC compiler to compile your source code into an executable file.\n\n    ```bash\n    gcc myfirstprogram.c -o myfirstprogram\n    ```\n    * `gcc`: The command for the GNU C compiler.\n    * `myfirstprogram.c`: Your source code file.\n    * `-o myfirstprogram`: The `-o` flag specifies the output file name (your executable). Without it, the default executable name is `a.out` (Linux/macOS) or `a.exe` (Windows).\n\n4.  **Run the executable:** Execute the compiled program.\n\n    ```bash\n    # On Linux/macOS:\n    ./myfirstprogram\n\n    # On Windows:\n    myfirstprogram.exe\n    # Or just:\n    myfirstprogram\n    ```\n    You should see the output: `Hello from my first C program!`\n\nCongratulations! You've successfully set up your environment and run your first C program. This process of edit -> compile -> run is fundamental to C development.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\nint main() {\n    printf(\"Hello from my first C program!\\n\");\n    return 0;\n}",
          "description": "The 'Hello World' program to get started with C, intended to be saved as a `.c` file and compiled."
        }
      ]
    },
    {
      "id": "c-syntax",
      "title": "C Syntax",
      "description": "Understand the basic rules for writing C code, including statements, blocks, and case sensitivity.",
      "content": "C syntax refers to the set of rules that define how a C program is written and structured. Adhering to these rules is crucial for the compiler to understand and translate your code correctly.\n\n### Key Syntax Rules:\n\n1.  **Statements:**\n    * A C program is a collection of statements. Each statement is a single instruction that tells the computer to do something.\n    * Most statements in C **must end with a semicolon (`;`)**.\n    ```c\n    int age = 30; // Declaration and initialization statement\n    printf(\"My age is %d\\n\", age); // Function call statement\n    return 0; // Return statement\n    ```\n\n2.  **Blocks of Code:**\n    * Multiple statements can be grouped together into a **block of code** or a **compound statement**.\n    * Code blocks are enclosed within curly braces (`{ }`).\n    * Functions, loops, and conditional statements all use code blocks.\n    ```c\n    if (age > 18) {\n        printf(\"You are an adult.\\n\"); // Statement 1 within block\n        printf(\"Welcome!\\n\");       // Statement 2 within block\n    } // End of block\n    ```\n\n3.  **Case Sensitivity:**\n    * C is a **case-sensitive** language. This means `myVar`, `MyVar`, and `myvar` are treated as three distinct variables.\n    * Keywords (`int`, `if`, `for`) must be written in lowercase.\n    ```c\n    int myVariable = 10;\n    // int myvariable = 20; // This would declare a DIFFERENT variable\n    ```\n\n4.  **Whitespace:**\n    * Whitespace (spaces, tabs, newlines) is generally ignored by the C compiler, except when it separates tokens (like between a keyword and a variable name) or within string literals.\n    * Use whitespace to make your code more readable.\n    ```c\n    // Both lines are functionally identical to the compiler\n    int number=10;\n    int anotherNumber = 20 ;\n    ```\n\n5.  **`main()` Function (Recap):**\n    * Every C program must have a `main()` function, which is the entry point for execution.\n    * It typically returns an `int` value.\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        // Your code goes here\n        printf(\"C syntax rules are important.\\n\");\n        return 0;\n    }\n    ```\n\nUnderstanding these basic syntax rules is the first step to writing correct and compilable C programs.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\nint main() {\n    int a = 5; // Statement ending with semicolon\n    int b = 10;\n\n    if (a < b) { // Code block for if statement\n        printf(\"a is less than b.\\n\");\n    }\n\n    return 0;\n}",
          "description": "Demonstrates basic C syntax including statements, semicolons, and code blocks."
        }
      ]
    },
    {
      "id": "c-output",
      "title": "C Output (`printf()`)",
      "description": "Learn how to display text and variable values to the console using the `printf()` function.",
      "content": "In C, displaying output to the console is primarily done using the `printf()` function, which is part of the `<stdio.h>` standard library. `printf()` is a powerful function that allows you to print formatted text, numbers, characters, and strings.\n\n### The `printf()` Function:\n\n* **Purpose:** To print formatted output to the standard output stream (usually your terminal or command prompt).\n* **Syntax:** `printf(\"format string\", arg1, arg2, ...);`\n    * `\"format string\"`: A string literal containing text to be printed and zero or more **format specifiers**.\n    * `arg1, arg2, ...`: Optional arguments (variables or expressions) whose values are to be inserted into the output, corresponding to the format specifiers.\n\n### Common Format Specifiers:\n\n* `%d` or `%i`: For signed decimal integers.\n* `%f`: For single-precision floating-point numbers (`float`).\n* `%lf`: For double-precision floating-point numbers (`double`).\n* `%c`: For a single character.\n* `%s`: For a string (null-terminated character array).\n* `%p`: For memory addresses (pointers).\n* `%%`: To print a literal percentage sign (`%`).\n\n### Escape Sequences:\n\nSpecial character combinations used within string literals to represent non-printable characters or to control output formatting.\n\n* `\\n`: Newline character (moves cursor to the next line).\n* `\\t`: Horizontal tab.\n* `\\b`: Backspace.\n* `\\r`: Carriage return.\n* `\\\\`: Backslash character.\n* `\\\"`: Double quotation mark.\n* `\\'`: Single quotation mark.\n\n```c\n#include <stdio.h>\n\nint main() {\n    // Print a simple string\n    printf(\"Hello, C Programming!\\n\");\n\n    // Print an integer\n    int age = 25;\n    printf(\"My age is %d years old.\\n\", age);\n\n    // Print a float with formatting\n    float pi = 3.14159f;\n    printf(\"Value of Pi: %.2f\\n\", pi); // %.2f prints with 2 decimal places\n\n    // Print a character\n    char initial = 'J';\n    printf(\"My initial is %c.\\n\", initial);\n\n    // Print a string\n    char name[] = \"Alice\";\n    printf(\"My name is %s.\\n\", name);\n\n    // Combining multiple specifiers and escape sequences\n    int items = 3;\n    float cost = 9.99f;\n    printf(\"You bought %d items at $%.2f each.\\n\", items, cost);\n    printf(\"This uses a \\\"newline\\\" and a \\t tab.\\n\");\n\n    return 0;\n}\n```\n\nMastering `printf()` and its format specifiers is crucial for debugging and presenting information clearly in your C programs.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\nint main() {\n    int score = 100;\n    char grade = 'A';\n    printf(\"Your score is %d and your grade is %c.\\n\", score, grade);\n    return 0;\n}",
          "description": "Prints an integer score and a character grade to the console on a single line."
        }
      ]
    },
    {
      "id": "c-comments",
      "title": "C Comments",
      "description": "Understand how to use single-line and multi-line comments to explain your C code.",
      "content": "Comments are annotations within the source code of a program that are ignored by the compiler. Their primary purpose is to make the code more readable and understandable for humans (including yourself in the future!). Good comments are essential for code maintenance, collaboration, and learning.\n\n### Types of Comments in C:\n\nC supports two main types of comments:\n\n1.  **Single-line Comments (`//`)**:\n    * Starts with two forward slashes (`//`).\n    * Everything from `//` to the end of the line is considered a comment.\n    * Introduced in the C99 standard, but widely supported by compilers.\n\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        int x = 10; // Declare and initialize an integer variable\n        printf(\"Value of x: %d\\n\", x); // Print the value of x to the console\n        return 0; // Indicate successful program termination\n    }\n    ```\n\n2.  **Multi-line Comments (`/* ... */`)**:\n    * Starts with `/*` and ends with `*/`.\n    * Anything between these delimiters, spanning multiple lines, is treated as a comment.\n    * This style is inherited from C and is universally supported.\n\n    ```c\n    #include <stdio.h>\n\n    /*\n    This is a multi-line comment.\n    This program demonstrates the use of both single-line\n    and multi-line comments in C programming.\n    Comments improve code readability and maintainability.\n    */\n    int main() {\n        int y = 20; /* This is also a multi-line comment, but on a single line */\n        printf(\"Value of y: %d\\n\", y);\n        return 0;\n    }\n    ```\n\n### Best Practices for Comments (Theory Focus):\n\n* **Explain *Why*:** Don't just re-state what the code does (the code itself should be clear). Instead, explain *why* a particular piece of code was written, the reasoning behind a complex algorithm, or the assumptions made.\n* **Keep them Up-to-Date:** Outdated comments are worse than no comments at all, as they can be misleading.\n* **Concise and Clear:** Write comments that are to the point and easy to understand.\n* **Avoid Excessive Comments:** Too many comments can clutter the code and make it harder to read. Focus on complex logic or non-obvious parts.\n* **Use for Debugging/Temporary Disabling:** You can temporarily comment out lines or blocks of code for debugging purposes.\n\nGood commenting practices are a hallmark of professional programming and greatly benefit anyone who reads or maintains your code.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\n/*\n * This function calculates the factorial of a non-negative integer.\n * Factorial of n (n!) is the product of all positive integers less than or equal to n.\n * Example: 5! = 5 * 4 * 3 * 2 * 1 = 120\n */\nint factorial(int n) {\n    if (n == 0) {\n        return 1; // Base case: factorial of 0 is 1\n    }\n    return n * factorial(n - 1); // Recursive step\n}\n\nint main() {\n    int num = 5;\n    // Call the factorial function and print the result\n    printf(\"Factorial of %d is %d.\\n\", num, factorial(num));\n    return 0;\n}",
          "description": "A C program that calculates the factorial of a number, demonstrating the use of both single-line and multi-line comments to explain the code and function purpose."
        }
      ]
    },
    {
      "id": "c-variables",
      "title": "C Variables",
      "description": "Understand how to declare, name, and use variables to store data in C programs.",
      "content": "Variables are fundamental building blocks in any programming language. In C, a **variable** is a named storage location in the computer's memory that holds a value. Before you can use a variable, you must declare it, specifying its **data type** and a **name**.\n\n### Declaring Variables:\n\n* **Syntax:** `dataType variableName;`\n* `dataType`: Specifies the type of data the variable can store (e.g., `int`, `float`, `char`).\n* `variableName`: A unique identifier for the variable.\n\n```c\n#include <stdio.h>\n\nint main() {\n    // Declaring variables\n    int myNumber;        // Declares an integer variable\n    float myFloatNum;    // Declares a floating-point variable\n    char myLetter;       // Declares a character variable\n\n    // Assigning values to variables (initialization or later assignment)\n    myNumber = 15;\n    myFloatNum = 5.99f; // 'f' suffix for float literal\n    myLetter = 'D';\n\n    // Printing variable values\n    printf(\"My integer: %d\\n\", myNumber);\n    printf(\"My float: %.2f\\n\", myFloatNum);\n    printf(\"My character: %c\\n\", myLetter);\n\n    return 0;\n}\n```\n\n### Variable Naming Rules (Theory Focus):\n\n* **Valid Characters:** Variable names can consist of letters (A-Z, a-z), digits (0-9), and underscores (`_`).\n* **Starting Character:** Must start with a letter or an underscore. Cannot start with a digit.\n* **Keywords:** Cannot be a C keyword (e.g., `int`, `void`, `return`).\n* **Case Sensitive:** C is case-sensitive, so `age` and `Age` are different variables.\n* **Reserved Names:** Avoid names that begin with an underscore, as they are often reserved for system use.\n* **Readability:** Choose meaningful names that reflect the variable's purpose (e.g., `studentAge` instead of `sa`).\n\n### Common Naming Conventions:\n\n* **Camel Case:** `myVariableName` (first letter of first word lowercase, subsequent words start with uppercase). Often used for variables and functions.\n* **Snake Case:** `my_variable_name` (words separated by underscores). Common in C for variables and functions.\n* **Pascal Case:** `MyVariableName` (first letter of every word uppercase). Often used for structures and types.\n\n### Declaring Multiple Variables:\n\nYou can declare multiple variables of the same type on one line, separated by commas.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 5, y = 10, z = 15; // Declare and initialize three int variables\n    printf(\"Sum: %d\\n\", x + y + z);\n\n    char c1 = 'A', c2 = 'B'; // Declare two char variables\n    printf(\"Chars: %c %c\\n\", c1, c2);\n\n    return 0;\n}\n```\n\nVariables are essential for storing and manipulating data within your C programs.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\nint main() {\n    int itemPrice = 25;\n    int quantity = 2;\n    int totalCost = itemPrice * quantity;\n    printf(\"Total cost: $%d\\n\", totalCost);\n    return 0;\n}",
          "description": "Calculates the total cost of items using integer variables and prints the result."
        }
      ]
    },
    {
      "id": "c-data-types",
      "title": "C Data Types",
      "description": "Explore the fundamental built-in data types in C and their memory usage.",
      "content": "A **data type** in C specifies the type of value a variable can store and the amount of memory it occupies. Choosing the correct data type is crucial for efficient memory usage and correct program behavior.\n\n### 1. Basic (Built-in) Data Types (Recap & Details):\n\n| Data Type | Description                              | Typical Memory Size (bytes) | Range Example                                   |\n| :-------- | :--------------------------------------- | :-------------------------- | :---------------------------------------------- |\n| `int`     | Integer (whole number)                   | 2 or 4                      | -32,768 to 32,767 (2-byte) / -2x10^9 to 2x10^9 (4-byte) |\n| `float`   | Single-precision floating-point number   | 4                           | 1.2E-38 to 3.4E+38                              |\n| `double`  | Double-precision floating-point number   | 8                           | 2.3E-308 to 1.7E+308                            |\n| `char`    | Single character                         | 1                           | -128 to 127 (signed) or 0 to 255 (unsigned)     |\n| `void`    | Absence of type (used for generic pointers or function return types) | N/A                         | N/A                                             |\n\n* **`sizeof` Operator:** You can use the `sizeof` operator to find the exact memory size (in bytes) occupied by a data type or a variable on your specific system.\n\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"Size of int: %zu bytes\\n\", sizeof(int));\n    printf(\"Size of float: %zu bytes\\n\", sizeof(float));\n    printf(\"Size of double: %zu bytes\\n\", sizeof(double));\n    printf(\"Size of char: %zu bytes\\n\", sizeof(char));\n\n    int myNum = 10;\n    printf(\"Size of myNum variable: %zu bytes\\n\", sizeof(myNum));\n\n    return 0;\n}\n```\n\n### 2. Derived Data Types (Theory Focus):\n\nThese are data types derived from basic types and allow for more complex data organization.\n\n* **Arrays:** Collections of elements of the same data type (e.g., `int arr[5];`).\n* **Pointers:** Variables that store memory addresses (e.g., `int *ptr;`).\n* **Structures (`struct`):** Collections of different data types under a single name.\n* **Unions (`union`):** Similar to structures, but members share the same memory location.\n* **Functions:** Though not a data type in the strict sense, functions are fundamental entities.\n\n### 3. Enumeration Data Type (`enum`) (Theory Focus):\n\n* Used to assign names to integer constants, making the code more readable and maintainable. By default, the first enumerator has a value of 0, and subsequent enumerators increase by 1.\n\n```c\n#include <stdio.h>\n\nenum Day { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday };\n\nint main() {\n    enum Day today = Wednesday;\n    printf(\"Today is day number: %d\\n\", today); // Output: Today is day number: 3\n\n    if (today == Wednesday) {\n        printf(\"It's hump day!\\n\");\n    }\n\n    // You can explicitly assign values\n    enum Status { Success = 1, Failure = 0, Pending = 2 };\n    enum Status currentStatus = Success;\n    printf(\"Current status code: %d\\n\", currentStatus); // Output: Current status code: 1\n\n    return 0;\n}\n```\n\nUnderstanding data types is foundational for proper variable declaration, memory management, and working with complex data structures in C.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\nint main() {\n    // Declare and initialize variables of different types\n    int studentAge = 20;\n    float averageGrade = 3.85f;\n    char studentInitial = 'M';\n\n    // Print values and their sizes\n    printf(\"Student Age: %d (Size: %zu bytes)\\n\", studentAge, sizeof(studentAge));\n    printf(\"Average Grade: %.2f (Size: %zu bytes)\\n\", averageGrade, sizeof(averageGrade));\n    printf(\"Student Initial: %c (Size: %zu bytes)\\n\", studentInitial, sizeof(studentInitial));\n\n    return 0;\n}",
          "description": "Demonstrates `int`, `float`, and `char` data types, printing their values and memory sizes using `sizeof`."
        }
      ]
    },
    {
      "id": "c-constants",
      "title": "C Constants",
      "description": "Define fixed values that cannot be changed during program execution using `const` and `#define`.",
      "content": "In C, a **constant** is a value that cannot be altered by the program during its execution. Constants are useful for defining fixed values that appear multiple times in a program (e.g., mathematical constants, array sizes, configuration values), improving readability and making code easier to maintain.\n\nC provides two main ways to define constants:\n\n### 1. Using the `const` Keyword (Preferred for Typed Constants):\n\n* The `const` keyword makes a variable 'read-only'. Once initialized, its value cannot be changed.\n* `const` variables are type-safe and follow scope rules like regular variables.\n\n```c\n#include <stdio.h>\n\nint main() {\n    const float PI = 3.14159f; // Declare a float constant\n    const int MAX_USERS = 100; // Declare an integer constant\n    const char NEWLINE = '\\n'; // Declare a character constant\n\n    printf(\"Value of PI: %.5f%c\", PI, NEWLINE);\n    printf(\"Maximum number of users: %d%c\", MAX_USERS, NEWLINE);\n\n    // PI = 3.14; // ERROR: assignment of read-only variable 'PI'\n\n    return 0;\n}\n```\n\n* **Initialization:** `const` variables must be initialized at the time of declaration.\n* **Scope:** `const` variables respect block scope (local `const` variables are only visible within their block).\n\n### 2. Using the `#define` Preprocessor Directive (Macro Constants):\n\n* `#define` is a preprocessor directive, not a statement. It performs simple text substitution before compilation.\n* When the preprocessor encounters a defined macro, it replaces all occurrences of the macro name with its defined value throughout the code.\n* Macros are typically written in uppercase by convention.\n\n```c\n#include <stdio.h>\n\n#define PI_MACRO 3.14159\n#define GREETING \"Hello from a macro!\"\n#define ARRAY_SIZE 5\n\nint main() {\n    printf(\"PI from macro: %.5f\\n\", PI_MACRO);\n    printf(\"%s\\n\", GREETING);\n\n    int arr[ARRAY_SIZE]; // ARRAY_SIZE is replaced by 5 before compilation\n    printf(\"Array size defined by macro: %d\\n\", ARRAY_SIZE);\n\n    // PI_MACRO = 3.0; // ERROR: This would be a syntax error because it tries to assign to a literal\n                     // The preprocessor replaces PI_MACRO with 3.14159, so it becomes 3.14159 = 3.0;\n\n    return 0;\n}\n```\n\n### `const` vs. `#define` (Theory Focus):\n\n| Feature           | `const`                               | `#define` (Macro)                                 |\n| :---------------- | :------------------------------------ | :------------------------------------------------ |\n| **Type Safety** | Type-safe (compiler checks type)      | Not type-safe (simple text substitution)          |\n| **Scope** | Respects block scope                  | Global scope (from `#define` to end of file, or until `#undef`) |\n| **Memory** | Allocated memory (like a variable)    | No memory allocated (text substitution)           |\n| **Debugging** | Debuggers can see `const` variables   | Debuggers typically cannot see macros             |\n| **Flexibility** | Can be used with pointers, arrays     | Limited to text substitution                       |\n\n**Recommendation:** For defining constants with a specific data type, using `const` is generally preferred over `#define` due to type safety and better debugging support. `#define` is still useful for simple symbolic constants, conditional compilation, and complex macros.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\n#define MAX_ATTEMPTS 3\nconst int DEFAULT_VALUE = 100;\n\nint main() {\n    printf(\"Maximum login attempts: %d\\n\", MAX_ATTEMPTS);\n    printf(\"Default system value: %d\\n\", DEFAULT_VALUE);\n    \n    // MAX_ATTEMPTS = 5; // Will cause compile-time error after macro substitution\n    // DEFAULT_VALUE = 200; // Will cause compile-time error\n    \n    return 0;\n}",
          "description": "Demonstrates defining constants using both `#define` (preprocessor macro) and the `const` keyword in C."
        }
      ]
    },
    {
      "id": "c-operators",
      "title": "C Operators",
      "description": "Learn about arithmetic, relational, logical, bitwise, and assignment operators in C.",
      "content": "Operators are symbols that perform specific operations on one or more operands (variables or values). C provides a rich set of operators for various purposes, allowing you to perform calculations, comparisons, logical operations, and manipulate data at the bit level.\n\n### Types of Operators:\n\n1.  **Arithmetic Operators:** Perform mathematical calculations.\n    * `+` (addition)\n    * `-` (subtraction)\n    * `*` (multiplication)\n    * `/` (division)\n    * `%` (modulus - remainder of division)\n    * `++` (increment): Increments operand by 1.\n    * `--` (decrement): Decrements operand by 1.\n\n    ```c\n    int a = 10, b = 3;\n    printf(\"a + b = %d\\n\", a + b); // 13\n    printf(\"a / b = %d\\n\", a / b); // 3 (integer division, result is truncated)\n    printf(\"a %% b = %d\\n\", a % b); // 1 (use %% to print a literal % sign in printf)\n    \n    a++; // Post-increment: a is used then incremented. a becomes 11\n    ++b; // Pre-increment: b is incremented then used. b becomes 4\n    printf(\"a (after ++): %d, b (after ++): %d\\n\", a, b);\n    ```\n\n2.  **Relational Operators:** Compare two operands and return `true` (1) or `false` (0).\n    * `==` (equal to)\n    * `!=` (not equal to)\n    * `>` (greater than)\n    * `<` (less than)\n    * `>=` (greater than or equal to)\n    * `<=` (less than or equal to)\n\n    ```c\n    int x = 10, y = 20;\n    printf(\"x == y : %d\\n\", x == y); // 0 (false)\n    printf(\"x < y : %d\\n\", x < y);   // 1 (true)\n    ```\n\n3.  **Logical Operators:** Combine or negate boolean expressions.\n    * `&&` (logical AND): Returns true if both operands are non-zero.\n    * `||` (logical OR): Returns true if at least one operand is non-zero.\n    * `!` (logical NOT): Returns true if the operand is zero.\n\n    ```c\n    int is_sunny = 1; // In C, any non-zero value is true, 0 is false\n    int is_warm = 0;\n    printf(\"Is it sunny AND warm? %d\\n\", is_sunny && is_warm); // 0 (false)\n    printf(\"Is it NOT warm? %d\\n\", !is_warm); // 1 (true)\n    ```\n\n4.  **Bitwise Operators:** Perform operations on individual bits of integer data types.\n    * `&` (bitwise AND)\n    * `|` (bitwise OR)\n    * `^` (bitwise XOR)\n    * `~` (bitwise NOT - one's complement)\n    * `<<` (left shift)\n    * `>>` (right shift)\n\n    ```c\n    unsigned int A = 60; // Binary: 0011 1100\n    unsigned int B = 13; // Binary: 0000 1101\n    printf(\"A & B = %d\\n\", A & B); // 12 (Binary: 0000 1100)\n    printf(\"A | B = %d\\n\", A | B); // 61 (Binary: 0011 1101)\n    printf(\"A << 2 = %d\\n\", A << 2); // 240 (Binary: 1111 0000)\n    ```\n\n5.  **Assignment Operators:** Assign values to variables. Shorthand for arithmetic operations followed by assignment.\n    * `=` (assign)\n    * `+=` (add and assign) e.g., `x += 5;` is `x = x + 5;`\n    * `-=` (subtract and assign)\n    * `*=` (multiply and assign)\n    * `/=` (divide and assign)\n    * `%=` (modulus and assign)\n\n    ```c\n    int total = 100;\n    total += 50; // total is now 150\n    printf(\"Total after +=: %d\\n\", total);\n    total /= 3; // total is now 50 (150 / 3)\n    printf(\"Total after /=: %d\\n\", total);\n    ```\n\n6.  **Ternary (Conditional) Operator:** `condition ? expression_if_true : expression_if_false;`\n    * A shorthand for simple `if-else` statements.\n\n    ```c\n    int age = 20;\n    char* status = (age >= 18) ? \"Adult\" : \"Minor\";\n    printf(\"Status: %s\\n\", status);\n    ```\n\n### Operator Precedence and Associativity (Theory Focus):\n\n* **Precedence:** Determines the order in which operators are evaluated in an expression (e.g., multiplication and division have higher precedence than addition and subtraction).\n* **Associativity:** Determines the order when operators have the same precedence (e.g., most arithmetic operators are left-to-right associative).\n\nUse parentheses `()` to explicitly control the order of operations and improve readability, regardless of precedence rules.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\nint main() {\n    int num = 7;\n    int result = num * 2 + 5; // Multiplication before addition\n    printf(\"Result: %d\\n\", result); // Expected: 19\n\n    int is_valid = (result > 15) && (num < 10); // Logical AND\n    printf(\"Is valid: %d\\n\", is_valid); // Expected: 1 (true)\n\n    num %= 3; // num = 7 % 3 = 1\n    printf(\"Num after modulo assignment: %d\\n\", num); // Expected: 1\n\n    return 0;\n}",
          "description": "Demonstrates operator precedence, logical operators, and assignment operators with example calculations."
        }
      ]
    },
    {
      "id": "c-booleans",
      "title": "C Booleans",
      "description": "Understand how boolean values (true/false) are represented and used in C.",
      "content": "Unlike some modern languages that have a dedicated `boolean` type, C (prior to C99) did not have a built-in `bool` type. Instead, boolean values are represented using **integers**:\n\n* **`0` (zero) represents `false`**.\n* **Any non-zero integer represents `true`** (commonly `1`).\n\n### Using Integers for Booleans:\n\nThis convention is fundamental in C. Conditional statements (`if`, `while`, `for`) evaluate their conditions as true if the result is non-zero, and false if the result is zero.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int is_logged_in = 1; // Represents true\n    int has_permissions = 0; // Represents false\n    int user_age = 25;\n\n    if (is_logged_in) { // Equivalent to: if (is_logged_in != 0)\n        printf(\"User is logged in.\\n\");\n    }\n\n    if (has_permissions) {\n        printf(\"User has permissions. (This won't print)\\n\");\n    } else {\n        printf(\"User does not have permissions.\\n\");\n    }\n\n    // Using relational operators, which return 0 or 1\n    int is_adult = (user_age >= 18); // is_adult will be 1 (true)\n    printf(\"Is user an adult? %d\\n\", is_adult);\n\n    return 0;\n}\n```\n\n### The `_Bool` Type (C99 and later):\n\nStarting with the C99 standard, C introduced the `_Bool` keyword and the `<stdbool.h>` header file, which defines macros `bool`, `true`, and `false`.\n\n* `bool`: An alias for `_Bool`.\n* `true`: A macro for `1`.\n* `false`: A macro for `0`.\n\nUsing `<stdbool.h>` makes your code more readable and explicit about boolean intent.\n\n```c\n#include <stdio.h>\n#include <stdbool.h> // Include this header for 'bool', 'true', 'false' macros\n\nint main() {\n    bool game_over = false; // Declares a boolean variable initialized to false\n    bool player_alive = true; // Declares a boolean variable initialized to true\n\n    printf(\"Game over: %d\\n\", game_over);   // Output: 0\n    printf(\"Player alive: %d\\n\", player_alive); // Output: 1\n\n    if (player_alive) {\n        printf(\"Player is still playing!\\n\");\n    }\n\n    game_over = true; // Assigning true\n\n    if (game_over) {\n        printf(\"Game has ended.\\n\");\n    }\n\n    return 0;\n}\n```\n\nEven with `stdbool.h`, remember that internally, `true` is `1` and `false` is `0`. This is important for understanding how boolean expressions are evaluated in C.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n#include <stdbool.h>\n\nbool isEven(int number) {\n    return (number % 2 == 0);\n}\n\nint main() {\n    int testNum1 = 4;\n    int testNum2 = 7;\n\n    printf(\"%d is even? %d\\n\", testNum1, isEven(testNum1)); // Output: 4 is even? 1\n    printf(\"%d is even? %d\\n\", testNum2, isEven(testNum2)); // Output: 7 is even? 0\n\n    return 0;\n}",
          "description": "A function `isEven` that returns a boolean (`true`/`false`) indicating if a number is even, demonstrating boolean usage."
        }
      ]
    },
    {
      "id": "c-if-else",
      "title": "C If...Else",
      "description": "Control program flow by executing code blocks based on specified conditions using `if`, `else if`, and `else` statements.",
      "content": "Conditional statements are essential for creating dynamic programs that can react differently based on various situations or user input. The `if`, `else if`, and `else` statements allow your C program to execute specific blocks of code only when certain conditions are met.\n\n### 1. The `if` Statement:\n\nThe `if` statement is the most basic conditional. It executes a block of code only if a specified condition is true (non-zero).\n\n* **Syntax:**\n    ```c\n    if (condition) {\n        // Code to be executed if condition is true\n    }\n    ```\n\n```c\n#include <stdio.h>\n\nint main() {\n    int temperature = 28;\n    if (temperature > 25) {\n        printf(\"It's a hot day!\\n\");\n    }\n    return 0;\n}\n```\n\n### 2. The `else` Statement:\n\nThe `else` statement provides an alternative block of code to execute if the `if` condition is false.\n\n* **Syntax:**\n    ```c\n    if (condition) {\n        // Code if condition is true\n    } else {\n        // Code if condition is false\n    }\n    ```\n\n```c\n#include <stdio.h>\n\nint main() {\n    int hour = 14;\n    if (hour < 12) {\n        printf(\"Good morning.\\n\");\n    } else {\n        printf(\"Good afternoon.\\n\");\n    }\n    return 0;\n}\n```\n\n### 3. The `else if` Statement (The `if-else if-else` Ladder):\n\nUsed when you have multiple, mutually exclusive conditions to check. The conditions are evaluated from top to bottom. The first `if` or `else if` condition that evaluates to true will have its corresponding block executed, and the rest of the ladder will be skipped.\n\n* **Syntax:**\n    ```c\n    if (condition1) {\n        // Code if condition1 is true\n    } else if (condition2) {\n        // Code if condition1 is false AND condition2 is true\n    } else if (condition3) {\n        // Code if condition1 and condition2 are false AND condition3 is true\n    } else {\n        // Code if all conditions above are false\n    }\n    ```\n\n```c\n#include <stdio.h>\n\nint main() {\n    int score = 75;\n\n    if (score >= 90) {\n        printf(\"Grade: A\\n\");\n    } else if (score >= 80) {\n        printf(\"Grade: B\\n\");\n    } else if (score >= 70) {\n        printf(\"Grade: C\\n\");\n    } else if (score >= 60) {\n        printf(\"Grade: D\\n\");\n    } else {\n        printf(\"Grade: F\\n\");\n    }\n    return 0;\n}\n```\n\n### Short Hand `if-else` (Ternary Operator):\n\nFor very simple `if-else` conditions, you can use the ternary operator (`? :`).\n\n* **Syntax:** `variable = (condition) ? expression_if_true : expression_if_false;`\n\n```c\n#include <stdio.h>\n\nint main() {\n    int time = 20;\n    char* greeting = (time < 18) ? \"Good day.\" : \"Good evening.\";\n    printf(\"%s\\n\", greeting);\n    return 0;\n}\n```\n\nConditional statements are fundamental for controlling the flow of logic in your C programs, allowing them to respond intelligently to different inputs and states.",
      "codeExamples": [
        {
          "lang": "c",
          "code": "#include <stdio.h>\n\nint main() {\n    int userAge = 16;\n    if (userAge >= 18) {\n        printf(\"You are eligible to vote.\\n\");\n    } else {\n        printf(\"You are not yet eligible to vote.\\n\");\n    }\n    return 0;\n}",
          "description": "Checks user's age for voting eligibility using an `if-else` statement."
        }
      ]
    },
    {
        "id": "c-switch",
        "title": "C Switch",
        "description": "Implement multi-way branching efficiently using the `switch` statement.",
        "content": "The `switch` statement is an alternative to a long `if-else if-else` ladder when you need to perform different actions based on the value of a single variable or expression. It allows for more readable and often more efficient code when dealing with many discrete choices.\n\n### How the `switch` Statement Works:\n\n* The `switch` expression (an integer, character, or enumeration type) is evaluated once.\n* Its value is then compared with the values of each `case` label.\n* If a match is found, the code block associated with that `case` is executed.\n* The `break` keyword is crucial: it terminates the `switch` statement and prevents 'fall-through' to subsequent `case` blocks.\n* The `default` case is optional and executes if none of the `case` labels match the expression's value.\n\n```c\n#include <stdio.h>\n\nint main() {\n    char grade = 'B';\n\n    switch (grade) {\n        case 'A':\n            printf(\"Excellent!\\n\");\n            break; // Exit the switch statement\n        case 'B':\n            printf(\"Very good!\\n\");\n            break;\n        case 'C':\n            printf(\"Good.\\n\");\n            break;\n        case 'D':\n            printf(\"Pass.\\n\");\n            break;\n        case 'F':\n            printf(\"Fail.\\n\");\n            break;\n        default: // Executed if no other case matches\n            printf(\"Invalid grade.\\n\");\n            break;\n    }\n\n    // Example with integer input\n    int day = 3;\n    switch (day) {\n        case 1:\n            printf(\"Monday\\n\");\n            break;\n        case 2:\n            printf(\"Tuesday\\n\");\n            break;\n        case 3:\n            printf(\"Wednesday\\n\");\n            break;\n        default:\n            printf(\"Another day\\n\");\n            break;\n    }\n\n    return 0;\n}\n```\n\n### Fall-through (Without `break`):\n\nIf you omit a `break` statement, execution will 'fall through' to the next `case` block. This can be used intentionally (e.g., for multiple cases performing the same action) but is often a source of bugs if done accidentally.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int season = 2; // 1: Spring, 2: Summer, 3: Autumn, 4: Winter\n\n    switch (season) {\n        case 1:\n        case 2: // Fall-through: if season is 1 or 2, executes the next printf\n            printf(\"It's warm season.\\n\");\n            break;\n        case 3:\n        case 4: // Fall-through\n            printf(\"It's cold season.\\n\");\n            break;\n        default:\n            printf(\"Unknown season.\\n\");\n            break;\n    }\n    return 0;\n}\n```\n\nThe `switch` statement is a cleaner and more structured way to handle specific, distinct conditions compared to a series of `if-else if` statements.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    int choice = 2;\n    switch (choice) {\n        case 1:\n            printf(\"Option 1 selected.\\n\");\n            break;\n        case 2:\n            printf(\"Option 2 selected.\\n\");\n            // No break here, intentional fall-through for demonstration\n        case 3:\n            printf(\"Option 3 also executed due to fall-through.\\n\");\n            break;\n        default:\n            printf(\"Invalid choice.\\n\");\n            break;\n    }\n    return 0;\n}",
            "description": "An example of a `switch` statement demonstrating fall-through behavior when `break` is omitted."
          }
        ]
      },
      {
        "id": "c-while-loop",
        "title": "C While Loop",
        "description": "Execute code repeatedly as long as a condition is true, checking before each iteration.",
        "content": "The `while` loop is a fundamental control flow statement in C that allows a block of code to be executed repeatedly as long as a specified condition remains true. It's an entry-controlled loop, meaning the condition is evaluated **before** each iteration of the loop body. If the condition is false initially, the loop body will never execute.\n\n### The `while` Loop Syntax:\n\n```c\nwhile (condition) {\n    // Code to be executed repeatedly\n    // (Ensure condition eventually becomes false to avoid infinite loop)\n}\n```\n\n* **`condition`**: An expression that evaluates to a non-zero value (true) or zero (false). The loop continues as long as this condition is true.\n\n### How it Works:\n\n1.  The `condition` is evaluated.\n2.  If `condition` is true:\n    * The code inside the loop body is executed.\n    * Control returns to step 1.\n3.  If `condition` is false:\n    * The loop terminates.\n    * Execution continues with the statement immediately following the `while` loop.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int count = 0; // Initialization\n\n    printf(\"Counting up with a while loop:\\n\");\n    while (count < 5) { // Condition: loop as long as count is less than 5\n        printf(\"Current count: %d\\n\", count);\n        count++; // Increment: update the control variable\n    }\n\n    printf(\"Loop finished. Final count: %d\\n\", count);\n\n    // Example: Loop that does not run (condition initially false)\n    int x = 10;\n    while (x < 5) {\n        printf(\"This line will never be printed.\\n\");\n        x++;\n    }\n    printf(\"\\nThis message always prints, even if the loop doesn't run.\\n\");\n\n    return 0;\n}\n```\n\n### Important Considerations:\n\n* **Avoiding Infinite Loops:** It is crucial to ensure that the `condition` inside a `while` loop eventually becomes false. If not, the loop will run indefinitely, leading to an **infinite loop**, which can crash your program or make it unresponsive.\n* **Loop Control Variable:** Usually, a variable involved in the condition is modified inside the loop body to change the condition's outcome.\n\n`while` loops are particularly useful when you need to repeat an action an unknown number of times, such as reading user input until a specific value is entered, or processing data from a file until the end of the file is reached.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    int sum = 0;\n    int i = 1;\n    while (i <= 5) {\n        sum += i;\n        i++;\n    }\n    printf(\"Sum of numbers 1 to 5: %d\\n\", sum);\n    return 0;\n}",
            "description": "Calculates the sum of numbers from 1 to 5 using a `while` loop."
          }
        ]
      },
      {
        "id": "c-for-loop",
        "title": "C For Loop",
        "description": "Iterate a specific number of times using the `for` loop, ideal for fixed iterations.",
        "content": "The `for` loop is a control flow statement used for executing a block of code repeatedly. It is particularly well-suited when you know in advance how many times you want the loop to run, or when iterating over a collection of items (like arrays).\n\n### The `for` Loop Syntax:\n\n```c\nfor (initialization; condition; increment/decrement) {\n    // Code to be executed repeatedly\n}\n```\n\n* **`initialization`**: This statement is executed **once** at the very beginning of the loop. It's typically used to declare and initialize a loop control variable.\n* **`condition`**: This expression is evaluated **before each iteration**. If it's true (non-zero), the loop body executes. If it's false (zero), the loop terminates.\n* **`increment/decrement`**: This statement is executed **after each iteration** of the loop body. It typically updates the loop control variable, moving it closer to making the condition false.\n\n### How it Works:\n\n1.  **Initialization** occurs.\n2.  The **Condition** is evaluated.\n3.  If the condition is true:\n    * The loop's code block is executed.\n    * The **Increment/Decrement** statement is executed.\n    * Control returns to step 2 (Condition evaluation).\n4.  If the condition is false, the loop terminates.\n\n```c\n#include <stdio.h>\n\nint main() {\n    // Example 1: Count from 1 to 5\n    printf(\"Counting up with a for loop:\\n\");\n    for (int i = 1; i <= 5; i++) { // i is initialized, checked, then incremented\n        printf(\"Number: %d\\n\", i);\n    }\n\n    // Example 2: Count down from 3\n    printf(\"\\nCountdown:\\n\");\n    for (int j = 3; j > 0; j--) {\n        printf(\"%d...\\n\", j);\n    }\n    printf(\"Blast off!\\n\");\n\n    // Example 3: Loop through an array\n    int numbers[] = {10, 20, 30, 40, 50};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    printf(\"\\nArray elements:\\n\");\n    for (int k = 0; k < size; k++) {\n        printf(\"numbers[%d] = %d\\n\", k, numbers[k]);\n    }\n\n    return 0;\n}\n```\n\n### Optional Parts:\n\nAll three parts of the `for` loop header are optional, but the semicolons must remain. If the condition is omitted, it defaults to true, creating an infinite loop (which would require a `break` statement to exit).\n\n```c\n#include <stdio.h>\n\nint main() {\n    int counter = 0;\n    // Infinite loop that breaks after 3 iterations\n    for ( ; ; ) { // No initialization, no condition, no increment\n        printf(\"Infinite loop iteration (will stop at 3): %d\\n\", counter);\n        counter++;\n        if (counter == 3) {\n            break; // Exit the loop\n        }\n    }\n    printf(\"\\nLoop with empty parts exited.\\n\");\n    return 0;\n}\n```\n\nThe `for` loop provides a concise and structured way to handle iterations, making it one of the most frequently used loop types in C.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    int factorial = 1;\n    int num = 5;\n    for (int i = 1; i <= num; i++) {\n        factorial *= i; // factorial = factorial * i\n    }\n    printf(\"Factorial of %d is %d\\n\", num, factorial);\n    return 0;\n}",
            "description": "Calculates the factorial of a number using a `for` loop."
          }
        ]
      },
      {
        "id": "c-break-continue",
        "title": "C Break/Continue",
        "description": "Learn to alter loop execution flow using `break` to exit and `continue` to skip iterations.",
        "content": "The `break` and `continue` statements are powerful keywords in C that allow you to alter the normal flow of loops (`for`, `while`, `do-while`). They provide precise control over when a loop should terminate prematurely or when a specific iteration should be skipped.\n\n### 1. The `break` Statement:\n\n* **Purpose:** The `break` statement is used to terminate the innermost loop immediately. When `break` is encountered, the loop is exited, and program execution continues with the statement immediately following the loop.\n* **Common Use Cases:** Exiting a loop early when a specific condition is met, such as finding a target element or encountering an error.\n\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"Break Statement Example:\\n\");\n    for (int i = 1; i <= 10; i++) {\n        if (i == 6) {\n            printf(\"Breaking loop at i = %d\\n\", i);\n            break; // Exit the loop when i becomes 6\n        }\n        printf(\"Current number: %d\\n\", i);\n    }\n    printf(\"Loop terminated. Code after loop continues.\\n\");\n\n    return 0;\n}\n```\n\n### 2. The `continue` Statement:\n\n* **Purpose:** The `continue` statement is used to skip the rest of the current iteration of the innermost loop and proceed to the next iteration. It effectively jumps to the loop's update expression (for `for` loops) or condition check (for `while`/`do-while` loops).\n* **Common Use Cases:** Skipping processing for specific values or conditions within a loop, while still wanting to continue with subsequent iterations.\n\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"\\nContinue Statement Example (Skipping even numbers):\\n\");\n    for (int i = 1; i <= 5; i++) {\n        if (i % 2 == 0) { // If i is even\n            printf(\"Skipping even number: %d\\n\", i);\n            continue; // Skip the rest of this iteration and go to the next\n        }\n        printf(\"Processing odd number: %d\\n\", i);\n    }\n    printf(\"Loop completed.\\n\");\n\n    return 0;\n}\n```\n\n### Important Notes:\n\n* **Innermost Loop Only:** Both `break` and `continue` only affect the innermost loop in which they are embedded. If you have nested loops, they will only break out of or continue the immediate containing loop.\n* **`switch` Statement:** `break` is also used within `switch` statements to prevent 'fall-through' to subsequent `case` labels.\n\nUsing `break` and `continue` judiciously can make your loop logic more efficient and concise, but overuse can sometimes make code harder to read and debug. Prefer clear loop conditions when possible.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    // Example 1: Find the first prime number greater than 10\n    printf(\"Finding first prime > 10:\\n\");\n    for (int num = 11; ; num++) { // Infinite loop until break\n        int is_prime = 1; // Assume prime\n        for (int i = 2; i <= num / 2; i++) {\n            if (num % i == 0) {\n                is_prime = 0; // Not prime\n                break; // Exit inner loop, no need to check further divisors\n            }\n        }\n        if (is_prime) {\n            printf(\"First prime number greater than 10 is: %d\\n\", num);\n            break; // Exit outer loop\n        }\n    }\n\n    // Example 2: Sum numbers, but skip multiples of 3\n    printf(\"\\nSumming numbers (skipping multiples of 3):\\n\");\n    int sum = 0;\n    for (int i = 1; i <= 10; i++) {\n        if (i % 3 == 0) {\n            continue; // Skip adding multiples of 3\n        }\n        sum += i;\n    }\n    printf(\"Sum: %d\\n\", sum); // Expected: (1+2+4+5+7+8+10) = 37\n\n    return 0;\n}",
            "description": "Demonstrates `break` for exiting an outer loop early when a condition is met, and `continue` for skipping iterations where a number is a multiple of 3."
          }
        ]
      },
      {
        "id": "c-arrays",
        "title": "C Arrays",
        "description": "Store fixed-size collections of data of the same type using arrays in C.",
        "content": "An **array** in C is a collection of data items of the same data type, stored at contiguous memory locations. It's one of the simplest and most fundamental data structures. Arrays are useful for storing a fixed number of elements of the same type.\n\n### Array Declaration and Initialization:\n\nArrays can be declared with a specified size, or initialized directly, in which case the compiler deduces the size.\n\n```c\n#include <stdio.h>\n\nint main() {\n    // 1. Declaration with fixed size (elements initialized to garbage values or zeros if global/static)\n    int numbers[5]; // Declares an integer array that can hold 5 elements\n\n    // 2. Initialization after declaration by accessing elements\n    numbers[0] = 10; // First element (index 0)\n    numbers[1] = 20;\n    numbers[2] = 30;\n    numbers[3] = 40;\n    numbers[4] = 50; // Last element (index 4)\n\n    // 3. Declaration and initialization at once (compiler determines size)\n    double scores[] = { 90.5, 88.0, 92.3, 78.9 }; \n\n    // 4. Accessing elements (arrays are 0-indexed)\n    printf(\"First number: %d\\n\", numbers[0]); // Output: 10\n    printf(\"Third score: %.1lf\\n\", scores[2]);   // Output: 92.3\n\n    // 5. Modifying an element\n    numbers[2] = 35;\n    printf(\"Modified numbers[2]: %d\\n\", numbers[2]); // Output: 35\n\n    // 6. Getting array length (using sizeof) - works for arrays in the same scope\n    // size_t is an unsigned integer type returned by sizeof\n    size_t numbers_length = sizeof(numbers) / sizeof(numbers[0]);\n    size_t scores_length = sizeof(scores) / sizeof(scores[0]);\n    printf(\"Length of numbers array: %zu\\n\", numbers_length); // Output: 5\n    printf(\"Length of scores array: %zu\\n\", scores_length); // Output: 4\n\n    // 7. Iterating through an array using a for loop\n    printf(\"\\nElements of numbers array:\\n\");\n    for (int i = 0; i < numbers_length; i++) {\n        printf(\"numbers[%d] = %d\\n\", i, numbers[i]);\n    }\n\n    return 0;\n}\n```\n\n* **Zero-indexed:** Array elements are always accessed starting from index `0`.\n* **Fixed Size:** Once an array is created, its size is fixed at compile time. You cannot resize it during runtime. For dynamic collections, you would use dynamic memory allocation (pointers) or more advanced data structures (like linked lists).\n* **`sizeof` Operator:** The `sizeof` operator can be used to calculate the size of an array in bytes. Dividing it by the size of a single element gives the number of elements.\n\n### Multi-dimensional Arrays (e.g., 2D Arrays/Matrices):\n\nArrays can have more than one dimension. A two-dimensional array is often used to represent a table or a matrix.\n\n```c\n#include <stdio.h>\n\nint main() {\n    // Declare and initialize a 2D array (2 rows, 3 columns)\n    int matrix[2][3] = {\n        {1, 2, 3}, // Row 0\n        {4, 5, 6}  // Row 1\n    };\n\n    // Accessing elements in a 2D array\n    printf(\"Element at matrix[0][1]: %d\\n\", matrix[0][1]); // Output: 2\n\n    // Iterating through a 2D array using nested loops\n    printf(\"\\nMatrix elements:\\n\");\n    for (int i = 0; i < 2; i++) { // Loop through rows\n        for (int j = 0; j < 3; j++) { // Loop through columns\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\"); // Newline after each row\n    }\n\n    return 0;\n}\n```\n\nArrays are a fundamental data structure for storing ordered collections of similar data.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    int ages[3] = {25, 30, 22};\n    printf(\"Ages: %d, %d, %d\\n\", ages[0], ages[1], ages[2]);\n\n    // Change an element\n    ages[1] = 31;\n    printf(\"Updated second age: %d\\n\", ages[1]);\n\n    return 0;\n}",
            "description": "Declares and initializes an integer array, then accesses and updates its elements."
          }
        ]
      },
      {
        "id": "c-strings",
        "title": "C Strings (Character Arrays)",
        "description": "Work with sequences of characters (text) using null-terminated character arrays in C.",
        "content": "In C, strings are not a built-in data type like `int` or `float`. Instead, strings are typically represented as **arrays of characters** that are terminated by a special **null character (`'\\0'`)**. This null character signifies the end of the string, which is crucial for C's string-handling functions to know where the string ends.\n\n### Declaring and Initializing Strings:\n\n```c\n#include <stdio.h>\n#include <string.h> // Required for string functions like strlen, strcpy, strcat, strcmp\n\nint main() {\n    // 1. Declare and initialize with a string literal (most common)\n    char greeting[] = \"Hello\"; // Compiler determines size (6 bytes: H,e,l,l,o,\\0)\n\n    // 2. Declare with a fixed size, then initialize using strcpy()\n    // Make sure the array is large enough to hold the string PLUS the null terminator.\n    char name[20]; // Array can hold up to 19 characters + null terminator\n    strcpy(name, \"Alice\"); // strcpy(destination, source) - copies a string\n\n    // 3. Initialize character by character (less common for full strings)\n    char city[5] = {'N', 'Y', 'C', '\\0'}; // Must explicitly include the null terminator\n\n    printf(\"Greeting: %s\\n\", greeting); // %s is the format specifier for strings\n    printf(\"Name: %s\\n\", name);\n    printf(\"City: %s\\n\", city);\n\n    // Important: Size of the array vs. length of the string\n    printf(\"Size of greeting array (including null): %zu bytes\\n\", sizeof(greeting)); // 6 bytes\n    printf(\"Length of greeting string (excluding null): %zu characters\\n\", strlen(greeting)); // 5 characters\n\n    return 0;\n}\n```\n\n* **Null Termination:** The `\\0` is absolutely vital. Without it, C string functions will read beyond the intended end of your string, leading to undefined behavior (crashes, incorrect data).\n* **`%s` Format Specifier:** Used in `printf` to display strings and in `scanf` to read strings.\n\n### Common String Functions (`string.h` Library):\n\nThe `<string.h>` header provides a set of powerful functions for manipulating C-style strings:\n\n* `strlen(str)`: Returns the length of the string (number of characters before `\\0`).\n* `strcpy(dest, src)`: Copies the string `src` to `dest`. **CAUTION:** Does not check for buffer size. `strncpy` is a safer alternative but more complex.\n* `strcat(dest, src)`: Concatenates (appends) `src` to the end of `dest`. **CAUTION:** Does not check for buffer size. `strncat` is a safer alternative.\n* `strcmp(str1, str2)`: Compares two strings lexicographically. Returns 0 if equal, a negative value if `str1` is less than `str2`, and a positive value if `str1` is greater than `str2`.\n* `strchr(str, char)`: Returns a pointer to the first occurrence of `char` in `str`, or `NULL` if not found.\n* `strstr(haystack, needle)`: Returns a pointer to the first occurrence of `needle` in `haystack`, or `NULL` if not found.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str1[50] = \"Hello\";\n    char str2[] = \" World\";\n    char str3[50];\n    int cmp_result;\n\n    // Copy string from str1 to str3\n    strcpy(str3, str1);\n    printf(\"str3 after strcpy: %s\\n\", str3); // Output: Hello\n\n    // Concatenate str2 to str1\n    strcat(str1, str2); // str1 becomes \"Hello World\"\n    printf(\"str1 after strcat: %s\\n\", str1); // Output: Hello World\n\n    // Compare strings\n    cmp_result = strcmp(str1, str3); // Compare \"Hello World\" with \"Hello\"\n    if (cmp_result == 0) {\n        printf(\"str1 and str3 are equal.\\n\");\n    } else if (cmp_result < 0) {\n        printf(\"str1 is less than str3.\\n\");\n    } else {\n        printf(\"str1 is greater than str3.\\n\"); // This will execute\n    }\n    \n    char sentence[] = \"The quick brown fox.\";\n    char *ptr_to_fox = strstr(sentence, \"fox\");\n    if (ptr_to_fox != NULL) {\n        printf(\"Found 'fox' starting at: %s\\n\", ptr_to_fox);\n    } else {\n        printf(\" 'fox' not found.\\n\");\n    }\n\n    return 0;\n}\n```\n\nWorking with strings in C requires manual memory management and a good understanding of how null termination affects string operations. Always ensure your character arrays are large enough to prevent buffer overflows when using string manipulation functions.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char firstName[15] = \"Jane\";\n    char lastName[15] = \"Doe\";\n    char fullName[30];\n\n    strcpy(fullName, firstName); // fullName is \"Jane\"\n    strcat(fullName, \" \");      // fullName is \"Jane \"\n    strcat(fullName, lastName); // fullName is \"Jane Doe\"\n\n    printf(\"Full Name: %s\\n\", fullName);\n    printf(\"Length: %zu\\n\", strlen(fullName));\n    return 0;\n}",
            "description": "Combines a first and last name into a full name string using `strcpy` and `strcat`, then prints the full name and its length."
          }
        ]
      },
      {
        "id": "c-user-input",
        "title": "C User Input (`scanf()`)",
        "description": "Learn to read various types of user input from the console using the `scanf()` function.",
        "content": "User input is crucial for creating interactive programs. In C, the primary function for reading formatted input from the standard input device (usually the keyboard) is `scanf()`, provided by the `<stdio.h>` library.\n\n### The `scanf()` Function:\n\n* **Purpose:** To read and parse input from the console based on specified format specifiers.\n* **Syntax:** `scanf(\"format string\", &variable1, &variable2, ...);`\n    * `\"format string\"`: A string literal containing text to match and **format specifiers** indicating the type of data to read.\n    * `&variable`: The **address** of the variable where the input value should be stored. This is critical for `scanf()` to write directly into the variable's memory location.\n\n### Common Format Specifiers for Input:\n\n* `%d` or `%i`: Reads a signed decimal integer.\n* `%f`: Reads a single-precision floating-point number (`float`).\n* `%lf`: Reads a double-precision floating-point number (`double`). (Note: `%f` is used for `printf` for both `float` and `double`, but `scanf` requires `%lf` for `double`).\n* `%c`: Reads a single character.\n* `%s`: Reads a string (sequence of non-whitespace characters) into a character array. **Does NOT need `&` operator for array names.** It stops reading at the first whitespace character.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int age;\n    float height;\n    char initial;\n    char name[30]; // Array to store string (max 29 chars + null terminator)\n\n    printf(\"Enter your age: \");\n    scanf(\"%d\", &age); // Read integer. '&' is crucial.\n\n    printf(\"Enter your height (e.g., 1.75): \");\n    scanf(\"%f\", &height); // Read float. '&' is crucial.\n\n    // When mixing scanf for numbers and then strings, \n    // the newline left by the number input can cause issues.\n    // Clear the input buffer before reading a string with scanf(\"%s\").\n    // A common way is to add a space before %c or %s in the format string.\n    // Or use getchar() to consume the leftover newline.\n    while (getchar() != '\\n'); // Consume remaining characters including newline\n\n    printf(\"Enter your first initial: \");\n    scanf(\"%c\", &initial); // Read character. Note the space before %c if not clearing buffer.\n\n    printf(\"Enter your first name (no spaces): \");\n    scanf(\"%s\", name); // Read string. Array name already is a pointer, so no '&'.\n\n    printf(\"\\n--- Your Information ---\\n\");\n    printf(\"Name: %s\\n\", name);\n    printf(\"Initial: %c\\n\", initial);\n    printf(\"Age: %d\\n\", age);\n    printf(\"Height: %.2f meters\\n\", height);\n\n    return 0;\n}\n```\n\n### Important Considerations for `scanf()`:\n\n* **Buffer Overflows with `%s`:** When reading strings with `scanf(\"%s\", ...)` into a fixed-size character array, there's a risk of buffer overflow if the user inputs a string longer than the array's capacity. `scanf` doesn't check the buffer size. It's safer to specify a maximum width:\n    `scanf(\"%29s\", name);` (reads max 29 characters + null terminator for a 30-char array).\n* **Whitespace Handling:**\n    * `%d`, `%f`, `%s` automatically skip leading whitespace.\n    * `%c` does **not** skip leading whitespace. If there's a newline left in the buffer from a previous input, `%c` will read it. To avoid this, add a space before `%c` in the format string (`scanf(\" %c\", &initial);`) or consume the leftover newline as shown in the example with `while (getchar() != '\\n');`.\n* **Return Value:** `scanf()` returns the number of items successfully read. You can use this to check if input was successful.\n    ```c\n    int num_read = scanf(\"%d\", &age);\n    if (num_read != 1) {\n        printf(\"Invalid input for age.\\n\");\n    }\n    ```\n\nFor reading entire lines of text (including spaces), especially when the length is unknown, `fgets()` is generally preferred over `scanf(\"%s\")` for safety and flexibility.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    char productName[50];\n    int productQuantity;\n    double unitPrice;\n\n    printf(\"Enter product name (single word): \");\n    scanf(\"%s\", productName);\n\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &productQuantity);\n\n    printf(\"Enter unit price: \");\n    scanf(\"%lf\", &unitPrice);\n\n    printf(\"\\nOrder Summary:\\n\");\n    printf(\"Product: %s\\n\", productName);\n    printf(\"Quantity: %d\\n\", productQuantity);\n    printf(\"Unit Price: $%.2lf\\n\", unitPrice);\n    printf(\"Total: $%.2lf\\n\", productQuantity * unitPrice);\n\n    return 0;\n}",
            "description": "Prompts the user for a product name, quantity, and unit price, then prints an order summary using `scanf` for various data types."
          }
        ]
      },
      {
        "id": "c-memory-address",
        "title": "C Memory Address",
        "description": "Understand how variables are stored in memory and how to access their memory addresses.",
        "content": "Every variable in a C program is stored at a specific location in the computer's memory. This location has a unique identifier called a **memory address**. Understanding memory addresses is fundamental to C programming, especially when working with pointers.\n\n### What is a Memory Address? (Theory Focus):\n\n* Your computer's RAM (Random Access Memory) is like a vast collection of storage cells, each capable of holding a certain amount of data (typically 1 byte).\n* Each of these cells has a unique numerical address, much like a street address for a house.\n* When you declare a variable (e.g., `int num;`), the compiler reserves a certain number of these memory cells (e.g., 4 bytes for an `int`) and associates that block of memory with the variable's name.\n\n### The Address-of Operator (`&`):\n\nTo find the memory address of a variable, you use the **address-of operator (`&`)**, also known as the **reference operator**. When placed before a variable name, it returns the memory address where that variable is stored.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int myAge = 30;         // An integer variable\n    float myHeight = 1.75f; // A float variable\n    char myInitial = 'A';   // A character variable\n\n    // Using the address-of operator '&' to get memory addresses\n    printf(\"Value of myAge: %d\\t Address of myAge: %p\\n\", myAge, &myAge);\n    printf(\"Value of myHeight: %.2f\\t Address of myHeight: %p\\n\", myHeight, &myHeight);\n    printf(\"Value of myInitial: %c\\t Address of myInitial: %p\\n\", myInitial, &myInitial);\n\n    // Addresses of array elements (they are contiguous)\n    int numbers[] = {10, 20, 30};\n    printf(\"\\nAddress of numbers[0]: %p\\n\", &numbers[0]);\n    printf(\"Address of numbers[1]: %p\\n\", &numbers[1]);\n    printf(\"Address of numbers[2]: %p\\n\", &numbers[2]);\n\n    // Note: The address of the array name 'numbers' itself is the address of its first element\n    printf(\"Address of array name 'numbers': %p\\n\", numbers);\n\n    return 0;\n}\n```\n\n* **`%p` Format Specifier:** When printing memory addresses using `printf()`, you should use the `%p` format specifier. It displays the address in a hexadecimal format (e.g., `0x7ffe4226f7c4`).\n* **Contiguous Memory:** For arrays, the elements are stored in contiguous (adjacent) memory locations. You'll notice that the addresses of `numbers[0]`, `numbers[1]`, `numbers[2]` are sequentially spaced by the size of an `int` (e.g., 4 bytes apart if `int` is 4 bytes).\n\n### Why are Memory Addresses Important?\n\nUnderstanding memory addresses is crucial for:\n\n1.  **Pointers:** Pointers are variables specifically designed to store memory addresses. They allow you to directly manipulate the content at a given address.\n2.  **Dynamic Memory Allocation:** When you allocate memory at runtime (using `malloc`, `calloc`), these functions return memory addresses.\n3.  **Function Parameters (Call by Reference):** To modify original variables inside functions, you pass their addresses (using `&`) and work with pointers inside the function.\n4.  **Data Structures:** Implementing complex data structures like linked lists, trees, and graphs heavily relies on pointers and memory addresses.\n\nMemory addresses are the backbone of how C interacts with hardware and manages data, providing low-level control that contributes to C's power and efficiency.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    int a = 10;\n    char b = 'X';\n    double c = 3.14;\n\n    printf(\"Variable 'a' value: %d, Address: %p\\n\", a, &a);\n    printf(\"Variable 'b' value: %c, Address: %p\\n\", b, &b);\n    printf(\"Variable 'c' value: %.2lf, Address: %p\\n\", c, &c);\n\n    return 0;\n}",
            "description": "Prints the value and memory address of integer, character, and double variables."
          }
        ]
      },
      {
        "id": "c-pointers",
        "title": "C Pointers",
        "description": "Master pointers: variables that store memory addresses, enabling direct memory access.",
        "content": "Pointers are fundamental to C programming, offering a direct way to interact with memory addresses. A **pointer** is a variable that stores the memory address of another variable. This capability provides immense power and flexibility, crucial for dynamic memory management, arrays, and efficient function arguments.\n\n### 1. What is a Pointer? (Recap & Detail):\n\n* A pointer variable does not store a value directly (like an `int` stores `5`). Instead, it stores the numerical **memory address** (location) of another variable.\n* Pointers are declared to point to a specific data type (e.g., `int *`, `char *`). This tells the compiler what type of data to expect at the address the pointer holds.\n\n### 2. Declaring Pointers:\n\nUse the asterisk (`*`) during declaration to indicate that the variable is a pointer.\n\n* `dataType *pointerName;`\n\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 10;     // An ordinary integer variable\n    int *ptr;         // Declares 'ptr' as a pointer to an integer\n    char *char_ptr;   // Declares 'char_ptr' as a pointer to a character\n\n    // 3. Assigning Address to a Pointer: Using the Address-of Operator (`&`)\n    ptr = &num;       // Assigns the memory address of 'num' to 'ptr'\n    \n    // You can also declare and initialize in one go:\n    int value = 50;\n    int *value_ptr = &value;\n\n    printf(\"Value of num: %d\\n\", num);                                // Original value\n    printf(\"Address of num (from &num): %p\\n\", &num);                  // Memory address of num\n    printf(\"Value of ptr (address stored): %p\\n\", ptr);                // Address stored in ptr (same as &num)\n    printf(\"Value pointed to by ptr (*ptr): %d\\n\", *ptr);             // Dereferenced value (value at address in ptr)\n    printf(\"Address of ptr itself: %p\\n\", &ptr);                    // Address where the pointer variable 'ptr' is stored\n\n    // 4. Modifying Value Through a Pointer: Using the Dereference Operator (`*`)\n    *ptr = 20; // Changes the value at the memory location 'ptr' points to\n               // Effectively, 'num' is now 20\n    printf(\"\\nNew value of num (after *ptr = 20): %d\\n\", num); // Output: 20\n\n    return 0;\n}\n```\n\n* **Address-of Operator (`&`):** Used to obtain the memory address of a variable.\n* **Dereference Operator (`*`):** When used in an expression (not a declaration), it accesses the value stored at the memory address held by the pointer. It's often called the 'value-at-address' operator.\n* **`%p` Format Specifier:** Used in `printf` to display memory addresses (pointers) in hexadecimal format.\n\n### 5. Null Pointers:\n\nA pointer that does not point to any valid memory location is called a **null pointer**. It's good practice to initialize pointers to `NULL` (or `nullptr` in C++11 and later, or simply `0`) if they are not immediately assigned a valid address. This helps prevent accessing invalid memory, which can lead to crashes (segmentation faults).\n\n```c\n#include <stdio.h>\n#include <stddef.h> // For NULL macro\n\nint main() {\n    int *myNullPtr = NULL; // Initialize a pointer to NULL\n\n    if (myNullPtr == NULL) {\n        printf(\"The pointer is NULL, indicating it points to nothing.\\n\");\n    } else {\n        printf(\"The pointer is not NULL.\\n\");\n    }\n\n    // DO NOT attempt to dereference a NULL pointer! It will cause a runtime error.\n    // *myNullPtr = 10; // This would cause a segmentation fault!\n\n    return 0;\n}\n```\n\nPointers are the cornerstone of many advanced C programming concepts, including arrays, dynamic memory allocation, linked lists, and passing arguments by reference to functions. While powerful, they demand careful handling to avoid common memory-related errors.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    int data_value = 123;\n    int *pointer_to_data = &data_value; // Pointer stores address of data_value\n\n    printf(\"Original value: %d\\n\", data_value);          // 123\n    printf(\"Value via pointer: %d\\n\", *pointer_to_data); // 123\n    printf(\"Address of data_value: %p\\n\", &data_value);\n    printf(\"Address stored in pointer: %p\\n\", pointer_to_data);\n\n    *pointer_to_data = 456; // Change value through pointer\n    printf(\"New value of data_value: %d\\n\", data_value); // 456\n\n    return 0;\n}",
            "description": "Demonstrates pointer declaration, assigning an address, accessing the value through the pointer, and modifying the value."
          }
        ]
      },
      {
        "id": "c-functions",
        "title": "C Functions",
        "description": "Modularize your C code with functions, covering declaration, definition, and parameters.",
        "content": "Functions are self-contained blocks of code that perform a specific task. They are fundamental for organizing code into reusable units, improving readability, making debugging easier, and promoting modularity. Functions allow you to break down a large program into smaller, manageable pieces.\n\n### 1. Why Use Functions?\n\n* **Modularity:** Break down complex problems into smaller, more manageable sub-problems.\n* **Reusability:** Write code once and use it multiple times throughout your program or in different programs.\n* **Readability:** Make your code easier to understand and follow.\n* **Maintainability:** Easier to find and fix bugs, and to update specific parts of the code without affecting others.\n\n### 2. Function Declaration (Prototype):\n\n* A function declaration (or **function prototype**) tells the compiler about a function's existence, its name, return type, and the types of its parameters. It does *not* contain the function's body.\n* Prototypes are typically placed at the beginning of a source file (before `main()`) or in a separate header (`.h`) file.\n* **Syntax:** `returnType functionName(dataType1 parameter1, dataType2 parameter2, ...);`\n    * `returnType functionName(dataType1, dataType2, ...);` (parameter names are optional in declaration, but types are mandatory)\n\n### 3. Function Definition:\n\n* The function definition provides the actual implementation (the code body) of the function. This is where the function's task is performed.\n* **Syntax:**\n    ```c\n    returnType functionName(dataType1 parameter1, dataType2 parameter2, ...) {\n        // Function body: code to be executed\n        // return value; // If returnType is not void\n    }\n    ```\n\n### 4. Function Call:\n\n* To execute a function, you 'call' it by its name, optionally passing any required arguments. When a function is called, control transfers to the function definition, its code executes, and then control returns to the point of the call.\n\n```c\n#include <stdio.h>\n\n// Function Declaration (Prototypes) - tells the compiler about the functions\nvoid greetUser(); // Function with no parameters and no return value\nint addNumbers(int num1, int num2); // Function with two int parameters and int return type\n\nint main() { // Main function: program execution starts here\n    printf(\"Inside main function.\\n\");\n\n    greetUser(); // Calling the greetUser function\n\n    int sum_result = addNumbers(15, 25); // Calling addNumbers, passing arguments\n    printf(\"Sum of 15 and 25: %d\\n\", sum_result);\n\n    // Another call to addNumbers with different arguments\n    int val1 = 5;\n    int val2 = 7;\n    int another_sum = addNumbers(val1, val2);\n    printf(\"Sum of %d and %d: %d\\n\", val1, val2, another_sum);\n\n    return 0; // Exit main function (program ends)\n}\n\n// Function Definition - provides the actual implementation of greetUser\nvoid greetUser() {\n    printf(\"Hello from the greetUser function!\\n\");\n}\n\n// Function Definition - provides the actual implementation of addNumbers\nint addNumbers(int num1, int num2) { // Parameters are 'num1' and 'num2'\n    int sum = num1 + num2;\n    return sum; // Returns the calculated sum\n}\n```\n\n* **Return Type (`void`):** If a function does not return any value, its return type is `void`.\n* **Parameters/Arguments:** Values passed to a function are called arguments during the call and parameters inside the function definition. By default, C uses **call by value** for parameters, meaning copies are passed. To modify original variables, you use pointers (call by reference), discussed in another lesson.\n\nFunctions are the cornerstone of structured programming in C, allowing you to build complex applications from smaller, manageable, and testable components.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\n// Function prototype\nvoid printMessage(char message[]);\n\nint main() {\n    printMessage(\"This is a custom message.\");\n    printMessage(\"Another message here.\");\n    return 0;\n}\n\n// Function definition\nvoid printMessage(char message[]) {\n    printf(\"Message: %s\\n\", message);\n}",
            "description": "Defines a function `printMessage` that takes a string (character array) as input and prints it to the console, demonstrating function reusability."
          }
        ]
      },
      {
        "id": "c-function-parameters",
        "title": "C Function Parameters",
        "description": "Deep dive into passing arguments to functions and the concept of Call by Value.",
        "content": "Function parameters are placeholders in a function definition that receive values when the function is called. These values, known as arguments, allow you to pass data into a function, making the function more flexible and reusable.\n\n### 1. Formal Parameters vs. Actual Arguments:\n\n* **Formal Parameters:** These are the variables declared in the function definition's parameter list. They are local to the function.\n* **Actual Arguments:** These are the values or expressions passed to the function when it is called.\n\n```c\n#include <stdio.h>\n\n// Function definition with formal parameters: 'a' and 'b'\nint multiply(int a, int b) {\n    int product = a * b;\n    return product;\n}\n\nint main() {\n    int x = 5; // Actual argument for 'a'\n    int y = 10; // Actual argument for 'b'\n\n    int result = multiply(x, y); // Function call with actual arguments: 'x' and 'y'\n    printf(\"The product of %d and %d is %d\\n\", x, y, result);\n\n    printf(\"Product of 7 and 3: %d\\n\", multiply(7, 3)); // Literal values as actual arguments\n\n    return 0;\n}\n```\n\n### 2. Call by Value (Default in C):\n\nBy default, C uses **call by value** to pass arguments to functions. This means:\n\n* A **copy** of the actual argument's value is passed to the formal parameter.\n* The function works with this copy, not the original variable.\n* Any modifications made to the formal parameter inside the function **do not affect** the original actual argument in the calling function.\n\n```c\n#include <stdio.h>\n\nvoid modifyValue(int num_param) { // 'num_param' is a copy\n    printf(\"Inside function: num_param before modification = %d\\n\", num_param); // 10\n    num_param = 100; // Modifies the local copy\n    printf(\"Inside function: num_param after modification = %d\\n\", num_param);  // 100\n}\n\nint main() {\n    int original_num = 10;\n    printf(\"Before function call: original_num = %d\\n\", original_num); // 10\n\n    modifyValue(original_num); // Pass a copy of original_num\n\n    printf(\"After function call: original_num = %d\\n\", original_num); // Still 10 (original unaffected)\n\n    return 0;\n}\n```\n\n### Why Call by Value?\n\n* **Safety:** It protects the original data from accidental modification by the function.\n* **Simplicity:** Easy to understand for simple data types.\n\n### When to use Call by Value?\n\n* When the function only needs to read the value of an argument.\n* When the function doesn't need to change the original variable.\n* When passing small, primitive data types (like `int`, `char`, `float`, `double`).\n\nTo allow a function to modify the original variable, you need to use **call by reference** with **pointers**, which is a crucial concept covered in a dedicated lesson. Understanding call by value is foundational before moving to pointers and call by reference.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\n// Function to calculate sum of two numbers (call by value)\nint calculateSum(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int num1 = 20;\n    int num2 = 30;\n    int total;\n\n    total = calculateSum(num1, num2); // Pass copies of num1 and num2\n\n    printf(\"The sum is: %d\\n\", total);\n    \n    // Original num1 and num2 are unchanged\n    printf(\"Original num1: %d, Original num2: %d\\n\", num1, num2);\n\n    return 0;\n}",
            "description": "Demonstrates how `calculateSum` receives copies of `num1` and `num2` (call by value), so the original variables remain unchanged."
          }
        ]
      },
      {
        "id": "c-scope",
        "title": "C Scope",
        "description": "Understand the visibility and lifetime of variables in C: local, global, and block scope.",
        "content": "In C programming, the **scope** of a variable defines the region of the program where that variable is visible and can be accessed. The **lifetime** of a variable refers to the period during which the variable exists in memory. Understanding scope and lifetime is critical for preventing naming conflicts and managing memory correctly.\n\nThere are primarily three types of scope in C:\n\n### 1. Local Scope (Block Scope):\n\n* **Definition:** Variables declared inside a block (`{ }`), such as inside a function or a loop, have local scope. They are only visible and accessible from their point of declaration to the end of that block.\n* **Lifetime:** These variables are created when the block is entered and destroyed when the block is exited. They are stored on the **stack** (unless they are `static`).\n* **Example:**\n\n```c\n#include <stdio.h>\n\nvoid myFunction() {\n    int local_var_func = 10; // local_var_func has local scope within myFunction()\n    printf(\"Inside myFunction: local_var_func = %d\\n\", local_var_func);\n\n    if (1) { // A new block\n        int block_var = 20; // block_var has local scope within this if block\n        printf(\"Inside if block: block_var = %d\\n\", block_var);\n    } // block_var is destroyed here\n    // printf(\"Outside if block: block_var = %d\\n\", block_var); // ERROR: block_var is not visible here\n}\n\nint main() {\n    int main_var = 5; // main_var has local scope within main()\n    printf(\"Inside main: main_var = %d\\n\", main_var);\n    myFunction();\n    // printf(\"Inside main: local_var_func = %d\\n\", local_var_func); // ERROR: local_var_func is not visible here\n    return 0;\n}\n```\n\n### 2. Global Scope (File Scope):\n\n* **Definition:** Variables declared outside of any function, usually at the top of a source file, have global scope. They are visible and accessible from their point of declaration to the end of the file in which they are declared.\n* **Lifetime:** They exist throughout the entire execution of the program.\n* **Storage:** Stored in the **data segment** (initialized global variables) or **BSS segment** (uninitialized global variables) of memory.\n* **Initialization:** Global variables are automatically initialized to zero if not explicitly initialized by the programmer.\n* **Example:**\n\n```c\n#include <stdio.h>\n\nint global_variable = 100; // global_variable has global scope\n\nvoid anotherFunction() {\n    printf(\"Inside anotherFunction: global_variable = %d\\n\", global_variable);\n}\n\nint main() {\n    printf(\"Inside main: global_variable = %d\\n\", global_variable);\n    global_variable = 200; // Global variables can be modified from anywhere\n    printf(\"Inside main (modified): global_variable = %d\\n\", global_variable);\n    anotherFunction();\n    return 0;\n}\n```\n\n### 3. Function Prototype Scope (Limited):\n\n* Parameters declared in a function prototype (declaration) have function prototype scope. Their names are only visible within the prototype itself and are not required to match the names in the function definition.\n\n### Shadowing (Local Hiding Global):\n\n* If a local variable has the same name as a global variable, the local variable takes precedence within its scope, effectively 'shadowing' the global one.\n\n```c\n#include <stdio.h>\n\nint counter = 1; // Global variable\n\nvoid printCounter() {\n    int counter = 10; // Local variable 'counter' shadows global 'counter'\n    printf(\"Local counter: %d\\n\", counter);\n}\n\nint main() {\n    printf(\"Global counter: %d\\n\", counter);\n    printCounter();\n    printf(\"Global counter after function call: %d\\n\", counter);\n    return 0;\n}\n```\n\nProperly managing variable scope is crucial for writing robust, maintainable, and error-free C programs. While global variables are convenient, overuse can lead to tightly coupled code and make debugging difficult.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint global_data = 50; // Global scope\n\nvoid display() {\n    int local_data = 10; // Local scope to display()\n    printf(\"From display: Local = %d, Global = %d\\n\", local_data, global_data);\n}\n\nint main() {\n    int main_local = 5; // Local scope to main()\n    printf(\"From main: Local = %d, Global = %d\\n\", main_local, global_data);\n    display();\n    \n    if (1) {\n        int block_local = 2; // Block scope\n        printf(\"From block: Block Local = %d, Main Local (from main's scope) is not visible\\n\", block_local);\n    }\n    // printf(\"Block Local outside block: %d\\n\", block_local); // Error: Not visible\n\n    return 0;\n}",
            "description": "Illustrates local, global, and block scope by demonstrating where variables are accessible and their lifetimes."
          }
        ]
      },
      {
        "id": "c-function-declaration",
        "title": "C Function Declaration",
        "description": "Understand the purpose and syntax of function declarations (prototypes) in C.",
        "content": "A **function declaration**, also known as a **function prototype**, provides the compiler with essential information about a function before its actual definition appears in the code. It tells the compiler the function's name, its return type, and the number and types of its parameters. This allows the compiler to perform type checking and generate correct code even if the function's full definition is located later in the same file or in a different source file.\n\n### Why are Function Declarations Important?\n\n1.  **Compiler Checks:** The compiler needs to know a function's signature (return type and parameter types) to ensure that function calls are made correctly. Without a prototype, if a function is called before it's defined, the compiler might assume an `int` return type and a variable number of arguments, leading to potential type mismatch errors or warnings.\n2.  **Order of Definitions:** It allows you to define functions in any order within a single file, or even split function definitions across multiple `.c` source files, as long as declarations are available.\n3.  **Header Files (`.h`):** In larger projects, function declarations are commonly placed in header files (`.h` extensions). These header files are then included (`#include`) in any source file (`.c`) that uses those functions, promoting modularity and preventing redundant declarations.\n\n### Syntax of a Function Declaration:\n\n```c\nreturnType functionName(dataType1 parameter1, dataType2 parameter2, ...);\n// OR (parameter names are optional in declaration, but types are mandatory)\nreturnType functionName(dataType1, dataType2, ...);\n```\n\n* **`returnType`**: The data type of the value the function returns (e.g., `int`, `float`, `void`).\n* **`functionName`**: The unique identifier for the function.\n* **`dataTypeN`**: The data type of each parameter. Parameter names are optional in the declaration but can improve readability.\n* **Semicolon (`;`)**: Crucially, a function declaration **must** end with a semicolon.\n\n```c\n#include <stdio.h>\n\n// --- Function Declarations (Prototypes) ---\n// Declare a function that takes two integers and returns an integer.\nint add(int a, int b);\n\n// Declare a function that takes no arguments and returns nothing.\nvoid printWelcomeMessage();\n\n// Declare a function that takes a float and returns a float.\nfloat calculateArea(float radius);\n\nint main() {\n    // Function calls can now be made before function definitions\n    printWelcomeMessage();\n\n    int sum = add(10, 20);\n    printf(\"Sum: %d\\n\", sum);\n\n    float area = calculateArea(5.0f);\n    printf(\"Area: %.2f\\n\", area);\n\n    return 0;\n}\n\n// --- Function Definitions (Implementations) ---\n// Definition of the add function\nint add(int a, int b) {\n    return a + b;\n}\n\n// Definition of the printWelcomeMessage function\nvoid printWelcomeMessage() {\n    printf(\"Welcome to the function demonstration!\\n\");\n}\n\n// Definition of the calculateArea function\nfloat calculateArea(float radius) {\n    const float PI = 3.14159f; // Using a const for PI\n    return PI * radius * radius;\n}\n```\n\nBy convention, function prototypes are often found in header (`.h`) files, and their corresponding definitions are in `.c` (source) files. This separation is key to organizing larger C projects effectively.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\n// Function Declaration: Tells compiler 'power' exists and what its signature is.\nint power(int base, int exp);\n\nint main() {\n    int result = power(2, 3); // Call the function\n    printf(\"2 raised to the power of 3 is: %d\\n\", result);\n    return 0;\n}\n\n// Function Definition: Actual implementation of 'power'.\nint power(int base, int exp) {\n    int res = 1;\n    for (int i = 0; i < exp; i++) {\n        res *= base;\n    }\n    return res;\n}",
            "description": "Demonstrates a C program with a function `power` that calculates a base raised to an exponent, highlighting the separate function declaration and definition."
          }
        ]
      },
      {
        "id": "c-recursion",
        "title": "C Recursion",
        "description": "Understand recursion: a function calling itself to solve problems by breaking them down.",
        "content": "Recursion is a programming technique where a function calls itself, directly or indirectly, to solve a problem. It's a powerful approach for problems that can be broken down into smaller, self-similar sub-problems. Every recursive function must have a **base case** to prevent infinite recursion and ensure termination.\n\n### How Recursion Works (Theory Focus):\n\n* **Base Case:** A condition that stops the recursion. When the base case is met, the function returns a value without making another recursive call. This is crucial to prevent an infinite loop.\n* **Recursive Step:** The part of the function where it calls itself, typically with a modified input that moves closer to the base case.\n\n### Example: Factorial Calculation (Illustrative Problem):\n\nThe factorial of a non-negative integer `n` (denoted as `n!`) is the product of all positive integers less than or equal to `n`. The base cases are `0! = 1` and `1! = 1`.\n\nMathematically:\n* `n! = n * (n-1)!` for `n > 1`\n* `0! = 1`\n\n```c\n#include <stdio.h>\n\n// Recursive function to calculate factorial\nlong long int factorial(int n) {\n    // Base case: If n is 0 or 1, return 1\n    if (n == 0 || n == 1) {\n        return 1;\n    }\n    // Recursive step: n * factorial(n-1)\n    else {\n        return n * factorial(n - 1); // Function calls itself\n    }\n}\n\nint main() {\n    int num = 5;\n    printf(\"Factorial of %d is %lld\\n\", num, factorial(num)); // Output: 120\n\n    int num2 = 0;\n    printf(\"Factorial of %d is %lld\\n\", num2, factorial(num2)); // Output: 1\n\n    int num3 = 10;\n    printf(\"Factorial of %d is %lld\\n\", num3, factorial(num3)); // Output: 3628800\n\n    return 0;\n}\n```\n\n### Pros and Cons of Recursion:\n\n* **Pros:**\n    * Often leads to more elegant and readable solutions for problems that are inherently recursive (e.g., tree traversals, quicksort).\n    * Reduces code length for certain problems.\n* **Cons:**\n    * Can be less efficient than iterative solutions due to function call overhead (stack usage).\n    * Risk of **stack overflow** if the recursion depth is too large (too many nested calls without reaching a base case).\n    * Can sometimes be harder to trace and debug.\n\nWhile powerful, recursion should be used thoughtfully, especially in performance-critical applications or when dealing with very large inputs where an iterative solution might be more appropriate.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\n// Recursive function to calculate Fibonacci numbers\n// F(n) = F(n-1) + F(n-2), F(0)=0, F(1)=1\nint fibonacci(int n) {\n    if (n <= 1) {\n        return n; // Base cases: F(0)=0, F(1)=1\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive step\n}\n\nint main() {\n    int n_terms = 6;\n    printf(\"Fibonacci sequence up to %d terms:\\n\", n_terms);\n    for (int i = 0; i < n_terms; i++) {\n        printf(\"%d \", fibonacci(i));\n    } // Output: 0 1 1 2 3 5 \n    printf(\"\\n\");\n    return 0;\n}",
            "description": "Calculates and prints the first N Fibonacci numbers using a recursive function, demonstrating multiple recursive calls."
          }
        ]
      },
      {
        "id": "c-math-functions",
        "title": "C Math Functions (`math.h`)",
        "description": "Utilize common mathematical functions for calculations like square roots, powers, and trigonometry.",
        "content": "C provides a rich set of mathematical functions available through the `<math.h>` header file. These functions allow you to perform common mathematical operations such as square roots, powers, trigonometric calculations, logarithms, and more. When compiling programs that use functions from `<math.h>`, you often need to link the math library using the `-lm` flag with GCC.\n\n### Common Math Functions:\n\n1.  **`sqrt()`:** Calculates the square root of a non-negative number.\n    * **Syntax:** `double sqrt(double x);`\n2.  **`pow()`:** Calculates the power of a number (`x` raised to the power of `y`).\n    * **Syntax:** `double pow(double base, double exponent);`\n3.  **`fabs()`:** Returns the absolute value of a floating-point number.\n    * **Syntax:** `double fabs(double x);` (also `abs()` for int, `labs()` for long int)\n4.  **`ceil()`:** Rounds a floating-point number up to the nearest integer.\n    * **Syntax:** `double ceil(double x);`\n5.  **`floor()`:** Rounds a floating-point number down to the nearest integer.\n    * **Syntax:** `double floor(double x);`\n6.  **`round()`:** Rounds a floating-point number to the nearest integer.\n    * **Syntax:** `double round(double x);`\n7.  **`sin()`, `cos()`, `tan()`:** Trigonometric sine, cosine, and tangent (input in radians).\n    * **Syntax:** `double sin(double angle_rad);`\n8.  **`log()`, `log10()`:** Natural logarithm (base `e`) and base-10 logarithm.\n    * **Syntax:** `double log(double x);`, `double log10(double x);`\n\n```c\n#include <stdio.h>\n#include <math.h> // Required for math functions\n\nint main() {\n    double num = 25.0;\n    double result_sqrt = sqrt(num);\n    printf(\"Square root of %.1lf is %.1lf\\n\", num, result_sqrt); // Output: 5.0\n\n    double base = 2.0;\n    double exponent = 3.0;\n    double result_pow = pow(base, exponent);\n    printf(\"%.1lf raised to the power of %.1lf is %.1lf\\n\", base, exponent, result_pow); // Output: 8.0\n\n    double val = -12.7;\n    double result_abs = fabs(val);\n    printf(\"Absolute value of %.1lf is %.1lf\\n\", val, result_abs); // Output: 12.7\n\n    double decimal_num = 3.14;\n    printf(\"Ceil of %.2lf is %.0lf\\n\", decimal_num, ceil(decimal_num));   // Output: 4\n    printf(\"Floor of %.2lf is %.0lf\\n\", decimal_num, floor(decimal_num)); // Output: 3\n    printf(\"Round of %.2lf is %.0lf\\n\", decimal_num, round(decimal_num)); // Output: 3\n\n    // Trigonometric example (M_PI is often defined in math.h for PI)\n    double angle_degrees = 90.0;\n    double angle_radians = angle_degrees * (M_PI / 180.0);\n    printf(\"Sin of %.0lf degrees (%.2lf radians) is %.2lf\\n\", angle_degrees, angle_radians, sin(angle_radians)); // Output: 1.00\n\n    return 0;\n}\n```\n\n### Compilation Note (for GCC/Clang):\n\nWhen compiling programs that use functions from `<math.h>`, you usually need to explicitly link the math library. With GCC or Clang, this is done by adding the `-lm` flag at the end of your compile command:\n\n```bash\ngcc your_program.c -o your_program -lm\n```\n\nThese mathematical functions are indispensable for scientific computing, graphics, game development, and any application requiring numerical analysis.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double hypotenuse;\n    double side1 = 3.0;\n    double side2 = 4.0;\n\n    // Calculate hypotenuse using Pythagorean theorem: sqrt(side1^2 + side2^2)\n    hypotenuse = sqrt(pow(side1, 2) + pow(side2, 2));\n\n    printf(\"For a right triangle with sides %.1lf and %.1lf, the hypotenuse is %.1lf\\n\",\n           side1, side2, hypotenuse); // Output: 5.0\n\n    return 0;\n}",
            "description": "Calculates the hypotenuse of a right triangle using `sqrt()` and `pow()` functions from `<math.h>`."
          }
        ]
      },
      {
        "id": "c-create-files",
        "title": "C Create Files",
        "description": "Learn to create and open files in C for writing and reading operations.",
        "content": "File handling is a crucial aspect of C programming, allowing programs to interact with the file system to store and retrieve data persistently. The first step in file handling is to create or open a file. This is done using the `fopen()` function, which returns a file pointer (`FILE*`).\n\n### `FILE` Pointer (Theory Focus):\n\n* In C, file operations are performed using a special pointer of type `FILE*` (defined in `<stdio.h>`). This pointer acts as a link between your program and the operating system's file system.\n* It points to a structure that contains information about the file, such as its name, mode, buffer, current position within the file, and whether an error occurred.\n\n### `fopen()` Function:\n\n* **Purpose:** Opens a file in a specified mode.\n* **Syntax:** `FILE *fp = fopen(\"filename\", \"mode\");`\n    * `\"filename\"`: A string containing the name of the file to open (can include a path).\n    * `\"mode\"`: A string specifying the file access mode.\n* **Return Value:** Returns a `FILE*` pointer on success, or `NULL` if the file cannot be opened (e.g., due to invalid path, permissions, or disk full).\n\n### Common File Modes (`\"mode\"`):\n\n| Mode  | Description                                                 |\n| :---- | :---------------------------------------------------------- |\n| `\"r\"` | **Read mode.** Opens an existing file for reading. File must exist.        |\n| `\"w\"` | **Write mode.** Creates a new file for writing. If the file exists, its content is truncated (erased).      |\n| `\"a\"` | **Append mode.** Opens a file for writing, appending data to the end. If the file doesn't exist, it's created. |\n| `\"r+\"`| **Read and Update.** Opens an existing file for both reading and writing. |\n| `\"w+\"`| **Write and Update.** Creates a new file for reading and writing. If the file exists, its content is truncated. |\n| `\"a+\"`| **Append and Update.** Opens a file for reading and appending. If the file doesn't exist, it's created. |\n\n(There are also binary modes like `\"rb\"`, `\"wb\"`, etc., for working with binary data).\n\n### `fclose()` Function (Crucial):\n\n* **Purpose:** Closes an opened file stream. This flushes any buffered data to the disk, releases resources, and breaks the link between your program and the file.\n* **Syntax:** `int fclose(FILE *fp);`\n* **Return Value:** Returns 0 on success, `EOF` (End Of File) on error.\n* **Importance:** Failing to close files can lead to data loss (buffered data not written), resource leaks, and file corruption.\n\n```c\n#include <stdio.h>\n#include <stdlib.h> // For EXIT_SUCCESS/EXIT_FAILURE\n\nint main() {\n    FILE *fptr;\n\n    // --- Creating a file for writing (or truncating existing) ---\n    fptr = fopen(\"newfile.txt\", \"w\"); // Open in write mode\n\n    if (fptr == NULL) { // Always check if fopen was successful\n        printf(\"Error creating file!\\n\");\n        return EXIT_FAILURE; // Standard way to indicate failure\n    }\n\n    printf(\"File 'newfile.txt' created/opened successfully in write mode.\\n\");\n    // You can write to it now, which will be covered in the next lesson\n\n    fclose(fptr); // Close the file\n    printf(\"File 'newfile.txt' closed.\\n\");\n\n    // --- Trying to open a non-existent file in read mode ---\n    fptr = fopen(\"nonexistent.txt\", \"r\"); // Open in read mode\n\n    if (fptr == NULL) {\n        printf(\"Error: File 'nonexistent.txt' could not be opened for reading (it likely does not exist).\\n\");\n    } else {\n        printf(\"File 'nonexistent.txt' opened successfully for reading. (Should not happen)\\n\");\n        fclose(fptr);\n    }\n\n    // --- Creating a file for appending (or creating if not exists) ---\n    fptr = fopen(\"log.txt\", \"a\"); // Open in append mode\n    if (fptr == NULL) {\n        printf(\"Error creating/opening log.txt in append mode!\\n\");\n        return EXIT_FAILURE;\n    }\n    printf(\"File 'log.txt' created/opened successfully in append mode.\\n\");\n    fclose(fptr);\n    printf(\"File 'log.txt' closed.\\n\");\n\n    return EXIT_SUCCESS;\n}\n```\n\nAlways remember to check the return value of `fopen()` and to call `fclose()` for every file you open to prevent resource leaks and data issues.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *filePtr;\n    filePtr = fopen(\"mydata.txt\", \"w\"); // Open for writing (creates or truncates)\n\n    if (filePtr == NULL) {\n        printf(\"Error: Could not create/open file.\\n\");\n        return 1; // Indicate error\n    }\n\n    printf(\"File 'mydata.txt' opened successfully in write mode.\\n\");\n    fclose(filePtr); // Close the file\n    printf(\"File closed.\\n\");\n\n    return 0;\n}",
            "description": "Demonstrates creating a new file named `mydata.txt` in write mode and then closing it. Includes error handling for `fopen`."
          }
        ]
      },
      {
        "id": "c-write-to-files",
        "title": "C Write To Files",
        "description": "Write various types of data (text, numbers) to files in C.",
        "content": "Once a file is successfully opened in a write or append mode (e.g., `\"w\"`, `\"a\"`, `\"w+\"`), you can write data to it. C provides several functions for writing different types of data to files, similar to how `printf()` works for console output.\n\n### Functions for Writing to Files (`stdio.h`):\n\n1.  **`fprintf()` (Formatted File Print):**\n    * Similar to `printf()`, but writes formatted output to a specified `FILE*` stream instead of the console.\n    * **Syntax:** `int fprintf(FILE *fp, const char *format, ...);`\n        * `fp`: The file pointer returned by `fopen()`.\n        * `format`: The format string (same as `printf()`).\n        * `...`: Optional arguments.\n    * **Return Value:** Returns the number of characters written on success, or a negative value on error.\n\n2.  **`fputc()` (File Put Character):**\n    * Writes a single character to the specified `FILE*` stream.\n    * **Syntax:** `int fputc(int character, FILE *fp);`\n        * `character`: The character to write (passed as an `int`).\n    * **Return Value:** Returns the character written on success, or `EOF` on error.\n\n3.  **`fputs()` (File Put String):**\n    * Writes a null-terminated string to the specified `FILE*` stream.\n    * **Syntax:** `int fputs(const char *str, FILE *fp);`\n        * `str`: The string to write.\n    * **Return Value:** Returns a non-negative value on success, or `EOF` on error. **Note:** `fputs()` does not automatically add a newline character at the end of the string; you must include it in `str` if desired (`\"Hello\\n\"`).\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    FILE *file_out;\n    char text_to_write[] = \"This is a line of text.\\n\";\n    int number = 123;\n    float pi_val = 3.14159f;\n    char single_char = 'X';\n\n    // Open file in write mode (\"w\") - will create or overwrite existing content\n    file_out = fopen(\"output.txt\", \"w\");\n\n    if (file_out == NULL) {\n        printf(\"Error opening file for writing!\\n\");\n        return EXIT_FAILURE;\n    }\n\n    printf(\"Writing to 'output.txt'\\n\");\n\n    // Using fprintf to write formatted data\n    fprintf(file_out, \"Hello, file!\\n\");\n    fprintf(file_out, \"%s\", text_to_write);\n    fprintf(file_out, \"Number: %d, PI: %.2f\\n\", number, pi_val);\n\n    // Using fputc to write a single character\n    fputc(single_char, file_out);\n    fputc('\\n', file_out); // Add a newline after the character\n\n    // Using fputs to write a string\n    fputs(\"Another line written with fputs.\\n\", file_out);\n\n    fclose(file_out); // Close the file\n    printf(\"Data written and file 'output.txt' closed.\\n\");\n\n    // --- Appending to an existing file ---\n    file_out = fopen(\"output.txt\", \"a\"); // Open in append mode (\"a\")\n    if (file_out == NULL) {\n        printf(\"Error opening file for appending!\\n\");\n        return EXIT_FAILURE;\n    }\n    printf(\"\\nAppending to 'output.txt'\\n\");\n    fprintf(file_out, \"This line was appended.\\n\");\n    fclose(file_out);\n    printf(\"Appended data and file 'output.txt' closed.\\n\");\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Important Reminders:\n\n* Always check the return value of `fopen()` to ensure the file was opened successfully.\n* Always `fclose()` a file after you are done writing to it to ensure all buffered data is written to disk and resources are released.\n* Be aware of the mode: `\"w\"` will overwrite, `\"a\"` will append.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dataFile;\n    dataFile = fopen(\"grades.txt\", \"w\");\n\n    if (dataFile == NULL) {\n        printf(\"Error opening file.\\n\");\n        return 1;\n    }\n\n    fprintf(dataFile, \"Student Name: Alice\\n\");\n    fprintf(dataFile, \"Math: 95\\n\");\n    fprintf(dataFile, \"Science: 88\\n\");\n\n    fclose(dataFile);\n    printf(\"Data written to grades.txt successfully.\\n\");\n    return 0;\n}",
            "description": "Writes student grades and name to a file named `grades.txt` using `fprintf`."
          }
        ]
      },
      {
        "id": "c-read-files",
        "title": "C Read Files",
        "description": "Read data from files character by character, line by line, or formatted input in C.",
        "content": "Reading data from files is just as important as writing to them. C provides several functions within `<stdio.h>` to read various types of data from files, allowing your program to process stored information.\n\n### Functions for Reading from Files (`stdio.h`):\n\n1.  **`fscanf()` (Formatted File Scan):**\n    * Similar to `scanf()`, but reads formatted input from a specified `FILE*` stream.\n    * **Syntax:** `int fscanf(FILE *fp, const char *format, ...);`\n        * `fp`: The file pointer returned by `fopen()`.\n        * `format`: The format string (same as `scanf()`).\n        * `...`: Addresses of variables to store the input.\n    * **Return Value:** Returns the number of input items successfully matched and assigned, or `EOF` if the end-of-file is reached or an error occurs before any items are matched.\n\n2.  **`fgetc()` (File Get Character):**\n    * Reads a single character from the specified `FILE*` stream.\n    * **Syntax:** `int fgetc(FILE *fp);`\n    * **Return Value:** Returns the character read (as an `int`), or `EOF` if the end of the file is reached or an error occurs.\n\n3.  **`fgets()` (File Get String):**\n    * Reads a line of text (string) from the specified `FILE*` stream until a newline character, `EOF`, or the specified buffer size is reached.\n    * **Syntax:** `char *fgets(char *str, int size, FILE *fp);`\n        * `str`: A pointer to the character array (buffer) where the string will be stored.\n        * `size`: The maximum number of characters to read (including the null terminator `\\0`). `fgets` will read at most `size - 1` characters.\n        * `fp`: The file pointer.\n    * **Return Value:** Returns `str` on success, or `NULL` if `EOF` is reached or an error occurs.\n    * **Important:** `fgets()` includes the newline character (`\\n`) if it's read from the file.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    FILE *file_in;\n    char buffer[100]; // Buffer to store read strings/lines\n    int num;\n    char name[50];\n\n    // --- Example 1: Reading formatted data with fscanf ---\n    // First, let's create a file with some formatted data to read\n    FILE *temp_write = fopen(\"data.txt\", \"w\");\n    if (temp_write == NULL) { printf(\"Error preparing data.txt\\n\"); return EXIT_FAILURE; }\n    fprintf(temp_write, \"Age: 30\\nName: Alice\\nValue: 123.45\\n\");\n    fclose(temp_write);\n\n    file_in = fopen(\"data.txt\", \"r\"); // Open in read mode\n    if (file_in == NULL) {\n        printf(\"Error opening 'data.txt' for reading!\\n\");\n        return EXIT_FAILURE;\n    }\n    printf(\"\\n--- Reading formatted data with fscanf ---\\n\");\n    // Read integer and skip \"Age: \"\n    if (fscanf(file_in, \"Age: %d\\n\", &num) == 1) {\n        printf(\"Read Age: %d\\n\", num);\n    }\n    // Read string and skip \"Name: \"\n    if (fscanf(file_in, \"Name: %s\\n\", name) == 1) { // %s stops at whitespace\n        printf(\"Read Name: %s\\n\", name);\n    }\n    // For reading full lines or strings with spaces, fgets is usually better.\n    fclose(file_in);\n\n    // --- Example 2: Reading line by line with fgets ---\n    file_in = fopen(\"lines.txt\", \"w\"); // Create a file with multiple lines\n    if (temp_write == NULL) { printf(\"Error preparing lines.txt\\n\"); return EXIT_FAILURE; }\n    fprintf(file_in, \"First line of text.\\n\");\n    fprintf(file_in, \"Second line with more words.\\n\");\n    fprintf(file_in, \"Third and final line.\\n\");\n    fclose(file_in);\n\n    file_in = fopen(\"lines.txt\", \"r\");\n    if (file_in == NULL) {\n        printf(\"Error opening 'lines.txt' for reading!\\n\");\n        return EXIT_FAILURE;\n    }\n    printf(\"\\n--- Reading line by line with fgets ---\\n\");\n    while (fgets(buffer, sizeof(buffer), file_in) != NULL) {\n        // fgets includes the newline character if it's read\n        printf(\"%s\", buffer); // buffer already contains \\n if present\n    }\n    fclose(file_in);\n\n    // --- Example 3: Reading character by character with fgetc ---\n    file_in = fopen(\"chars.txt\", \"w\"); // Create a file with simple text\n    if (temp_write == NULL) { printf(\"Error preparing chars.txt\\n\"); return EXIT_FAILURE; }\n    fprintf(file_in, \"ABCDEFG\");\n    fclose(file_in);\n\n    file_in = fopen(\"chars.txt\", \"r\");\n    if (file_in == NULL) {\n        printf(\"Error opening 'chars.txt' for reading!\\n\");\n        return EXIT_FAILURE;\n    }\n    printf(\"\\n--- Reading character by character with fgetc ---\\n\");\n    int ch;\n    while ((ch = fgetc(file_in)) != EOF) {\n        printf(\"%c\", ch);\n    }\n    printf(\"\\n\");\n    fclose(file_in);\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Error Handling and End-of-File (EOF):\n\n* Always check the return value of `fopen()`.\n* For `fgetc()`, `EOF` is an integer constant typically defined as `-1`. You must compare the return value of `fgetc` to `EOF` to detect the end of the file or an error.\n* For `fscanf()` and `fgets()`, they return `NULL` or `EOF` on failure or when the end of the file is reached.\n* Always `fclose()` files after reading.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *dataFile;\n    char line[100]; // Buffer to hold one line from the file\n\n    dataFile = fopen(\"mytext.txt\", \"r\"); // Open for reading\n\n    if (dataFile == NULL) {\n        printf(\"Error: Could not open file for reading. Make sure 'mytext.txt' exists.\\n\");\n        return 1;\n    }\n\n    printf(\"Content of mytext.txt:\\n\");\n    while (fgets(line, sizeof(line), dataFile) != NULL) {\n        printf(\"%s\", line); // fgets includes the newline if present in file\n    }\n\n    fclose(dataFile);\n    return 0;\n}",
            "description": "Reads and prints content from a file named `mytext.txt` line by line using `fgets`. Requires `mytext.txt` to exist for successful execution."
          }
        ]
      },
      {
        "id": "c-structures",
        "title": "C Structures",
        "description": "Define custom data types to group related variables of different types under a single name.",
        "content": "In C, a **structure** (`struct`) is a user-defined data type that allows you to combine variables of different data types under a single name. Structures are incredibly useful for representing real-world entities that have multiple attributes, such as a `Student` (with `name`, `id`, `grade`), a `Point` (with `x`, `y` coordinates), or a `Book` (with `title`, `author`, `pages`).\n\n### Declaring a Structure:\n\n* A structure definition creates a blueprint or a template for a new data type. It does not allocate memory.\n* **Syntax:**\n    ```c\n    struct StructureName {\n        dataType member1;\n        dataType member2;\n        // ... more members\n    };\n    ```\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// 1. Declare a structure named 'Student'\nstruct Student {\n    char name[50];\n    int roll_number;\n    float marks;\n};\n\nint main() {\n    // 2. Declare variables of type 'struct Student'\n    struct Student student1; // Declare a structure variable\n\n    // 3. Accessing and assigning values to members (using the dot operator '.')\n    strcpy(student1.name, \"Alice Smith\"); // Assign string using strcpy\n    student1.roll_number = 101;\n    student1.marks = 85.5f;\n\n    // 4. Accessing and printing members\n    printf(\"Student Name: %s\\n\", student1.name);\n    printf(\"Roll Number: %d\\n\", student1.roll_number);\n    printf(\"Marks: %.1f\\n\", student1.marks);\n\n    // 5. Another way to initialize structures upon declaration\n    struct Student student2 = {\"Bob Johnson\", 102, 92.0f};\n    printf(\"\\nStudent Name: %s\\n\", student2.name);\n    printf(\"Roll Number: %d\\n\", student2.roll_number);\n    printf(\"Marks: %.1f\\n\", student2.marks);\n\n    return 0;\n}\n```\n\n### Accessing Members:\n\n* **Dot Operator (`.`):** Used to access members of a structure variable directly (e.g., `student1.name`).\n* **Arrow Operator (`->`):** Used to access members of a structure when working with a **pointer to a structure** (e.g., `ptr_to_student->name`).\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p1 = {10, 20};\n    struct Point *ptr_p1 = &p1; // Pointer to a Point structure\n\n    // Accessing members using dot operator\n    printf(\"p1.x = %d, p1.y = %d\\n\", p1.x, p1.y);\n\n    // Accessing members using arrow operator with a pointer\n    printf(\"ptr_p1->x = %d, ptr_p1->y = %d\\n\", ptr_p1->x, ptr_p1->y);\n    \n    // Modifying through pointer\n    ptr_p1->x = 15;\n    printf(\"p1.x after modification via pointer = %d\\n\", p1.x);\n\n    return 0;\n}\n```\n\n### `typedef` with Structures (Convenience):\n\nUsing `typedef` can create an alias for `struct StructureName`, making variable declarations cleaner.\n\n```c\n#include <stdio.h>\n\n// Define a structure and create a typedef alias 'Circle'\ntypedef struct Circle {\n    float radius;\n    char color[20];\n} Circle; // Now 'Circle' can be used instead of 'struct Circle'\n\nint main() {\n    Circle c1; // Declare using the typedef alias\n    c1.radius = 10.0f;\n    // strcpy(c1.color, \"Red\"); // Can't use strcpy without string.h\n    \n    printf(\"Circle radius: %.1f\\n\", c1.radius);\n\n    return 0;\n}\n```\n\nStructures are essential for creating complex, organized data types that mirror real-world entities, forming the basis for more advanced data structures like linked lists and trees.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <string.h>\n\n// Define a structure for a Book\nstruct Book {\n    char title[100];\n    char author[50];\n    int pages;\n    double price;\n};\n\nint main() {\n    // Declare and initialize a Book variable\n    struct Book myBook = {\"The Great Adventure\", \"John Writer\", 300, 25.99};\n\n    // Print book details\n    printf(\"Book Title: %s\\n\", myBook.title);\n    printf(\"Author: %s\\n\", myBook.author);\n    printf(\"Pages: %d\\n\", myBook.pages);\n    printf(\"Price: $%.2lf\\n\", myBook.price);\n\n    // Create another book and assign values individually\n    struct Book anotherBook;\n    strcpy(anotherBook.title, \"C Programming Basics\");\n    strcpy(anotherBook.author, \"Code Master\");\n    anotherBook.pages = 450;\n    anotherBook.price = 39.95;\n\n    printf(\"\\nAnother Book Title: %s\\n\", anotherBook.title);\n\n    return 0;\n}",
            "description": "Defines a `Book` structure to store book information and demonstrates initializing and accessing its members."
          }
        ]
      },
      {
        "id": "c-unions",
        "title": "C Unions",
        "description": "Understand unions: a special data type where all members share the same memory location.",
        "content": "A **union** in C is a special user-defined data type that allows you to store different data types in the *same memory location*. Unlike structures, where each member has its own distinct memory, all members of a union share the same memory space. This means a union can hold *only one* of its members' values at any given time.\n\n### Theoretical Aspects of Unions:\n\n* **Memory Sharing:** The size of a union is determined by the size of its largest member. All members are stored starting at the same memory address within that allocated space.\n* **Single Active Member:** You can only use one member of a union at a time. If you assign a value to one member, and then assign a value to another, the previous member's value will be overwritten.\n* **Purpose:** Unions are primarily used for memory optimization in specific scenarios where you know that only one piece of information (of different possible types) will be needed at any given moment for a particular object.\n\n### Declaring and Using a Union:\n\n* The syntax for declaring a union is similar to a structure, but with the `union` keyword.\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Declare a union named 'Data'\nunion Data {\n    int i;       // Integer member\n    float f;     // Float member\n    char str[20]; // Character array (string) member\n};\n\nint main() {\n    union Data data; // Declare a union variable\n\n    printf(\"Size of union Data: %zu bytes (size of its largest member, str[20])\\n\", sizeof(data));\n\n    // 1. Assign value to integer member 'i'\n    data.i = 10; \n    printf(\"Data.i: %d\\n\", data.i); // Output: Data.i: 10\n    printf(\"Data.f: %f (Garbage or 0.0 because 'i' overwrites 'f')\\n\", data.f); // Undefined behavior if accessed after 'i' assigned\n\n    // 2. Assign value to float member 'f' (this overwrites 'i')\n    data.f = 22.5f;\n    printf(\"Data.f: %f\\n\", data.f); // Output: Data.f: 22.500000\n    printf(\"Data.i: %d (Garbage because 'f' overwrites 'i')\\n\", data.i); // Undefined behavior\n\n    // 3. Assign value to string member 'str' (this overwrites 'f')\n    strcpy(data.str, \"Hello Union\");\n    printf(\"Data.str: %s\\n\", data.str); // Output: Data.str: Hello Union\n    printf(\"Data.i: %d (Garbage because 'str' overwrites 'i')\\n\", data.i); // Undefined behavior\n    printf(\"Data.f: %f (Garbage because 'str' overwrites 'f')\\n\", data.f); // Undefined behavior\n\n    return 0;\n}\n```\n\n### `union` vs. `struct` (Key Differences):\n\n| Feature    | `struct`                                | `union`                                   |\n| :--------- | :-------------------------------------- | :---------------------------------------- |\n| **Memory** | Each member has its own memory location | All members share the same memory location|\n| **Size** | Sum of sizes of all members (plus padding) | Size of the largest member                 |\n| **Usage** | All members can hold values simultaneously | Only one member can hold a valid value at a time |\n| **Purpose**| Group related but distinct data         | Memory optimization where only one type is active |\n\n### When to Use Unions:\n\n* **Memory Optimization:** In embedded systems or memory-constrained environments where you need to save space and know that at any given time, only one type of data will be active.\n* **Type Punning:** (Advanced and generally discouraged for portability) To interpret the same memory block as different data types. For example, to inspect the individual bytes of an `int`.\n\n```c\n#include <stdio.h>\n\n// Example of type punning (advanced, use with caution)\nunion IntBytes {\n    int i;\n    char bytes[sizeof(int)]; // Array of chars to view individual bytes\n};\n\nint main() {\n    union IntBytes ib;\n    ib.i = 0x12345678; // Example integer value\n\n    printf(\"Integer: 0x%X\\n\", ib.i);\n    printf(\"Bytes (Hex, depending on endianness):\\n\");\n    for (size_t k = 0; k < sizeof(int); k++) {\n        printf(\"Byte %zu: 0x%02X\\n\", k, (unsigned char)ib.bytes[k]);\n    }\n    return 0;\n}\n```\n\nUnions are a niche but powerful feature in C, allowing for memory-efficient data representation when carefully managed.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <string.h>\n\n// Union for a flexible ID type\nunion ID {\n    int int_id;\n    char string_id[20];\n};\n\nint main() {\n    union ID employeeID;\n\n    // Store an integer ID\n    employeeID.int_id = 12345;\n    printf(\"Integer ID: %d\\n\", employeeID.int_id);\n\n    // Now store a string ID (this overwrites the integer ID)\n    strcpy(employeeID.string_id, \"EMP_A001\");\n    printf(\"String ID: %s\\n\", employeeID.string_id);\n\n    // Accessing int_id now would be undefined behavior/garbage\n    printf(\"Integer ID (after string): %d\\n\", employeeID.int_id); \n\n    return 0;\n}",
            "description": "Defines a union `ID` to demonstrate how its members share memory. Shows overwriting of data when a new member is assigned a value."
          }
        ]
      },
      {
        "id": "c-enums",
        "title": "C Enums",
        "description": "Use enums (enumerations) to define a set of named integer constants for improved readability.",
        "content": "An **enum** (enumeration) in C is a user-defined data type that consists of a set of named integer constants. Enums are primarily used to make code more readable and maintainable by assigning meaningful names to a list of related integer values, rather than using raw numbers.\n\n### Theoretical Aspects of Enums:\n\n* **Symbolic Constants:** Enums provide a way to create symbolic names (identifiers) for a list of integer values.\n* **Integer Representation:** Internally, each enum constant is represented by an integer value. By default, the first enumerator (name) is assigned `0`, the next `1`, and so on.\n* **Readability:** Using enum names (e.g., `MONDAY`) instead of raw numbers (e.g., `1`) makes the code much clearer and less prone to errors.\n\n### Declaring and Using an Enum:\n\n* **Syntax:**\n    ```c\n    enum EnumName {\n        CONSTANT1, // default value 0\n        CONSTANT2, // default value 1\n        // ...\n        CONSTANTN\n    };\n    ```\n\n```c\n#include <stdio.h>\n\n// Declare an enum for days of the week\nenum Day {\n    SUNDAY,    // Default value 0\n    MONDAY,    // Default value 1\n    TUESDAY,   // Default value 2\n    WEDNESDAY, // Default value 3\n    THURSDAY,  // Default value 4\n    FRIDAY,    // Default value 5\n    SATURDAY   // Default value 6\n};\n\nint main() {\n    enum Day today = WEDNESDAY; // Declare an enum variable and assign a constant\n\n    printf(\"Today is day number: %d\\n\", today); // Output: 3\n\n    if (today == WEDNESDAY) {\n        printf(\"It's the middle of the week!\\n\");\n    }\n\n    // You can iterate through enum values (if they are sequential)\n    for (enum Day d = SUNDAY; d <= SATURDAY; d++) {\n        printf(\"Day %d\\n\", d);\n    }\n\n    return 0;\n}\n```\n\n### Assigning Custom Values to Enum Constants:\n\nYou can explicitly assign integer values to enum constants. If you assign a value, subsequent unassigned constants will increment from that value.\n\n```c\n#include <stdio.h>\n\nenum Status {\n    SUCCESS = 100, // Explicitly set to 100\n    FAILURE = 200, // Explicitly set to 200\n    PENDING,       // Automatically 201 (increments from previous)\n    ERROR = -1     // Explicitly set to -1\n};\n\nint main() {\n    enum Status current_status = PENDING;\n    printf(\"Current status code: %d\\n\", current_status); // Output: 201\n\n    current_status = ERROR;\n    printf(\"Error status code: %d\\n\", current_status); // Output: -1\n\n    return 0;\n}\n```\n\n### `typedef` with Enums (Convenience):\n\nSimilar to structures, `typedef` can be used to create an alias for the enum type, making declarations cleaner.\n\n```c\n#include <stdio.h>\n\n// Define an enum and create a typedef alias 'Color'\ntypedef enum Color {\n    RED,\n    GREEN,\n    BLUE\n} Color; // Now 'Color' can be used instead of 'enum Color'\n\nint main() {\n    Color chosen_color = GREEN; // Declare using the typedef alias\n    printf(\"Chosen color code: %d\\n\", chosen_color); // Output: 1\n\n    if (chosen_color == RED) {\n        printf(\"It's red.\\n\");\n    } else {\n        printf(\"It's not red.\\n\");\n    }\n\n    return 0;\n}\n```\n\nEnums are a powerful tool for improving code clarity and reducing the likelihood of errors when working with a fixed set of related integer values.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\n// Define an enum for logging levels\nenum LogLevel {\n    DEBUG,   // 0\n    INFO,    // 1\n    WARN,    // 2\n    ERROR    // 3\n};\n\nvoid log_message(enum LogLevel level, const char *message) {\n    printf(\"[%d] \", level);\n    switch (level) {\n        case DEBUG:\n            printf(\"DEBUG: \");\n            break;\n        case INFO:\n            printf(\"INFO: \");\n            break;\n        case WARN:\n            printf(\"WARNING: \");\n            break;\n        case ERROR:\n            printf(\"ERROR: \");\n            break;\n    }\n    printf(\"%s\\n\", message);\n}\n\nint main() {\n    log_message(INFO, \"User logged in.\");\n    log_message(ERROR, \"Database connection failed.\");\n    log_message(DEBUG, \"Variable X value: 10.\");\n    return 0;\n}",
            "description": "Defines an enum for `LogLevel` and uses it in a logging function to print messages with different severity levels."
          }
        ]
      },
      {
        "id": "c-memory-management",
        "title": "C Memory Management",
        "description": "Dive deeper into how memory is organized in C programs: stack, heap, data, and code segments.",
        "content": "Understanding how memory is managed in C is crucial for writing efficient, robust, and error-free programs. C gives the programmer significant control over memory allocation and deallocation. Memory in a C program is typically divided into several segments:\n\n### Memory Segments (Theory Focus):\n\n1.  **Text Segment (Code Segment):**\n    * Stores the compiled machine code of the program (instructions).\n    * Read-only to prevent accidental modification.\n    * Fixed size during program execution.\n\n2.  **Data Segment:**\n    * Stores global variables and static variables that are explicitly initialized.\n    * Has a fixed size at compile time, but contents can change at runtime.\n\n3.  **BSS Segment (Block Started by Symbol):**\n    * Stores global variables and static variables that are *uninitialized*.\n    * Initialized to zero by the loader before the program starts execution.\n    * Also has a fixed size at compile time.\n\n4.  **Heap Segment (Dynamic Memory):**\n    * Used for **dynamic memory allocation** during program execution (`malloc`, `calloc`, `realloc`).\n    * Memory is allocated and deallocated by the programmer explicitly.\n    * Grows upwards towards the stack.\n    * Memory allocated here persists until explicitly `free`d or the program terminates.\n    * **Memory Leaks:** Occur when dynamically allocated memory is no longer referenced but not deallocated.\n\n5.  **Stack Segment:**\n    * Used for **automatic memory allocation** (local variables, function parameters).\n    * Follows a Last-In, First-Out (LIFO) order: when a function is called, a **stack frame** is pushed onto the stack; when it returns, its stack frame is popped.\n    * Grows downwards towards the heap.\n    * Memory is automatically managed by the compiler (allocated on function entry, deallocated on exit).\n    * **Stack Overflow:** Occurs when the stack runs out of memory, typically due to excessive recursion or large local variables.\n\n```c\n#include <stdio.h>\n#include <stdlib.h> // For malloc and free\n\n// Global variable (Data Segment - initialized, or BSS - uninitialized)\nint global_var = 10; // Initialized, so in Data Segment\nstatic int static_global_var; // Uninitialized static, so in BSS Segment (initialized to 0 by default)\n\nvoid exampleFunction(int param_a) { // param_a is on the Stack\n    int local_var = 20; // local_var is on the Stack\n    static int static_local_var = 0; // static_local_var is in Data Segment (persists across calls)\n    static_local_var++;\n\n    printf(\"\\n--- Inside exampleFunction ---\\n\");\n    printf(\"Param (Stack): %d\\n\", param_a);\n    printf(\"Local Var (Stack): %d\\n\", local_var);\n    printf(\"Static Local Var (Data): %d\\n\", static_local_var);\n}\n\nint main() {\n    printf(\"Global Var (Data): %d\\n\", global_var);\n    printf(\"Static Global Var (BSS): %d\\n\", static_global_var);\n\n    exampleFunction(1); // Call 1\n    exampleFunction(2); // Call 2 (static_local_var increments)\n\n    // Dynamic Memory Allocation (Heap)\n    int *dynamic_array = (int *) malloc(3 * sizeof(int)); // Memory from Heap\n    if (dynamic_array == NULL) {\n        fprintf(stderr, \"Failed to allocate dynamic memory!\\n\");\n        return EXIT_FAILURE;\n    }\n\n    dynamic_array[0] = 100;\n    dynamic_array[1] = 200;\n    dynamic_array[2] = 300;\n\n    printf(\"\\nDynamic Array (Heap): %d, %d, %d\\n\", dynamic_array[0], dynamic_array[1], dynamic_array[2]);\n\n    free(dynamic_array); // Release memory back to Heap\n    dynamic_array = NULL; // Prevent dangling pointer\n    printf(\"Dynamic memory freed.\\n\");\n\n    return EXIT_SUCCESS;\n}\n```\n\nMastering memory management in C is crucial for writing efficient, reliable, and secure applications. It directly impacts program performance and stability.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Global variable: Lives in Data/BSS segment\nint g_count = 0;\n\nvoid increment_local_and_global() {\n    int local_num = 1; // Local variable: Lives on Stack\n    static int static_local_num = 0; // Static local: Lives in Data/BSS segment\n\n    g_count++;\n    local_num++;\n    static_local_num++;\n\n    printf(\"Global: %d, Local: %d, Static Local: %d\\n\", g_count, local_num, static_local_num);\n}\n\nint main() {\n    int *dynamic_int = (int *) malloc(sizeof(int)); // Dynamic memory: Lives on Heap\n    if (dynamic_int == NULL) return 1;\n\n    *dynamic_int = 1000;\n    printf(\"Dynamic int: %d\\n\", *dynamic_int);\n\n    increment_local_and_global(); // Call 1\n    increment_local_and_global(); // Call 2\n    increment_local_and_global(); // Call 3\n\n    free(dynamic_int); // Free Heap memory\n    dynamic_int = NULL;\n\n    return 0;\n}",
            "description": "Illustrates variable placement in different memory segments (global, local, static local, heap) and their lifetimes."
          }
        ]
      },
      {
        "id": "c-errors",
        "title": "C Errors",
        "description": "Identify and understand common types of errors in C programming: syntax, runtime, and logical errors.",
        "content": "In C programming, encountering errors is a normal part of the development process. Understanding different types of errors helps you diagnose and fix problems more effectively. Generally, errors can be categorized into three main types:\n\n### 1. Compile-time Errors (Syntax Errors):\n\n* **When they occur:** During the compilation phase, before the program can even run.\n* **Cause:** These are typically due to violations of C's syntax rules.\n* **Compiler Output:** The compiler will report these errors with specific line numbers and descriptions, preventing the creation of an executable file.\n* **Examples:**\n    * Missing semicolons (` ; `) at the end of statements.\n    * Undeclared variables or functions.\n    * Type mismatches (e.g., assigning a string to an integer).\n    * Mismatched parentheses or curly braces.\n    * Incorrect keywords.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 10\n    printf(\"Value: %d\\n\", x) // Missing semicolon here\n    return 0;\n} // Missing semicolon here (also, main usually needs a return 0;)\n\n// Compiler error output for above (example for GCC):\n// error: expected ';' before 'printf'\n// error: expected ';' before '}' token\n```\n\n### 2. Runtime Errors:\n\n* **When they occur:** During the execution of the program, after it has successfully compiled.\n* **Cause:** These errors happen when the program tries to perform an invalid operation that the compiler couldn't detect (or warn about).\n* **Behavior:** Often cause the program to crash (e.g., segmentation fault), behave unpredictably, or produce incorrect output.\n* **Examples:**\n    * **Division by zero:** Attempting to divide a number by zero.\n    * **Null pointer dereference:** Trying to access memory through a pointer that points to `NULL`.\n    * **Array out-of-bounds access:** Trying to access an array element outside its valid index range.\n    * **Memory leaks:** (Less severe, but still an error) Not freeing dynamically allocated memory, leading to increased memory consumption over time.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int a = 10;\n    int b = 0;\n    // printf(\"Result: %d\\n\", a / b); // Runtime Error: Division by zero\n\n    int *ptr = NULL;\n    // *ptr = 100; // Runtime Error: Null pointer dereference (Segmentation fault)\n\n    int arr[5];\n    // arr[10] = 5; // Runtime Error: Array out of bounds access (can lead to crash or corrupted data)\n\n    return 0;\n}\n```\n\n### 3. Logical Errors:\n\n* **When they occur:** The program compiles and runs without crashing, but it produces incorrect or unexpected results.\n* **Cause:** These are errors in the program's logic or algorithm, meaning the code doesn't do what the programmer intended.\n* **Detection:** Often the hardest to detect, as the compiler offers no help, and the program appears to run normally. Requires careful testing, debugging, and understanding of the problem domain.\n* **Examples:**\n    * Incorrect mathematical formulas.\n    * Wrong loop conditions (off-by-one errors).\n    * Incorrect use of relational or logical operators.\n    * Flawed algorithms for sorting, searching, etc.\n\n```c\n#include <stdio.h>\n\nint main() {\n    // Logical Error Example: Intended to sum numbers from 1 to 5, but condition is wrong\n    int sum = 0;\n    for (int i = 1; i < 5; i++) { // Should be i <= 5 to include 5\n        sum += i;\n    }\n    printf(\"Sum of 1 to 5 (incorrectly): %d\\n\", sum); // Output: 10 (should be 15)\n\n    return 0;\n}\n```\n\nDebugging skills are essential to identify and rectify these types of errors, ensuring your C programs work as intended.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    // Syntax Error example: missing semicolon\n    // int x = 10\n    // printf(\"Missing semicolon.\\n\");\n\n    // Runtime Error example: division by zero\n    // int a = 5, b = 0;\n    // printf(\"Result: %d\\n\", a / b);\n\n    // Logical Error example: calculating average incorrectly\n    int total_score = 100;\n    int num_subjects = 3;\n    // int average = total_score / num_subjects; // Integer division will truncate\n    // To fix: use float for average\n    float average = (float)total_score / num_subjects;\n    printf(\"Calculated Average: %.2f\\n\", average);\n\n    return 0;\n}",
            "description": "Illustrates examples of syntax errors (commented out), runtime errors (commented out), and a common logical error (integer division when float is needed) with its correction."
          }
        ]
      },
      {
        "id": "c-debugging",
        "title": "C Debugging",
        "description": "Learn basic debugging techniques and tools to find and fix errors in your C programs.",
        "content": "Debugging is the process of identifying, analyzing, and removing errors (bugs) from computer programs. It's an indispensable skill for any programmer. While C compilers provide helpful error messages for syntax issues, logical and runtime errors often require more sophisticated debugging techniques.\n\n### Common Debugging Techniques:\n\n1.  **Print Statements (`printf()` Debugging):**\n    * The simplest and most common debugging technique. You insert `printf()` statements at strategic points in your code to display the values of variables, confirm execution flow, and pinpoint where unexpected behavior occurs.\n    * **Pros:** Easy to use, no special tools needed.\n    * **Cons:** Can be tedious to add and remove, clutters code, less efficient for complex issues.\n\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        int a = 5;\n        int b = 10;\n        printf(\"DEBUG: Before calculation, a = %d, b = %d\\n\", a, b); // Debug print\n        \n        int sum = a + b;\n        printf(\"DEBUG: After calculation, sum = %d\\n\", sum); // Debug print\n        \n        // Simulate a logical error\n        // if (sum == 16) { // This condition is wrong if sum should be 15\n        //    printf(\"Logic path entered.\\n\");\n        // }\n\n        printf(\"Final sum: %d\\n\", sum);\n        return 0;\n    }\n    ```\n\n2.  **Using a Debugger (e.g., GDB - GNU Debugger):**\n    * A debugger is a powerful tool that allows you to execute your program step-by-step, inspect variable values at any point, set breakpoints, and trace execution flow.\n    * **Pros:** Highly effective for complex bugs, provides deep insight into program state.\n    * **Cons:** Steeper learning curve than `printf()` debugging, requires compiler flags for debug symbols.\n\n    ### Basic GDB Commands (for `gcc`):\n    1.  **Compile with debug symbols:** `gcc -g your_program.c -o your_program` (The `-g` flag is crucial!)\n    2.  **Start GDB:** `gdb ./your_program`\n    3.  **Set Breakpoint:** `b main` (set breakpoint at `main` function) or `b your_program.c:10` (at line 10).\n    4.  **Run:** `run` (start program execution)\n    5.  **Next Line:** `n` (execute next line, stepping over function calls)\n    6.  **Step Into:** `s` (execute next line, stepping into function calls)\n    7.  **Print Variable:** `p variable_name` (print value of variable)\n    8.  **Continue:** `c` (continue execution until next breakpoint or program end)\n    9.  **Quit:** `q` (exit GDB)\n\n    *(Example GDB session commands - not C code)*\n    ```bash\n    # Compile with debug info\n    gcc -g main.c -o myapp\n\n    # Start debugger\n    gdb ./myapp\n\n    # Inside gdb:\n    (gdb) b main\n    Breakpoint 1 at 0x12345: file main.c, line 5.\n    (gdb) run\n    Starting program: /path/to/myapp \n\n    Breakpoint 1, main () at main.c:5\n    5           int a = 5;\n    (gdb) n\n    6           int b = 10;\n    (gdb) p a\n    $1 = 5\n    (gdb) n\n    7           int sum = a + b;\n    (gdb) p b\n    $2 = 10\n    (gdb) n\n    8           printf(\"Final sum: %d\\n\", sum);\n    (gdb) p sum\n    $3 = 15\n    (gdb) c\n    Final sum: 15\n    [Inferior 1 (process 12345) exited normally]\n    (gdb) q\n    ```\n\n3.  **Code Review:** Having another programmer review your code can often catch logical errors you might have overlooked.\n\nDebugging is an iterative process of observing, hypothesizing, testing, and fixing. Mastering a debugger like GDB will significantly improve your efficiency in finding and resolving complex issues.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\n// Function with a potential bug for demonstration\nint calculate_average(int total, int count) {\n    // Logical error: If 'count' is 0, this will cause division by zero (runtime error)\n    // Even if count is not 0, integer division might truncate result if not cast to float\n    return total / count; \n}\n\nint main() {\n    int sum = 95;\n    int num_items = 0; // This will cause a runtime error\n    // int num_items = 3; // To test logical error (average will be 31, not 31.66)\n\n    // Debugging with printf:\n    printf(\"DEBUG: sum = %d, num_items = %d\\n\", sum, num_items);\n\n    // int avg = calculate_average(sum, num_items); // Uncomment to see runtime error\n    // printf(\"DEBUG: Average = %d\\n\", avg);\n\n    // Corrected logic (using float to prevent truncation)\n    float correct_avg = (float)sum / num_items; // Will still crash if num_items is 0\n    if (num_items > 0) {\n        printf(\"Corrected Average: %.2f\\n\", correct_avg);\n    } else {\n        printf(\"Cannot calculate average: number of items is zero.\\n\");\n    }\n    \n    return 0;\n}",
            "description": "Demonstrates `printf` debugging and identifies potential runtime (division by zero) and logical (integer truncation) errors in a simple average calculation function. It also shows a corrected version to handle division by zero."
          }
        ]
      },
      {
        "id": "c-input-validation",
        "title": "C Input Validation",
        "description": "Ensure robust programs by validating user input to prevent errors and vulnerabilities.",
        "content": "Input validation is the process of ensuring that user input (or any external input) conforms to expected formats, ranges, and types before it is processed by the program. It is a critical security and robustness practice, as invalid input can lead to program crashes, unexpected behavior, security vulnerabilities (like buffer overflows), and incorrect results.\n\n### Why is Input Validation Important?\n\n* **Prevent Crashes:** Avoid runtime errors (e.g., division by zero, null pointer dereference) caused by unexpected input.\n* **Security:** Guard against malicious input (e.g., buffer overflows, injection attacks).\n* **Correctness:** Ensure the program operates on valid data, leading to accurate results.\n* **User Experience:** Provide clear feedback to the user when input is incorrect.\n\n### Common Input Validation Scenarios:\n\n1.  **Checking Return Values of `scanf()`:**\n    * `scanf()` returns the number of items successfully read. You should always check this value.\n\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        int age;\n        printf(\"Enter your age (integer): \");\n        int num_read = scanf(\"%d\", &age);\n\n        if (num_read == 1) {\n            printf(\"You entered age: %d\\n\", age);\n        }\n        else {\n            printf(\"Invalid input. Please enter a valid integer for age.\\n\");\n            // Clear input buffer to avoid infinite loop on subsequent reads\n            while (getchar() != '\\n'); \n        }\n        return 0;\n    }\n    ```\n\n2.  **Validating Numeric Ranges:**\n    * Ensure numeric input falls within acceptable minimum and maximum values.\n\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        int score;\n        printf(\"Enter a score (0-100): \");\n        if (scanf(\"%d\", &score) == 1) {\n            if (score >= 0 && score <= 100) {\n                printf(\"Valid score: %d\\n\", score);\n            } else {\n                printf(\"Invalid score: Must be between 0 and 100.\\n\");\n            }\n        } else {\n            printf(\"Invalid input type for score.\\n\");\n            while (getchar() != '\\n');\n        }\n        return 0;\n    }\n    ```\n\n3.  **Validating Strings (Length, Content):**\n    * When using `scanf(\"%s\")`, consider specifying a maximum width to prevent buffer overflows (e.g., `scanf(\"%19s\", name);` for a `char name[20];`).\n    * For robust string input, `fgets()` is generally preferred as it allows reading an entire line and specifying buffer size.\n    * After reading a string, you might use functions from `<string.h>` (e.g., `strlen`) or `<ctype.h>` (e.g., `isalpha`, `isdigit`) to validate its content.\n\n    ```c\n    #include <stdio.h>\n    #include <string.h>\n    #include <ctype.h> // For isdigit\n\n    int main() {\n        char password[20];\n        printf(\"Enter password (max 19 chars, at least 6): \");\n        if (fgets(password, sizeof(password), stdin) != NULL) {\n            // Remove trailing newline character if fgets read it\n            password[strcspn(password, \"\\n\")] = 0; \n\n            if (strlen(password) >= 6 && strlen(password) < sizeof(password)) {\n                printf(\"Password accepted.\\n\");\n            } else {\n                printf(\"Password too short or too long.\\n\");\n            }\n        } else {\n            printf(\"Error reading password.\\n\");\n        }\n        return 0;\n    }\n    ```\n\n4.  **Looping for Valid Input:**\n    * Often, you'll put input reading and validation inside a loop that continues until valid input is provided.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int age;\n    int valid_input = 0;\n\n    while (!valid_input) {\n        printf(\"Enter your age (integer > 0): \");\n        if (scanf(\"%d\", &age) == 1) {\n            if (age > 0) {\n                valid_input = 1; // Input is valid, exit loop\n            } else {\n                printf(\"Age must be a positive number.\\n\");\n            }\n        } else {\n            printf(\"Invalid input. Please enter a number.\\n\");\n            // Clear buffer: consume remaining characters including newline\n            while (getchar() != '\\n'); \n        }\n    }\n    printf(\"Your age is: %d\\n\", age);\n    return 0;\n}\n```\n\nImplementing robust input validation is a cornerstone of writing reliable and secure C applications.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int choice;\n    int validInput = 0;\n\n    while (!validInput) {\n        printf(\"Choose an option (1-3): \");\n        if (scanf(\"%d\", &choice) == 1) { // Check if an integer was read\n            if (choice >= 1 && choice <= 3) {\n                validInput = 1; // Input is valid\n            } else {\n                printf(\"Invalid option. Please choose between 1 and 3.\\n\");\n            }\n        } else {\n            printf(\"Invalid input. Please enter a number.\\n\");\n            // Clear input buffer: consume invalid characters and newline\n            while (getchar() != '\\n'); \n        }\n    }\n\n    printf(\"You selected option: %d\\n\", choice);\n    return 0;\n}",
            "description": "Prompts the user to choose an option (1-3) and uses a `while` loop with `scanf` and input buffer clearing to ensure valid integer input within the specified range."
          }
        ]
      },
      {
        "id": "c-macros",
        "title": "C Macros",
        "description": "Learn to use preprocessor macros (`#define`) for text substitution and conditional compilation.",
        "content": "In C, **macros** are simple textual replacements performed by the preprocessor *before* the actual compilation process begins. They are defined using the `#define` directive. Macros are a powerful but sometimes tricky feature, primarily used for defining constants, creating short functions, or for conditional compilation.\n\n### 1. Object-like Macros (Symbolic Constants):\n\n* These are simple substitutions of an identifier with a replacement string (value). We covered this briefly in the \"C Constants\" lesson.\n* By convention, macro names are typically written in `UPPERCASE`.\n\n```c\n#include <stdio.h>\n\n#define PI 3.1415926535\n#define MAX_BUFFER_SIZE 1024\n#define AUTHOR_NAME \"John Doe\"\n\nint main() {\n    printf(\"Value of PI: %.10f\\n\", PI);\n    printf(\"Buffer size: %d bytes\\n\", MAX_BUFFER_SIZE);\n    printf(\"Author: %s\\n\", AUTHOR_NAME);\n    return 0;\n}\n```\n\n### 2. Function-like Macros:\n\n* These macros take arguments, mimicking the syntax of a function call. The preprocessor replaces the macro call with the substituted text, including the arguments.\n* **Caution:** Due to simple text substitution, function-like macros can lead to unexpected behavior if not written carefully (e.g., problems with operator precedence, multiple evaluations of arguments).\n* **Best Practice:** Always enclose macro arguments in parentheses to prevent precedence issues.\n\n```c\n#include <stdio.h>\n\n// GOOD macro: Arguments are parenthesized to avoid precedence issues\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n// BAD macro example (illustrating issues without parentheses):\n// #define MULTIPLY(x, y) x * y\n// If you use MULTIPLY(a + b, c), it becomes a + b * c, not (a+b)*c\n\nint main() {\n    int x = 10, y = 20;\n    int result = MAX(x, y);\n    printf(\"Max of %d and %d is: %d\\n\", x, y, result); // Output: 20\n\n    // Caution with side effects: Arguments are evaluated multiple times\n    int val = 5;\n    int res_side_effect = MAX(val++, 10); // val++ is evaluated twice!\n                                        // Becomes ((val++) > (10) ? (val++) : (10))\n    printf(\"Result with side effect: %d (val becomes %d)\\n\", res_side_effect, val); \n    // Output might be 10 (val becomes 7) if val++ evaluated before comparison, and then again for return.\n    // Or it might be 10 (val becomes 6) if the branch chosen is '10'\n    // This is why functions are generally preferred for complex logic.\n\n    return 0;\n}\n```\n\n### 3. Conditional Compilation Directives:\n\n* Macros are also used with preprocessor directives like `#ifdef`, `#ifndef`, `#if`, `#else`, `#endif` to conditionally include or exclude blocks of code during compilation.\n* This is very useful for platform-specific code, debugging code, or creating different versions of a program from the same source.\n\n```c\n#include <stdio.h>\n\n#define DEBUG_MODE // Define this macro to enable debug features\n\nint main() {\n    printf(\"Starting program.\\n\");\n\n    #ifdef DEBUG_MODE // If DEBUG_MODE is defined\n        printf(\"DEBUG: Debug mode is active.\\n\");\n        // Additional debug code goes here\n    #else\n        printf(\"Release mode.\\n\");\n    #endif\n\n    printf(\"Program finished.\\n\");\n    return 0;\n}\n```\n\n### Pros and Cons of Macros:\n\n* **Pros:**\n    * Faster than functions for very small operations (no function call overhead).\n    * Can perform text substitution that functions cannot (e.g., for conditional compilation).\n    * Used for defining constant values.\n* **Cons:**\n    * **Lack of Type Safety:** Preprocessor doesn't check types, leading to subtle bugs.\n    * **Side Effects:** Arguments with side effects can be evaluated multiple times, leading to unexpected results.\n    * **Debugging Difficulty:** Debuggers often see the substituted code, not the macro itself, making debugging harder.\n    * **Code Expansion:** Can lead to larger executable sizes if a macro is used many times (code bloat).\n\nFor most cases where simple logic or type checking is important, C functions or `const` variables are generally preferred over macros. Macros are best reserved for symbolic constants and conditional compilation.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\n#define ARRAY_COUNT 5\n#define SQUARE(x) ((x) * (x))\n\nint main() {\n    int numbers[ARRAY_COUNT]; // ARRAY_COUNT is replaced by 5\n    for (int i = 0; i < ARRAY_COUNT; i++) {\n        numbers[i] = i + 1;\n    }\n    printf(\"First element squared: %d\\n\", SQUARE(numbers[0])); // (1) * (1) = 1\n    printf(\"Second element squared: %d\\n\", SQUARE(numbers[1])); // (2) * (2) = 4\n\n    #ifdef DEBUG\n        printf(\"DEBUG: This message is only compiled in debug mode.\\n\");\n    #endif\n\n    return 0;\n}",
            "description": "Demonstrates an object-like macro for array size, a function-like macro for squaring a number (with parentheses for safety), and conditional compilation using `#ifdef`."
          }
        ]
      },
      {
        "id": "c-projects",
        "title": "C Projects",
        "description": "Overview of C project structure and building simple applications.",
        "content": "Developing real-world C applications involves more than just writing single `.c` files. Projects often consist of multiple source files, header files, and external libraries, all of which need to be compiled and linked together. Understanding a basic project structure and the compilation process is key for larger, more organized C development.\n\n### 1. Basic Project Structure (Theory Focus):\n\nA typical small to medium C project might have a structure like this:\n\n```\nmy_c_project/\n├── src/                # Source files (.c) where function implementations reside\n│   ├── main.c          # Contains the main() function (program entry point)\n│   └── utils.c         # Contains utility functions (e.g., math, string ops)\n├── include/            # Header files (.h) containing function declarations, struct definitions, macros\n│   └── utils.h         # Declarations for functions in utils.c\n├── bin/                # (Optional) Directory for compiled executables\n├── obj/                # (Optional) Directory for intermediate object files (.o)\n├── Makefile            # (Optional, but highly recommended) For automating compilation\n└── README.md           # Project description\n```\n\n* **`.c` files (Source files):** Contain the actual code logic and function definitions.\n* **`.h` files (Header files):** Contain function prototypes, structure declarations, enum definitions, and macros. They act as interfaces, telling other source files what's available.\n\n### 2. The Compilation Process (Multi-file):\n\nWhen you have multiple `.c` files, the compilation process involves several steps, usually handled by a build tool or by explicitly calling the compiler:\n\n1.  **Preprocessing (`cpp`):** Handles directives like `#include` (copy-pasting content of header files) and macro (`#define`) substitutions.\n2.  **Compilation (`cc1`):** Translates preprocessed C code into assembly code.\n3.  **Assembly (`as`):** Converts assembly code into machine code (object files with `.o` extension).\n4.  **Linking (`ld`):** Combines all object files and required library code into a single executable file.\n\n**Example Manual Compilation (Linux/macOS):**\n\n* `main.c`:\n    ```c\n    #include <stdio.h>\n    #include \"utils.h\"\n\n    int main() {\n        printf(\"Welcome to my C project!\\n\");\n        printMessage(\"This message is from utils.c!\");\n        int sum = add(5, 7);\n        printf(\"Sum of 5 and 7: %d\\n\", sum);\n        return 0;\n    }\n    ```\n\n* `utils.h` (in `include/`):\n    ```c\n    #ifndef UTILS_H\n    #define UTILS_H\n\n    // Function prototypes\n    void printMessage(const char *msg);\n    int add(int a, int b);\n\n    #endif // UTILS_H\n    ```\n\n* `utils.c` (in `src/`):\n    ```c\n    #include <stdio.h>\n    #include \"utils.h\" // Include its own header for consistency and checks\n\n    void printMessage(const char *msg) {\n        printf(\"UTIL_MSG: %s\\n\", msg);\n    }\n\n    int add(int a, int b) {\n        return a + b;\n    }\n    ```\n\n**Compilation Steps:**\n\n```bash\n# Step 1: Compile each .c file into an object file (.o)\n# -Iinclude tells the compiler to look for headers in the 'include' directory\n# -c tells the compiler to compile only, not link\ngcc -c src/main.c -Iinclude -o obj/main.o\ngcc -c src/utils.c -Iinclude -o obj/utils.o\n\n# Step 2: Link all object files into a single executable\ngcc obj/main.o obj/utils.o -o bin/myproject\n\n# Step 3: Run the executable\n./bin/myproject\n```\n\n### 3. Using Makefiles (Automation):\n\nFor projects with many files, manually compiling is tedious. **Makefiles** automate this process. A `Makefile` defines rules for building targets (like executables) from sources.\n\n```makefile\n# Makefile Example\nCC = gcc             # C compiler to use\nCFLAGS = -Wall -g -Iinclude # Compiler flags: -Wall (all warnings), -g (debug info), -Iinclude (include path)\nLDFLAGS =            # Linker flags\n\nSRCDIR = src\nOBJDIR = obj\nBINDIR = bin\n\nSOURCES = $(wildcard $(SRCDIR)/*.c) # Finds all .c files in src/\nOBJECTS = $(patsubst $(SRCDIR)/%.c,$(OBJDIR)/%.o,$(SOURCES)) # Changes .c to .o and src/ to obj/\nTARGET = $(BINDIR)/myproject\n\n# Rule to create directories if they don't exist\n.PHONY: all clean dirs\nall: dirs $(TARGET)\n\ndirs:\n\t@mkdir -p $(OBJDIR) $(BINDIR)\n\n$(TARGET): $(OBJECTS)\n\t$(CC) $(OBJECTS) -o $@ $(LDFLAGS)\n\n$(OBJDIR)/%.o: $(SRCDIR)/%.c $(wildIRDIR)/%.h # Dependencies: .c file and any .h in include/\n\t$(CC) $(CFLAGS) -c $< -o $@\n\nclean:\n\t@rm -rf $(OBJDIR) $(BINDIR)\n\n```\n\nTo build with `make`, just type `make` in the terminal where the `Makefile` is. To clean compiled files, type `make clean`.\n\nOrganizing your C code into projects and using build tools is crucial for scalability and effective team collaboration.",
        "codeExamples": []
      },
      {
        "id": "c-reference",
        "title": "C Reference",
        "description": "An overview of C language specifications, standard libraries, and essential resources.",
        "content": "The C programming language has a rich set of features and a well-defined standard. A 'C Reference' typically refers to documentation that details the language's syntax, keywords, standard library functions, and other specifications. It's an invaluable resource for looking up specific functionalities, understanding behavior, and ensuring portability across different compilers and platforms.\n\n### Key Areas of C Reference:\n\n1.  **Language Keywords:** Reserved words with special meanings (e.g., `if`, `else`, `while`, `int`, `void`, `return`).\n2.  **Operators:** Symbols used to perform operations (e.g., `+`, `-`, `*`, `/`, `==`, `&&`, `&`).\n3.  **Data Types:** Built-in and user-defined types (e.g., `int`, `float`, `char`, `struct`, `union`, `enum`).\n4.  **Preprocessor Directives:** Commands processed before compilation (e.g., `#include`, `#define`, `#ifdef`).\n5.  **Standard Libraries:** Collections of pre-written functions for common tasks.\n    * `<stdio.h>`: Standard Input/Output (e.g., `printf`, `scanf`, file operations).\n    * `<stdlib.h>`: Standard Utility Functions (e.g., memory allocation, string conversions).\n    * `<string.h>`: String Manipulation Functions (e.g., `strcpy`, `strlen`, `strcmp`).\n    * `<math.h>`: Mathematical Functions (e.g., `sqrt`, `pow`, `sin`).\n    * `<ctype.h>`: Character Type Functions (e.g., `isalpha`, `isdigit`, `tolower`).\n    * `<time.h>`: Time and Date Functions.\n    * `<limits.h>`: Integer type limits.\n    * `<float.h>`: Floating-point type limits.\n\n### Importance of Reference Materials:\n\n* **Accuracy:** Provides definitive information on how language features and library functions are supposed to behave.\n* **Portability:** Helps write code that works consistently across different systems and compilers by adhering to standard specifications.\n* **Debugging:** Understanding precise function behavior helps in diagnosing issues.\n* **Learning:** A good reference allows you to quickly look up syntax, arguments, and return values for functions you're learning or using.\n\nWhile this tutorial covers many essential aspects, the detailed C reference is often your go-to resource for specifics. Online resources like cppreference.com or cplusplus.com (which also covers C) are excellent choices for looking up C standard library functions.\n\nIn the following lessons, we will briefly touch upon some of the most commonly used standard library headers to provide you with a quick reference.",
        "codeExamples": []
      },
      {
        "id": "c-keywords",
        "title": "C Keywords",
        "description": "A list and explanation of reserved words in C with special meanings.",
        "content": "Keywords are reserved words in C that have predefined meanings and cannot be used as identifiers (like variable names, function names, etc.). They are integral to the C language syntax and control its operations.\n\nC has a relatively small set of keywords, which expanded slightly with C99 and C11 standards. Here's a list of standard C keywords (from C99 and C11 where applicable, but focusing on most common):\n\n### Common Keyword Explanations:\n\n* **`auto`**: Default storage class for local variables, meaning they are created on entry to a block and destroyed on exit.\n* **`break`**: Used to exit `switch` statements or loops (`for`, `while`, `do-while`).\n* **`case`**: Used within `switch` statements to define specific values to match.\n* **`char`**: Data type for a single character.\n* **`const`**: Declares a variable as constant (read-only).\n* **`continue`**: Skips the rest of the current iteration of a loop and proceeds to the next iteration.\n* **`default`**: Used within `switch` statements to specify code to execute if no `case` matches.\n* **`do`**: Used to define a `do-while` loop (executes at least once).\n* **`double`**: Data type for double-precision floating-point numbers.\n* **`else`**: Used with `if` to provide an alternative code block.\n* **`enum`**: Declares an enumeration type.\n* **`extern`**: Declares a variable or function that is defined in another source file.\n* **`float`**: Data type for single-precision floating-point numbers.\n* **`for`**: Used to define a `for` loop.\n* **`goto`**: Unconditionally transfers control to a labeled statement (use sparingly, often makes code hard to read).\n* **`if`**: Used for conditional execution.\n* **`int`**: Data type for integer numbers.\n* **`long`**: A type modifier that typically provides extended range for integer or floating-point types.\n* **`register`**: A hint to the compiler to store a variable in a CPU register for faster access.\n* **`return`**: Used to exit a function and optionally return a value.\n* **`short`**: A type modifier that typically provides reduced range for integer types.\n* **`signed`**: A type modifier indicating that a numeric type can hold positive and negative values (default for `int`, `short`, `long`).\n* **`sizeof`**: An operator that returns the size of a type or variable in bytes.\n* **`static`**: Declares a variable or function with static storage duration (persists throughout program execution) or internal linkage (visible only within its file).\n* **`struct`**: Declares a structure data type.\n* **`switch`**: Used for multi-way branching.\n* **`typedef`**: Creates an alias (new name) for an existing data type.\n* **`union`**: Declares a union data type.\n* **`unsigned`**: A type modifier indicating that a numeric type can only hold non-negative values.\n* **`void`**: Indicates no type, no return value for a function, or a generic pointer.\n* **`volatile`**: A type qualifier suggesting that a variable's value may change unexpectedly (e.g., by hardware).\n* **`while`**: Used to define a `while` loop.\n\nUnderstanding these keywords is fundamental to writing correct C code, as they form the core vocabulary of the language.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nconst int MAX_VALUE = 100;\n\nint main() {\n    int counter = 0;\n    for (int i = 0; i < 5; i++) {\n        if (i == 3) {\n            continue; // Skip this iteration\n        }\n        counter++;\n    }\n    printf(\"Counter: %d\\n\", counter); // Output: 4 (skipped i=3)\n    printf(\"Max Value: %d\\n\", MAX_VALUE);\n    return 0;\n}",
            "description": "Demonstrates the use of `const`, `int`, `for`, `if`, `continue`, `printf`, and `return` keywords."
          }
        ]
      },
      {
        "id": "c-stdio",
        "title": "C `<stdio.h>` Reference",
        "description": "Commonly used functions from the Standard Input/Output library (`stdio.h`).",
        "content": "The `<stdio.h>` header file (Standard Input/Output) is one of the most frequently used standard libraries in C. It provides a wide range of functions for performing input and output operations, both to the console and to files.\n\n### Key Functions in `<stdio.h>`:\n\n1.  **Console I/O:**\n    * `printf(const char *format, ...)`:\n        * **Purpose:** Prints formatted output to the standard output (console).\n        * **Example:** `printf(\"Hello %s, your age is %d.\\n\", \"Alice\", 30);`\n    * `scanf(const char *format, ...)`:\n        * **Purpose:** Reads formatted input from the standard input (keyboard).\n        * **Example:** `scanf(\"%d %s\", &age, name);` (Note the `&` for `int`, not for array name).\n    * `getchar()`:\n        * **Purpose:** Reads a single character from the standard input.\n        * **Example:** `char ch = getchar();`\n    * `putchar(int char_val)`:\n        * **Purpose:** Writes a single character to the standard output.\n        * **Example:** `putchar('A');`\n    * `gets(char *str)`: **(DANGEROUS - AVOID)**\n        * **Purpose:** Reads a line from stdin into `str` until newline or EOF. No buffer overflow protection.\n    * `puts(const char *str)`:\n        * **Purpose:** Writes a string to standard output, followed by a newline.\n        * **Example:** `puts(\"Hello, world!\");`\n\n2.  **File I/O:**\n    * `fopen(const char *filename, const char *mode)`:\n        * **Purpose:** Opens a file and returns a `FILE*` pointer. Returns `NULL` on failure.\n        * **Example:** `FILE *fp = fopen(\"data.txt\", \"r\");`\n    * `fclose(FILE *fp)`:\n        * **Purpose:** Closes an opened file stream. Returns 0 on success, `EOF` on error.\n        * **Example:** `fclose(fp);`\n    * `fprintf(FILE *fp, const char *format, ...)`:\n        * **Purpose:** Prints formatted output to a file.\n        * **Example:** `fprintf(fp, \"Logged value: %d\\n\", value);`\n    * `fscanf(FILE *fp, const char *format, ...)`:\n        * **Purpose:** Reads formatted input from a file.\n        * **Example:** `fscanf(fp, \"%s %d\", name, &id);`\n    * `fgetc(FILE *fp)`:\n        * **Purpose:** Reads a single character from a file. Returns `EOF` on end of file or error.\n        * **Example:** `char ch = fgetc(fp);`\n    * `fputc(int char_val, FILE *fp)`:\n        * **Purpose:** Writes a single character to a file. Returns the character written or `EOF` on error.\n        * **Example:** `fputc('A', fp);`\n    * `fgets(char *str, int size, FILE *fp)`:\n        * **Purpose:** Reads a line from a file into `str` (up to `size-1` characters or until newline/EOF). Includes newline if present.\n        * **Example:** `fgets(line_buffer, sizeof(line_buffer), fp);`\n    * `fputs(const char *str, FILE *fp)`:\n        * **Purpose:** Writes a string to a file. Does not append a newline.\n        * **Example:** `fputs(\"This is a line.\\n\", fp);`\n    * `feof(FILE *fp)`:\n        * **Purpose:** Checks if the end-of-file indicator is set for the stream. Returns non-zero if true.\n    * `ferror(FILE *fp)`:\n        * **Purpose:** Checks if the error indicator is set for the stream. Returns non-zero if true.\n\n### Standard Streams:\n\n`stdio.h` defines three standard file pointers, which are automatically opened when a program starts:\n\n* `stdin`: Standard input stream (usually keyboard).\n* `stdout`: Standard output stream (usually console).\n* `stderr`: Standard error stream (usually console, for error messages).\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    printf(\"Using printf to console.\\n\");\n    fputs(\"Using fputs to console (stdout).\\n\", stdout);\n\n    // File operations example\n    FILE *log_file = fopen(\"log.txt\", \"a\");\n    if (log_file == NULL) {\n        fprintf(stderr, \"Error opening log file!\\n\"); // Print error to stderr\n        return EXIT_FAILURE;\n    }\n\n    fprintf(log_file, \"Application started at %s %s\\n\", __DATE__, __TIME__);\n    fclose(log_file);\n    printf(\"Log message written to log.txt\\n\");\n\n    return EXIT_SUCCESS;\n}\n```\n\n`<stdio.h>` is essential for almost any C program that interacts with the user or files.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n\nint main() {\n    char name[20];\n    int id;\n    FILE *data_file;\n\n    // Write to a file\n    data_file = fopen(\"users.txt\", \"w\");\n    if (data_file) {\n        fprintf(data_file, \"John 101\\n\");\n        fprintf(data_file, \"Jane 102\\n\");\n        fclose(data_file);\n        printf(\"Data written to users.txt\\n\");\n    }\n\n    // Read from the file\n    data_file = fopen(\"users.txt\", \"r\");\n    if (data_file) {\n        printf(\"Reading from users.txt:\\n\");\n        while (fscanf(data_file, \"%s %d\", name, &id) == 2) {\n            printf(\"Name: %s, ID: %d\\n\", name, id);\n        }\n        fclose(data_file);\n    }\n    return 0;\n}",
            "description": "Demonstrates writing formatted data to a file using `fprintf` and reading it back using `fscanf`."
          }
        ]
      },
      {
        "id": "c-stdlib",
        "title": "C `<stdlib.h>` Reference",
        "description": "Commonly used general-purpose utility functions from the Standard Library (`stdlib.h`).",
        "content": "The `<stdlib.h>` header file (Standard Library) provides general-purpose utility functions, including dynamic memory management, string conversion, random number generation, environment control, and more. It's a vital header for many common programming tasks in C.\n\n### Key Functions in `<stdlib.h>`:\n\n1.  **Memory Management:**\n    * `void *malloc(size_t size)`:\n        * **Purpose:** Allocates `size` bytes of uninitialized memory from the heap. Returns `NULL` on failure.\n        * **Example:** `int *arr = (int *) malloc(5 * sizeof(int));`\n    * `void *calloc(size_t num, size_t size)`:\n        * **Purpose:** Allocates memory for `num` elements, each of `size` bytes, and initializes all bytes to zero. Returns `NULL` on failure.\n        * **Example:** `float *f_arr = (float *) calloc(10, sizeof(float));`\n    * `void *realloc(void *ptr, size_t size)`:\n        * **Purpose:** Resizes the memory block pointed to by `ptr` to `size` bytes. Returns `NULL` on failure.\n        * **Example:** `arr = (int *) realloc(arr, 10 * sizeof(int));`\n    * `void free(void *ptr)`:\n        * **Purpose:** Deallocates the memory block pointed to by `ptr`, returning it to the heap. `ptr` should be a pointer previously returned by `malloc`, `calloc`, or `realloc`.\n        * **Example:** `free(arr); arr = NULL;`\n\n2.  **String Conversion (ASCII to Numeric):**\n    * `int atoi(const char *str)`:\n        * **Purpose:** Converts a string to an integer.\n        * **Example:** `int num = atoi(\"123\");`\n    * `long atol(const char *str)`:\n        * **Purpose:** Converts a string to a long integer.\n    * `long long atoll(const char *str)`:\n        * **Purpose:** Converts a string to a long long integer.\n    * `double atof(const char *str)`:\n        * **Purpose:** Converts a string to a double-precision floating-point number.\n        * **Example:** `double val = atof(\"3.14\");`\n    * `long strtol(const char *str, char **endptr, int base)`:\n        * **Purpose:** Converts a string to a long integer with more robust error handling and base specification.\n    * `double strtod(const char *str, char **endptr)`:\n        * **Purpose:** Converts a string to a double with more robust error handling.\n\n3.  **Random Number Generation:**\n    * `int rand(void)`:\n        * **Purpose:** Generates a pseudo-random integer between 0 and `RAND_MAX`.\n        * **Note:** `RAND_MAX` is a macro defined in `stdlib.h`.\n    * `void srand(unsigned int seed)`:\n        * **Purpose:** Seeds the random number generator. Typically seeded with `time(NULL)` from `<time.h>` to get different sequences each time.\n        * **Example:** `srand(time(NULL));`\n\n4.  **Process Control:**\n    * `void exit(int status)`:\n        * **Purpose:** Terminates the calling program normally. `status` is returned to the operating system (0 for success, non-zero for error).\n        * **Example:** `exit(EXIT_SUCCESS);` (where `EXIT_SUCCESS` is usually 0, `EXIT_FAILURE` is 1).\n    * `int system(const char *command)`:\n        * **Purpose:** Executes a system command. Returns the command's exit status.\n        * **Example:** `system(\"ls -l\");` (on Unix-like systems)\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h> // For time(NULL) to seed rand()\n\nint main() {\n    // Dynamic Memory Allocation\n    int *my_int_ptr = (int *) malloc(sizeof(int));\n    if (my_int_ptr == NULL) {\n        fprintf(stderr, \"Memory allocation failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n    *my_int_ptr = 100;\n    printf(\"Dynamically allocated int: %d\\n\", *my_int_ptr);\n    free(my_int_ptr);\n    my_int_ptr = NULL;\n\n    // String Conversion\n    char num_str[] = \"456\";\n    int converted_num = atoi(num_str);\n    printf(\"String '%s' converted to int: %d\\n\", num_str, converted_num);\n\n    char float_str[] = \"12.34\";\n    double converted_float = atof(float_str);\n    printf(\"String '%s' converted to float: %.2lf\\n\", float_str, converted_float);\n\n    // Random Number Generation\n    srand(time(NULL)); // Seed the random number generator once\n    printf(\"Random number 1: %d\\n\", rand());\n    printf(\"Random number 2 (0-99): %d\\n\", rand() % 100); // Generate 0-99\n\n    return EXIT_SUCCESS;\n}\n```\n\n`<stdlib.h>` is a fundamental header, providing crucial functionalities ranging from managing program memory to interacting with the operating system.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    int *data = (int *)calloc(5, sizeof(int)); // Allocate and initialize to zero\n    if (data == NULL) {\n        perror(\"Failed to allocate memory\");\n        return EXIT_FAILURE;\n    }\n    printf(\"Initial data[0]: %d\\n\", data[0]); // Should be 0\n\n    // Generate a random password\n    srand(time(NULL));\n    char password[11]; // 10 chars + null terminator\n    for (int i = 0; i < 10; i++) {\n        password[i] = 'A' + (rand() % 26); // Random uppercase letter\n    }\n    password[10] = '\\0';\n    printf(\"Random Password: %s\\n\", password);\n\n    free(data);\n    return EXIT_SUCCESS;\n}",
            "description": "Demonstrates using `calloc` for memory allocation, and `srand` with `rand` for generating a simple random password."
          }
        ]
      },
      {
        "id": "c-string",
        "title": "C `<string.h>` Reference",
        "description": "Commonly used functions for manipulating strings from the String Manipulation library (`string.h`).",
        "content": "The `<string.h>` header file provides a rich set of functions for manipulating null-terminated strings (character arrays) in C. These functions are essential for tasks like copying, concatenating, comparing, and searching within strings.\n\n### Key Functions in `<string.h>`:\n\n1.  **`size_t strlen(const char *str)`:**\n    * **Purpose:** Calculates the length of the string `str`, excluding the null terminator (`\\0`).\n    * **Returns:** The number of characters in the string.\n    * **Example:** `size_t len = strlen(\"Hello\"); // len is 5`\n\n2.  **`char *strcpy(char *dest, const char *src)`:**\n    * **Purpose:** Copies the string `src` (including the null terminator) to the buffer pointed to by `dest`.\n    * **Returns:** A pointer to `dest`.\n    * **Caution:** Does not perform bounds checking. **Highly prone to buffer overflows** if `dest` is not large enough. Prefer `strncpy` or safer alternatives like `snprintf`.\n    * **Example:** `strcpy(buffer, \"World\");`\n\n3.  **`char *strncpy(char *dest, const char *src, size_t n)`:**\n    * **Purpose:** Copies at most `n` characters from `src` to `dest`. If `src` is shorter than `n`, `dest` is padded with null bytes. **If `src` is longer than or equal to `n`, `dest` will NOT be null-terminated automatically.**\n    * **Returns:** A pointer to `dest`.\n    * **Example:** `strncpy(buffer, \"LongString\", sizeof(buffer) - 1); buffer[sizeof(buffer) - 1] = '\\0';`\n\n4.  **`char *strcat(char *dest, const char *src)`:**\n    * **Purpose:** Appends the string `src` to the end of the string `dest`. The null terminator of `dest` is overwritten by the first character of `src`.\n    * **Returns:** A pointer to `dest`.\n    * **Caution:** Like `strcpy`, highly prone to buffer overflows. Prefer `strncat` or safer alternatives.\n    * **Example:** `strcat(full_name, \" Doe\");`\n\n5.  **`char *strncat(char *dest, const char *src, size_t n)`:**\n    * **Purpose:** Appends at most `n` characters from `src` to `dest`. A null terminator is always appended if `dest` has room.\n    * **Returns:** A pointer to `dest`.\n\n6.  **`int strcmp(const char *str1, const char *str2)`:**\n    * **Purpose:** Compares two strings lexicographically.\n    * **Returns:**\n        * `0`: If `str1` and `str2` are equal.\n        * `< 0`: If `str1` is less than `str2`.\n        * `> 0`: If `str1` is greater than `str2`.\n    * **Example:** `if (strcmp(s1, s2) == 0)`\n\n7.  **`int strncmp(const char *str1, const char *str2, size_t n)`:**\n    * **Purpose:** Compares at most `n` characters of two strings lexicographically.\n    * **Returns:** Same as `strcmp`.\n\n8.  **`char *strchr(const char *str, int c)`:**\n    * **Purpose:** Searches for the first occurrence of the character `c` in the string `str`.\n    * **Returns:** A pointer to the first occurrence of `c`, or `NULL` if not found.\n    * **Example:** `char *ptr = strchr(\"Hello\", 'o');`\n\n9.  **`char *strstr(const char *haystack, const char *needle)`:**\n    * **Purpose:** Searches for the first occurrence of the substring `needle` in the string `haystack`.\n    * **Returns:** A pointer to the first occurrence of `needle`, or `NULL` if not found.\n    * **Example:** `char *sub = strstr(\"programming\", \"gram\");`\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char s1[50] = \"Hello\";\n    char s2[] = \" World\";\n    char s3[50];\n    char greeting[10] = \"\"; // Initialize empty string\n\n    printf(\"Length of s1: %zu\\n\", strlen(s1)); // Output: 5\n\n    // Copy s1 to s3\n    strcpy(s3, s1);\n    printf(\"s3 after strcpy: %s\\n\", s3); // Output: Hello\n\n    // Concatenate s2 to s1\n    strcat(s1, s2); // s1 becomes \"Hello World\"\n    printf(\"s1 after strcat: %s\\n\", s1); // Output: Hello World\n\n    // Compare strings\n    if (strcmp(s1, \"Hello World\") == 0) {\n        printf(\"s1 is 'Hello World'.\\n\");\n    }\n\n    // Search for a character\n    char *char_found = strchr(s1, 'o');\n    if (char_found) {\n        printf(\"First 'o' found at: %s\\n\", char_found); // Output: o World\n    }\n\n    // Search for a substring\n    char *sub_found = strstr(s1, \"Wor\");\n    if (sub_found) {\n        printf(\"Substring 'Wor' found at: %s\\n\", sub_found); // Output: World\n    }\n\n    // Using strncpy and strncat for safer operations\n    strncpy(greeting, \"Hi\", sizeof(greeting) - 1);\n    greeting[sizeof(greeting) - 1] = '\\0'; // Ensure null termination\n    printf(\"Greeting: %s (length %zu)\\n\", greeting, strlen(greeting));\n\n    strncat(greeting, \" there!\", sizeof(greeting) - strlen(greeting) - 1);\n    printf(\"Greeting after strncat: %s (length %zu)\\n\", greeting, strlen(greeting));\n\n    return 0;\n}\n```\n\nWhile `strcpy` and `strcat` are common, always prioritize their safer `_n` counterparts (`strncpy`, `strncat`) or functions like `snprintf` when dealing with fixed-size buffers to prevent security vulnerabilities like buffer overflows.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char source[] = \"Programming\";\n    char destination[20];\n\n    // Copy string\n    strcpy(destination, source);\n    printf(\"Copied: %s\\n\", destination);\n\n    // Concatenate another string\n    strcat(destination, \" in C\");\n    printf(\"Concatenated: %s\\n\", destination);\n\n    // Compare strings\n    if (strcmp(source, \"Programming\") == 0) {\n        printf(\"Source string is 'Programming'.\\n\");\n    }\n\n    printf(\"Length of destination: %zu\\n\", strlen(destination));\n    return 0;\n}",
            "description": "Demonstrates basic string operations: copying with `strcpy`, concatenating with `strcat`, comparing with `strcmp`, and getting length with `strlen`."
          }
        ]
      },
      {
        "id": "c-math",
        "title": "C `<math.h>` Reference",
        "description": "Commonly used mathematical functions from the Math library (`math.h`).",
        "content": "The `<math.h>` header file provides a collection of functions designed for common mathematical operations. These functions are typically overloaded for `float`, `double`, and `long double` types, but in C, they usually take `double` arguments and return `double` results. Remember to link the math library with `-lm` when compiling using GCC/Clang.\n\n### Key Functions in `<math.h>`:\n\n1.  **Exponential and Logarithmic Functions:**\n    * `double exp(double x)`: Returns $e^x$ (exponential function).\n    * `double log(double x)`: Returns the natural logarithm (base e) of `x`.\n    * `double log10(double x)`: Returns the base-10 logarithm of `x`.\n    * `double pow(double base, double exp)`: Returns `base` raised to the power of `exp`.\n    * `double sqrt(double x)`: Returns the non-negative square root of `x`.\n\n2.  **Trigonometric Functions (angles in radians):**\n    * `double sin(double x)`: Returns the sine of `x` (in radians).\n    * `double cos(double x)`: Returns the cosine of `x` (in radians).\n    * `double tan(double x)`: Returns the tangent of `x` (in radians).\n    * `double asin(double x)`: Returns the arcsine (inverse sine) of `x` (result in radians).\n    * `double acos(double x)`: Returns the arccosine (inverse cosine) of `x` (result in radians).\n    * `double atan(double x)`: Returns the arctangent (inverse tangent) of `x` (result in radians).\n    * `double atan2(double y, double x)`: Returns the arctangent of `y/x` using the signs of both arguments to determine the correct quadrant.\n\n3.  **Hyperbolic Functions:**\n    * `double sinh(double x)`: Returns the hyperbolic sine of `x`.\n    * `double cosh(double x)`: Returns the hyperbolic cosine of `x`.\n    * `double tanh(double x)`: Returns the hyperbolic tangent of `x`.\n\n4.  **Rounding and Absolute Value Functions:**\n    * `double ceil(double x)`: Returns the smallest integer value greater than or equal to `x` (rounds up).\n    * `double floor(double x)`: Returns the largest integer value less than or equal to `x` (rounds down).\n    * `double round(double x)`: Rounds `x` to the nearest integer. Halfway cases (e.g., 2.5) typically round away from zero.\n    * `double fabs(double x)`: Returns the absolute value of a floating-point number `x`.\n    * `double fmod(double x, double y)`: Returns the floating-point remainder of `x / y`.\n\n```c\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double num = 9.0;\n    printf(\"sqrt(%.1lf) = %.1lf\\n\", num, sqrt(num)); // Output: 3.0\n\n    double base = 2.0, exp = 3.0;\n    printf(\"%.1lf ^ %.1lf = %.1lf\\n\", base, exp, pow(base, exp)); // Output: 8.0\n\n    double angle_degrees = 45.0;\n    double angle_radians = angle_degrees * (M_PI / 180.0); // Convert degrees to radians\n    printf(\"sin(%.0lf degrees) = %.4lf\\n\", angle_degrees, sin(angle_radians));\n\n    double val = -5.7;\n    printf(\"fabs(%.1lf) = %.1lf\\n\", val, fabs(val)); // Output: 5.7\n    printf(\"ceil(%.1lf) = %.1lf\\n\", val, ceil(val));   // Output: -5.0\n    printf(\"floor(%.1lf) = %.1lf\\n\", val, floor(val)); // Output: -6.0\n    printf(\"round(%.1lf) = %.1lf\\n\", 2.5, round(2.5)); // Output: 3.0\n\n    return 0;\n}\n```\n\n**Compilation Note:** When compiling with GCC or Clang, you typically need to link the math library using the `-lm` flag:\n\n```bash\ngcc your_program.c -o your_program -lm\n```\n\n`<math.h>` is indispensable for any program requiring numerical computations, scientific simulations, or graphical applications.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double value = 16.0;\n    printf(\"Square root of %.1lf: %.1lf\\n\", value, sqrt(value));\n\n    double x = 4.0, y = 0.5;\n    printf(\"%.1lf to the power of %.1lf: %.1lf\\n\", x, y, pow(x, y)); // 4^0.5 = 2.0\n\n    double angle = M_PI / 6; // 30 degrees in radians\n    printf(\"Sine of PI/6: %.4lf\\n\", sin(angle));\n\n    printf(\"Ceiling of 7.2: %.1lf\\n\", ceil(7.2));\n    printf(\"Floor of 7.8: %.1lf\\n\", floor(7.8));\n\n    return 0;\n}",
            "description": "Demonstrates the use of `sqrt`, `pow`, `sin`, `ceil`, and `floor` functions from the `<math.h>` library for common mathematical calculations."
          }
        ]
      },
      {
        "id": "c-ctype",
        "title": "C `<ctype.h>` Reference",
        "description": "Commonly used functions for character testing and conversion from the Character Type library (`ctype.h`).",
        "content": "The `<ctype.h>` header file provides a set of functions that allow you to test characters for various properties (e.g., is it an alphabet, a digit, whitespace?) and to convert character case (uppercase to lowercase, and vice-versa). These functions are particularly useful when parsing input, validating data, or manipulating text.\n\n### Key Functions in `<ctype.h>`:\n\nAll functions in `<ctype.h>` take an `int` argument (representing a character's ASCII value) and return an `int`. They return a non-zero (true) value if the condition is met, and `0` (false) otherwise.\n\n1.  **Character Testing Functions:**\n    * `int isalnum(int c)`: Returns true if `c` is an alphanumeric character (letter or digit).\n    * `int isalpha(int c)`: Returns true if `c` is an an alphabetic character (letter).\n    * `int isblank(int c)`: Returns true if `c` is a blank character (space or horizontal tab).\n    * `int iscntrl(int c)`: Returns true if `c` is a control character (non-printable ASCII characters like newline, tab, etc.).\n    * `int isdigit(int c)`: Returns true if `c` is a decimal digit (0-9).\n    * `int isgraph(int c)`: Returns true if `c` is any printable character except space.\n    * `int islower(int c)`: Returns true if `c` is a lowercase letter.\n    * `int isprint(int c)`: Returns true if `c` is a printable character (including space).\n    * `int ispunct(int c)`: Returns true if `c` is a punctuation character (any printable character that is not a space or an alphanumeric character).\n    * `int isspace(int c)`: Returns true if `c` is a whitespace character (space, form feed, newline, carriage return, horizontal tab, vertical tab).\n    * `int isupper(int c)`: Returns true if `c` is an uppercase letter.\n    * `int isxdigit(int c)`: Returns true if `c` is a hexadecimal digit (0-9, a-f, A-F).\n\n2.  **Character Conversion Functions:**\n    * `int tolower(int c)`:\n        * **Purpose:** Converts an uppercase letter to its lowercase equivalent. If `c` is not an uppercase letter, it's returned unchanged.\n        * **Example:** `char lower_ch = tolower('B'); // lower_ch is 'b'`\n    * `int toupper(int c)`:\n        * **Purpose:** Converts a lowercase letter to its uppercase equivalent. If `c` is not a lowercase letter, it's returned unchanged.\n        * **Example:** `char upper_ch = toupper('c'); // upper_ch is 'C'`\n\n```c\n#include <stdio.h>\n#include <ctype.h> // Required for ctype functions\n\nint main() {\n    char ch1 = 'A';\n    char ch2 = '7';\n    char ch3 = '$';\n    char ch4 = ' '; // Space character\n\n    printf(\"--- Character Testing ---\\n\");\n    printf(\"'%c' is alpha? %d\\n\", ch1, isalpha(ch1));     // Output: 1\n    printf(\"'%c' is digit? %d\\n\", ch2, isdigit(ch2));     // Output: 1\n    printf(\"'%c' is alphanumeric? %d\\n\", ch1, isalnum(ch1)); // Output: 1\n    printf(\"'%c' is alphanumeric? %d\\n\", ch2, isalnum(ch2)); // Output: 1\n    printf(\"'%c' is alphanumeric? %d\\n\", ch3, isalnum(ch3)); // Output: 0\n    printf(\"'%c' is space? %d\\n\", ch4, isspace(ch4));     // Output: 1\n    printf(\"'%c' is punctuation? %d\\n\", ch3, ispunct(ch3)); // Output: 1\n\n    printf(\"\\n--- Character Conversion ---\\n\");\n    char mixed_char = 'k';\n    printf(\"Lowercase '%c' to uppercase: %c\\n\", mixed_char, toupper(mixed_char)); // Output: K\n\n    mixed_char = 'L';\n    printf(\"Uppercase '%c' to lowercase: %c\\n\", mixed_char, tolower(mixed_char)); // Output: l\n\n    // Example: Convert a string to uppercase\n    char text[] = \"Hello World123!\";\n    printf(\"Original: %s\\n\", text);\n    for (int i = 0; text[i] != '\\0'; i++) {\n        text[i] = toupper(text[i]);\n    }\n    printf(\"Uppercase: %s\\n\", text); // Output: HELLO WORLD123!\n\n    return 0;\n}\n```\n\nThese functions simplify character-based manipulations and validations, making your code more robust and readable when dealing with textual data.",
        "codeExamples": [
          {
            "lang": "c",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint main() {\n    char input_char = '5';\n    if (isdigit(input_char)) {\n        printf(\"'%c' is a digit.\\n\", input_char);\n    }\n\n    char upper_char = 'x';\n    printf(\"Uppercase of '%c' is '%c'.\\n\", upper_char, toupper(upper_char));\n\n    char sentence[] = \"Hi There!\";\n    printf(\"Original sentence: %s\\n\", sentence);\n    for (int i = 0; i < strlen(sentence); i++) {\n        if (islower(sentence[i])) {\n            sentence[i] = toupper(sentence[i]);\n        }\n    }\n    printf(\"Sentence in uppercase: %s\\n\", sentence);\n\n    return 0;\n}",
            "description": "Demonstrates `isdigit` for character testing, `toupper` for character conversion, and iterating through a string to convert lowercase letters to uppercase."
          }
        ]
      }
  ]
  